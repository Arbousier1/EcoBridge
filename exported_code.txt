
==================================================
FILE: ecobridge-java\build.gradle.kts
==================================================

import com.github.jengelman.gradle.plugins.shadow.tasks.ShadowJar
import java.util.Properties
buildscript {
repositories {
central()
gradlePluginPortal()
}
dependencies {
// ASM 9.9.1: 完美支持 Java 25 预览版字节码，确保 shadowJar 正常工作
classpath("org.ow2.asm:asm-commons:9.9.1")
}
}
plugins {
`java-library`
id("com.gradleup.shadow") version "8.3.5" // 建议使用稳定版，或保持您的 9.3.1
idea
}
group = "top.ellan"
version = "1.0-SNAPSHOT"
// --- [jextract 自动化配置逻辑] ---
val rustHeaderFile = file("${projectDir}/../ecobridge-rust/ecobridge_rust.h")
val generatedSourceDir = layout.buildDirectory.dir("generated/sources/jextract")
val targetPackage = "top.ellan.ecobridge.gen"
/**
* 自动寻找 jextract 可执行文件
*/
fun findJextract(): String {
val os = org.gradle.internal.os.OperatingSystem.current()
val binaryName = if (os.isWindows) "jextract.bat" else "jextract"
val envHome = System.getenv("JEXTRACT_HOME")
if (!envHome.isNullOrBlank()) {
val path = file("$envHome/bin/$binaryName")
if (path.exists()) return path.absolutePath
}
val localPropsFile = file("local.properties")
if (localPropsFile.exists()) {
val props = Properties()
localPropsFile.inputStream().use { props.load(it) }
val localHome = props.getProperty("jextract.home")
if (localHome != null) {
val possiblePaths = listOf(file("$localHome/bin/$binaryName"), file("$localHome/$binaryName"))
for (path in possiblePaths) if (path.exists()) return path.absolutePath
}
}
return binaryName
}
val generateBindings = tasks.register<Exec>("generateBindings") {
group = "build"
description = "使用 jextract 自动从 Rust 头文件生成 Java FFM 绑定。"
doFirst {
if (!rustHeaderFile.exists()) {
throw GradleException("❌ 错误：未找到 Rust 头文件: ${rustHeaderFile.absolutePath}")
}
generatedSourceDir.get().asFile.mkdirs()
}
commandLine(
findJextract(),
"--output", generatedSourceDir.get().asFile.absolutePath,
"--target-package", targetPackage,
"--header-class-name", "ecobridge_rust_h",
// ✅ 关键修改：移除了 --library 参数。
// 这将防止生成的 Java 类在静态块中自动调用 System.loadLibrary()。
// 现在加载权完全交给了您的 NativeLoader。
rustHeaderFile.absolutePath
)
inputs.file(rustHeaderFile)
outputs.dir(generatedSourceDir)
}
// IntelliJ 配置：支持生成的代码高亮与跳转
idea {
module {
generatedSourceDirs.add(generatedSourceDir.get().asFile)
}
}
// --- [Java 环境与工具链] ---
java {
toolchain {
languageVersion.set(JavaLanguageVersion.of(25))
}
}
sourceSets {
main {
java.srcDir(generateBindings)
}
}
// --- [仓库配置] ---
repositories {
mavenCentral()
// 核心库与预发布库
maven("https://central.sonatype.com/repository/maven-snapshots/")
maven("https://oss.sonatype.org/content/repositories/releases/")
// 三方插件与 API
maven("https://jitpack.io")
maven("https://repo.papermc.io/repository/maven-public/")
maven("https://repo.nightexpressdev.com/releases")
maven("https://repo.lanink.cn/repository/maven-public/")
maven("https://repo.extendedclip.com/content/repositories/placeholderapi/")
flatDir { dirs("libs") }
}
dependencies {
// Minecraft & 插件 API
compileOnly("io.papermc.paper:paper-api:1.21.1-R0.1-SNAPSHOT")
compileOnly("me.clip:placeholderapi:2.11.6")
compileOnly("su.nightexpress.nightcore:main:2.13.0")
compileOnly("su.nightexpress.coinsengine:CoinsEngine:2.6.0")
compileOnly("cn.superiormc.ultimateshop:plugin:4.2.3")
compileOnly(fileTree(mapOf("dir" to "libs", "include" to listOf("**/*.jar"))))
// Jackson 3.0 BOM (处理 JSON)
implementation(platform("tools.jackson:jackson-bom:3.0.0"))
implementation("tools.jackson.core:jackson-databind")
implementation("tools.jackson.core:jackson-core")
implementation("com.fasterxml.jackson.core:jackson-annotations")
// 数据库与缓存
implementation("org.mariadb.jdbc:mariadb-java-client:3.5.7")
implementation("com.zaxxer:HikariCP:7.0.2")
implementation("com.github.ben-manes.caffeine:caffeine:3.2.3")
implementation("redis.clients:jedis:5.2.0") // 建议使用 5.x 稳定版，7.x 尚在早期
compileOnly("com.google.code.gson:gson:2.11.0")
// 测试
testImplementation(platform("org.junit:junit-bom:5.11.0"))
testImplementation("org.junit.jupiter:junit-jupiter")
}
tasks.withType<JavaCompile> {
dependsOn(generateBindings)
options.encoding = "UTF-8"
options.release.set(25)
options.compilerArgs.addAll(listOf(
"--enable-preview",
"-Xlint:unchecked",
"-Xlint:-preview"
))
}
tasks.named<ShadowJar>("shadowJar") {
archiveClassifier.set("")
val prefix = "top.ellan.ecobridge.libs"
// 重定向以避免与其他插件版本冲突
relocate("tools.jackson", "$prefix.jackson")
relocate("com.fasterxml.jackson.annotation", "$prefix.jackson.annotations")
relocate("com.zaxxer.hikari", "$prefix.hikari")
relocate("org.mariadb.jdbc", "$prefix.mariadb")
//relocate("com.github.benmanes.caffeine", "$prefix.caffeine")
relocate("redis.clients", "$prefix.jedis")
// 打包原生库资源文件
from("src/main/resources") {
include("*.dll", "*.so", "*.dylib", "natives/**")
}
mergeServiceFiles()
minimize {
exclude(dependency("org.mariadb.jdbc:.*"))
}
}
tasks.withType<ProcessResources> {
val props = mapOf("version" to project.version)
inputs.properties(props)
filesMatching("plugin.yml") {
expand(props)
}
}

==================================================
FILE: ecobridge-java\settings.gradle.kts
==================================================

rootProject.name = "EcoBridge"

==================================================
FILE: ecobridge-java\src\main\java\top\ellan\ecobridge\EcoBridge.java
==================================================

package top.ellan.ecobridge;
import net.kyori.adventure.text.minimessage.MiniMessage;
import net.kyori.adventure.text.minimessage.tag.resolver.TagResolver;
import org.bukkit.Bukkit;
import org.bukkit.event.EventHandler;
import org.bukkit.event.Listener;
import org.bukkit.event.player.PlayerJoinEvent;
import org.bukkit.event.player.PlayerQuitEvent;
import org.bukkit.plugin.java.JavaPlugin;
import top.ellan.ecobridge.bridge.NativeBridge;
import top.ellan.ecobridge.cache.HotDataCache;
import top.ellan.ecobridge.command.TransferCommand;
import top.ellan.ecobridge.database.DatabaseManager;
import top.ellan.ecobridge.hook.EcoPlaceholderExpansion;
import top.ellan.ecobridge.hook.UShopHookManager;
import top.ellan.ecobridge.listener.CacheListener;
import top.ellan.ecobridge.listener.CoinsEngineListener;
import top.ellan.ecobridge.listener.CommandInterceptor;
import top.ellan.ecobridge.listener.TradeListener;
import top.ellan.ecobridge.manager.*;
import top.ellan.ecobridge.network.RedisManager;
import top.ellan.ecobridge.storage.ActivityCollector;
import top.ellan.ecobridge.storage.AsyncLogger;
import top.ellan.ecobridge.util.HolidayManager;
import top.ellan.ecobridge.util.LogUtil;
import java.util.concurrent.ExecutorService;
import java.util.concurrent.Executors;
import java.util.concurrent.TimeUnit;
import java.util.concurrent.atomic.AtomicBoolean;
public final class EcoBridge extends JavaPlugin implements Listener {
private static volatile EcoBridge instance;
private static final MiniMessage MM = MiniMessage.miniMessage();
private ExecutorService virtualExecutor;
private final AtomicBoolean fullyInitialized = new AtomicBoolean(false);
@Override
public void onEnable() {
instance = this;
this.virtualExecutor = Executors.newVirtualThreadPerTaskExecutor();
try {
bootstrapInfrastructure();
ActivityCollector.startHeartbeat(this);
printBanner();
} catch (Exception e) {
getLogger().severe("基础架构引导失败: " + e.getMessage());
Bukkit.getPluginManager().disablePlugin(this);
return;
}
if (!verifyDependencies()) return;
try {
EconomyManager.init(this);
NativeBridge.init(this);
EconomicStateManager.init(this);
PricingManager.init(this);
TransferManager.init(this);
registerCommands();
registerListeners();
registerHooks();
getServer().getScheduler().runTaskLater(this, () -> {
if (getServer().getPluginManager().isPluginEnabled("UltimateShop")) {
LogUtil.info("检测到 UltimateShop，执行统一内核接管...");
UShopHookManager.execute(this);
}
}, 30L);
this.fullyInitialized.set(true);
sendConsole("<blue>┃ <green>系统状态: <white>宏观自适应演算内核已上线 (v0.9.4) <blue>┃");
sendConsole("<gradient:aqua:blue>┗━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━┛</gradient>");
} catch (Throwable e) {
LogUtil.error("致命错误: 初始化拓扑崩溃", e);
Bukkit.getPluginManager().disablePlugin(this);
}
}
@Override
public void onDisable() {
shutdownSequence();
instance = null;
}
private void shutdownSequence() {
if (!fullyInitialized.getAndSet(false)) return;
sendConsole("<yellow>[EcoBridge] 正在启动安全关机序列 (Atomic-Safe Shutdown)...");
try {
UShopHookManager.revert();
if (RedisManager.getInstance() != null) RedisManager.getInstance().shutdown();
HolidayManager.shutdown();
if (PricingManager.getInstance() != null) PricingManager.getInstance().shutdown();
if (EconomyManager.getInstance() != null) EconomyManager.getInstance().shutdown();
if (AsyncLogger.getInstance() != null) AsyncLogger.getInstance().shutdown();
LogUtil.info("正在执行最终数据同步 (Sync Cache Save)...");
HotDataCache.saveAllSync();
NativeBridge.shutdown();
terminateVirtualPool();
DatabaseManager.close();
getServer().getScheduler().cancelTasks(this);
sendConsole("<red>[EcoBridge] 所有系统资源已安全回收。逻辑屏障已关闭。");
} catch (Exception e) {
System.err.println("[EcoBridge] 关机序列异常，可能存在资源泄漏: " + e.getMessage());
}
}
private void bootstrapInfrastructure() {
saveDefaultConfig();
LogUtil.init();
DatabaseManager.init();
AsyncLogger.init(this);
HolidayManager.init();
RedisManager.init(this);
}
private void terminateVirtualPool() {
if (virtualExecutor != null && !virtualExecutor.isShutdown()) {
virtualExecutor.shutdown();
try {
if (!virtualExecutor.awaitTermination(5, TimeUnit.SECONDS)) {
virtualExecutor.shutdownNow();
}
} catch (InterruptedException e) {
virtualExecutor.shutdownNow();
Thread.currentThread().interrupt();
}
}
}
private boolean verifyDependencies() {
var pm = Bukkit.getPluginManager();
if (!pm.isPluginEnabled("CoinsEngine")) {
sendConsole("<blue>┃ <red>致命错误: 未检测到必要依赖 CoinsEngine。 <blue>┃");
pm.disablePlugin(this);
return false;
}
return true;
}
private void registerListeners() {
var pm = getServer().getPluginManager();
pm.registerEvents(this, this);
pm.registerEvents(new CoinsEngineListener(this), this);
pm.registerEvents(new CommandInterceptor(this), this);
pm.registerEvents(new TradeListener(this), this);
pm.registerEvents(new CacheListener(), this);
}
private void registerHooks() {
if (getServer().getPluginManager().isPluginEnabled("PlaceholderAPI")) {
new EcoPlaceholderExpansion(this).register();
}
}
private void registerCommands() {
var cmd = getCommand("ecopay");
if (cmd != null) cmd.setExecutor(new TransferCommand());
}
public void reload() {
reloadConfig();
LogUtil.init();
if (EconomyManager.getInstance() != null) EconomyManager.getInstance().loadState();
if (PricingManager.getInstance() != null) PricingManager.getInstance().loadConfig();
if (getServer().getPluginManager().isPluginEnabled("UltimateShop")) {
UShopHookManager.execute(this);
}
sendConsole("<green>[EcoBridge] 逻辑配置参数重载成功。");
}
@EventHandler public void onJoin(PlayerJoinEvent event) { ActivityCollector.updateSnapshot(event.getPlayer()); }
@EventHandler public void onQuit(PlayerQuitEvent event) { ActivityCollector.removePlayer(event.getPlayer().getUniqueId()); }
public static EcoBridge getInstance() { return instance; }
public ExecutorService getVirtualExecutor() { return virtualExecutor; }
public static MiniMessage getMiniMessage() { return MM; }
public boolean isFullyInitialized() { return fullyInitialized.get(); }
private void printBanner() {
String version = getPluginMeta().getVersion();
sendConsole("<gradient:aqua:blue>┏━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━┓</gradient>");
sendConsole("<blue>┃ <green>EcoBridge <white>v" + version + " <gray>| <aqua>Macro Adaptive Edition <blue>┃");
}
private void sendConsole(String msg, TagResolver... resolvers) {
Bukkit.getConsoleSender().sendMessage(MM.deserialize(msg, resolvers));
}
}

==================================================
FILE: ecobridge-java\src\main\java\top\ellan\ecobridge\api\UShopProvider.java
==================================================

package top.ellan.ecobridge.api;
import cn.superiormc.ultimateshop.objects.buttons.ObjectItem;
import org.bukkit.entity.Player;
import top.ellan.ecobridge.bridge.NativeBridge;
import top.ellan.ecobridge.manager.PricingManager;
import top.ellan.ecobridge.util.PriceOracle;
public final class UShopProvider {
public static double calculateDynamicPrice(Player player, ObjectItem item, int amount) {
if (player == null || item == null) return 0.0;
if (!PriceOracle.isValidEconomyItem(item)) {
return PriceOracle.getOriginalBasePrice(item, amount < 0);
}
if (!NativeBridge.isLoaded()) {
return PriceOracle.getOriginalBasePrice(item, amount < 0);
}
double unitPrice = PricingManager.getInstance().getSnapshotPrice(
item.getShop(),
item.getProduct()
);
if (unitPrice <= 0) {
double p0 = PriceOracle.getOriginalBasePrice(item, amount < 0);
return p0 > 0 ? p0 : 0.0;
}
return unitPrice * Math.abs(amount);
}
}

==================================================
FILE: ecobridge-java\src\main\java\top\ellan\ecobridge\api\event\PriceCalculatedEvent.java
==================================================

package top.ellan.ecobridge.api.event;
import net.kyori.adventure.text.Component;
import net.kyori.adventure.text.minimessage.tag.resolver.Placeholder;
import org.bukkit.entity.Player;
import org.bukkit.event.Event;
import org.bukkit.event.HandlerList;
import org.jetbrains.annotations.NotNull;
import org.jetbrains.annotations.Nullable;
import top.ellan.ecobridge.EcoBridge;
import java.util.ArrayList;
import java.util.Collections;
import java.util.List;
import java.util.function.UnaryOperator;
public class PriceCalculatedEvent extends Event {
private static final HandlerList handlers = new HandlerList();
private final @Nullable Player player;
private final String shopId;
private final String productId;
private final double rustBasePrice;
private volatile double finalPrice;
private final List<String> modificationLog = new ArrayList<>(4);
public PriceCalculatedEvent(@Nullable Player player, @NotNull String shopId, @NotNull String productId, double calculated) {
super(false);
this.player = player;
this.shopId = shopId;
this.productId = productId;
this.rustBasePrice = calculated;
this.finalPrice = calculated;
this.modificationLog.add("EcoKernel-v0.8.9");
}
public @Nullable Player getPlayer() { return player; }
@NotNull
public String getShopId() { return shopId; }
@NotNull
public String getProductId() { return productId; }
public double getRustBasePrice() { return rustBasePrice; }
public double getFinalPrice() { return finalPrice; }
public synchronized void modifyPrice(@NotNull String source, @NotNull UnaryOperator<Double> modifier) {
double oldPrice = this.finalPrice;
this.finalPrice = Math.max(0.01, modifier.apply(this.finalPrice));
if (Double.compare(oldPrice, finalPrice) != 0) {
this.modificationLog.add(source);
}
}
public synchronized void setFinalPrice(double finalPrice, @NotNull String source) {
this.finalPrice = Math.max(0.01, finalPrice);
this.modificationLog.add(source + "(Overwrite)");
}
public synchronized boolean isModified() {
return modificationLog.size() > 1;
}
@NotNull
public synchronized List<String> getModificationLog() {
return Collections.unmodifiableList(new ArrayList<>(modificationLog));
}
@NotNull
public Component toComponent() {
String lastSource;
double currentFinal;
boolean modified;
synchronized (this) {
if (modificationLog.isEmpty()) {
lastSource = "Unknown";
} else {
lastSource = modificationLog.get(modificationLog.size() - 1);
}
currentFinal = this.finalPrice;
modified = modificationLog.size() > 1;
}
String template = modified
? "<gray>[EcoBridge] <white><product> <yellow><final> <dark_gray>(原:<base>, 改自:<source>)"
: "<gray>[EcoBridge] <white><product> <green><final> <dark_gray>(物理定价)";
return EcoBridge.getMiniMessage().deserialize(template,
Placeholder.unparsed("product", productId),
Placeholder.unparsed("final", String.format("%.2f", currentFinal)),
Placeholder.unparsed("base", String.format("%.2f", rustBasePrice)),
Placeholder.unparsed("source", lastSource)
);
}
@NotNull
@Override
public HandlerList getHandlers() { return handlers; }
public static HandlerList getHandlerList() { return handlers; }
}

==================================================
FILE: ecobridge-java\src\main\java\top\ellan\ecobridge\bridge\NativeBridge.java
==================================================

package top.ellan.ecobridge.bridge;
import top.ellan.ecobridge.EcoBridge;
import top.ellan.ecobridge.gen.*;
import top.ellan.ecobridge.util.LogUtil;
import java.lang.foreign.*;
import java.lang.invoke.MethodHandle;
import java.lang.invoke.VarHandle;
import static java.lang.foreign.ValueLayout.*;
public class NativeBridge {
private static final int EXPECTED_ABI_VERSION = 0x0009_0000;
private static Arena bridgeArena;
public static final int CODE_NORMAL = 0;
public static final int CODE_WARNING_HIGH_RISK = 1;
public static final int CODE_BLOCK_REVERSE_FLOW = 2;
public static final int CODE_BLOCK_INJECTION = 3;
public static final int CODE_BLOCK_INSUFFICIENT_FUNDS = 4;
public static final int CODE_BLOCK_VELOCITY_LIMIT = 5;
private static volatile MethodHandle getAbiVersionMH;
private static volatile MethodHandle initDBMH;
private static volatile MethodHandle getVersionMH;
private static volatile MethodHandle getHealthStatsMH;
private static volatile MethodHandle shutdownDBMH;
private static volatile MethodHandle pushToDuckDBMH;
private static volatile MethodHandle queryNeffVectorizedMH;
private static volatile MethodHandle computePriceMH;
private static volatile MethodHandle calculateEpsilonMH;
private static volatile MethodHandle checkTransferMH;
private static volatile MethodHandle computePidMH;
private static volatile MethodHandle resetPidMH;
private static volatile MethodHandle calcInflationMH;
private static volatile MethodHandle calcStabilityMH;
private static volatile MethodHandle calcDecayMH;
private static volatile MethodHandle computeTierPriceMH;
private static volatile MethodHandle computePriceBoundedMH;
private static volatile MethodHandle computeBatchPricesMH;
public static final VarHandle VH_CTX_BASE_PRICE;
public static final VarHandle VH_CTX_CURR_AMT;
public static final VarHandle VH_CTX_INF_RATE;
public static final VarHandle VH_CTX_TIMESTAMP;
public static final VarHandle VH_CTX_PLAY_TIME;
public static final VarHandle VH_CTX_TIMEZONE_OFFSET;
public static final VarHandle VH_CTX_NEWBIE_MASK;
public static final VarHandle VH_CTX_MARKET_HEAT;
public static final VarHandle VH_CTX_ECO_SAT;
public static final VarHandle VH_CFG_LAMBDA;
public static final VarHandle VH_CFG_VOLATILITY;
public static final VarHandle VH_CFG_S_AMP;
public static final VarHandle VH_CFG_W_MULT;
public static final VarHandle VH_CFG_N_PROT;
public static final VarHandle VH_CFG_W_SEASONAL;
public static final VarHandle VH_CFG_W_WEEKEND;
public static final VarHandle VH_CFG_W_NEWBIE;
public static final VarHandle VH_CFG_W_INFLATION;
public static final VarHandle VH_TCTX_ACTIVITY_SCORE;
public static final VarHandle VH_TCTX_VELOCITY;
public static final VarHandle VH_RCFG_V_THRESHOLD;
private static final VarHandle VH_RES_TAX;
private static final VarHandle VH_RES_BLOCKED;
private static final VarHandle VH_RES_CODE;
static {
try {
GroupLayout ctxLayout = TradeContext.layout();
VH_CTX_BASE_PRICE = ctxLayout.varHandle(MemoryLayout.PathElement.groupElement("base_price"));
VH_CTX_CURR_AMT = ctxLayout.varHandle(MemoryLayout.PathElement.groupElement("current_amount"));
VH_CTX_INF_RATE = ctxLayout.varHandle(MemoryLayout.PathElement.groupElement("inflation_rate"));
VH_CTX_TIMESTAMP = ctxLayout.varHandle(MemoryLayout.PathElement.groupElement("current_timestamp"));
VH_CTX_PLAY_TIME = ctxLayout.varHandle(MemoryLayout.PathElement.groupElement("play_time_seconds"));
VH_CTX_TIMEZONE_OFFSET = ctxLayout.varHandle(MemoryLayout.PathElement.groupElement("timezone_offset"));
VH_CTX_NEWBIE_MASK = ctxLayout.varHandle(MemoryLayout.PathElement.groupElement("newbie_mask"));
VH_CTX_MARKET_HEAT = ctxLayout.varHandle(MemoryLayout.PathElement.groupElement("market_heat"));
VH_CTX_ECO_SAT = ctxLayout.varHandle(MemoryLayout.PathElement.groupElement("eco_saturation"));
GroupLayout cfgLayout = MarketConfig.layout();
VH_CFG_LAMBDA = cfgLayout.varHandle(MemoryLayout.PathElement.groupElement("base_lambda"));
VH_CFG_VOLATILITY = cfgLayout.varHandle(MemoryLayout.PathElement.groupElement("volatility_factor"));
VH_CFG_S_AMP = cfgLayout.varHandle(MemoryLayout.PathElement.groupElement("seasonal_amplitude"));
VH_CFG_W_MULT = cfgLayout.varHandle(MemoryLayout.PathElement.groupElement("weekend_multiplier"));
VH_CFG_N_PROT = cfgLayout.varHandle(MemoryLayout.PathElement.groupElement("newbie_protection_rate"));
VH_CFG_W_SEASONAL = cfgLayout.varHandle(MemoryLayout.PathElement.groupElement("seasonal_weight"));
VH_CFG_W_WEEKEND = cfgLayout.varHandle(MemoryLayout.PathElement.groupElement("weekend_weight"));
VH_CFG_W_NEWBIE = cfgLayout.varHandle(MemoryLayout.PathElement.groupElement("newbie_weight"));
VH_CFG_W_INFLATION = cfgLayout.varHandle(MemoryLayout.PathElement.groupElement("inflation_weight"));
GroupLayout tCtxLayout = TransferContext.layout();
VH_TCTX_ACTIVITY_SCORE = tCtxLayout.varHandle(MemoryLayout.PathElement.groupElement("sender_activity_score"));
VH_TCTX_VELOCITY = tCtxLayout.varHandle(MemoryLayout.PathElement.groupElement("sender_velocity"));
GroupLayout rCfgLayout = RegulatorConfig.layout();
VH_RCFG_V_THRESHOLD = rCfgLayout.varHandle(MemoryLayout.PathElement.groupElement("velocity_threshold"));
GroupLayout resLayout = top.ellan.ecobridge.gen.TransferResult.layout();
VH_RES_TAX = resLayout.varHandle(MemoryLayout.PathElement.groupElement("final_tax"));
VH_RES_BLOCKED = resLayout.varHandle(MemoryLayout.PathElement.groupElement("is_blocked"));
VH_RES_CODE = resLayout.varHandle(MemoryLayout.PathElement.groupElement("warning_code"));
} catch (Exception e) {
throw new RuntimeException("CRITICAL: FFM Memory Layout Initialization Failed! Check your Rust structs.", e);
}
}
public static synchronized void init(EcoBridge plugin) {
if (isLoaded()) return;
try {
NativeLoader.load(plugin);
Linker linker = Linker.nativeLinker();
getAbiVersionMH = bind(linker, "ecobridge_abi_version", FunctionDescriptor.of(JAVA_INT));
int nativeVersion = (int) getAbiVersionMH.invokeExact();
if (nativeVersion != EXPECTED_ABI_VERSION) {
throw new IllegalStateException(String.format("ABI Mismatch! Java=0x%08X, Native=0x%08X. Please rebuild native libs.", EXPECTED_ABI_VERSION, nativeVersion));
}
initDBMH = bind(linker, "ecobridge_init_db", FunctionDescriptor.of(JAVA_INT, ADDRESS));
getVersionMH = bind(linker, "ecobridge_version", FunctionDescriptor.of(ADDRESS));
getHealthStatsMH = bind(linker, "ecobridge_get_health_stats", FunctionDescriptor.ofVoid(ADDRESS, ADDRESS));
shutdownDBMH = bind(linker, "ecobridge_shutdown_db", FunctionDescriptor.of(JAVA_INT));
pushToDuckDBMH = bind(linker, "ecobridge_log_to_duckdb", FunctionDescriptor.ofVoid(JAVA_LONG, ADDRESS, JAVA_DOUBLE, JAVA_DOUBLE, ADDRESS));
queryNeffVectorizedMH = bind(linker, "ecobridge_query_neff_vectorized", FunctionDescriptor.of(JAVA_DOUBLE, JAVA_LONG, JAVA_DOUBLE));
computePriceMH = bind(linker, "ecobridge_compute_price_humane", FunctionDescriptor.of(JAVA_DOUBLE, JAVA_DOUBLE, JAVA_DOUBLE, JAVA_DOUBLE, JAVA_DOUBLE));
calculateEpsilonMH = bind(linker, "ecobridge_calculate_epsilon", FunctionDescriptor.of(JAVA_DOUBLE, ADDRESS, ADDRESS));
checkTransferMH = bind(linker, "ecobridge_compute_transfer_check", FunctionDescriptor.ofVoid(ADDRESS, ADDRESS, ADDRESS));
computePidMH = bind(linker, "ecobridge_compute_pid_adjustment", FunctionDescriptor.of(JAVA_DOUBLE, ADDRESS, JAVA_DOUBLE, JAVA_DOUBLE, JAVA_DOUBLE, JAVA_DOUBLE, JAVA_DOUBLE));
resetPidMH = bind(linker, "ecobridge_reset_pid_state", FunctionDescriptor.ofVoid(ADDRESS));
calcInflationMH = bind(linker, "ecobridge_calc_inflation", FunctionDescriptor.of(JAVA_DOUBLE, JAVA_DOUBLE, JAVA_DOUBLE));
calcStabilityMH = bind(linker, "ecobridge_calc_stability", FunctionDescriptor.of(JAVA_DOUBLE, JAVA_LONG, JAVA_LONG));
calcDecayMH = bind(linker, "ecobridge_calc_decay", FunctionDescriptor.of(JAVA_DOUBLE, JAVA_DOUBLE, JAVA_DOUBLE));
computeTierPriceMH = bind(linker, "ecobridge_compute_tier_price", FunctionDescriptor.of(JAVA_DOUBLE, JAVA_DOUBLE, JAVA_DOUBLE, JAVA_BOOLEAN));
computePriceBoundedMH = bind(linker, "ecobridge_compute_price_bounded", FunctionDescriptor.of(JAVA_DOUBLE, JAVA_DOUBLE, JAVA_DOUBLE, JAVA_DOUBLE, JAVA_DOUBLE, JAVA_DOUBLE, JAVA_DOUBLE));
computeBatchPricesMH = bind(linker, "ecobridge_compute_batch_prices", FunctionDescriptor.ofVoid(JAVA_LONG, JAVA_DOUBLE, ADDRESS, ADDRESS, ADDRESS, ADDRESS, ADDRESS));
try (Arena arena = Arena.ofConfined()) {
String dataPath = plugin.getDataFolder().getAbsolutePath();
int result = (int) initDBMH.invokeExact(arena.allocateFrom(dataPath));
if (result != 0 && result != -3) {
throw new IllegalStateException("Rust Engine DB Initialization Failed: Error Code " + result);
}
}
bridgeArena = Arena.ofShared();
MemorySegment v = (MemorySegment) getVersionMH.invokeExact();
LogUtil.info("<green>Native engine loaded successfully! Version: " + v.getString(0));
} catch (Throwable e) {
LogUtil.error("FATAL: Native Bridge failed to initialize.", e);
shutdown();
}
}
private static MethodHandle bind(Linker linker, String name, FunctionDescriptor desc) {
return NativeLoader.findSymbol(name)
.map(symbol -> linker.downcallHandle(symbol, desc))
.orElseThrow(() -> new UnsatisfiedLinkError("CRITICAL: Failed to find symbol in native library: " + name));
}
public static boolean isLoaded() {
return NativeLoader.isReady() && bridgeArena != null;
}
public static synchronized void shutdown() {
if (isLoaded()) {
try {
if (shutdownDBMH != null) shutdownDBMH.invokeExact();
} catch (Throwable t) {
LogUtil.error("Error during native database shutdown.", t);
} finally {
if (bridgeArena != null) {
bridgeArena.close();
bridgeArena = null;
}
NativeLoader.unload();
clearMethodHandles();
}
}
}
private static void clearMethodHandles() {
getAbiVersionMH = null; initDBMH = null; getVersionMH = null;
getHealthStatsMH = null; shutdownDBMH = null; pushToDuckDBMH = null;
queryNeffVectorizedMH = null; computePriceMH = null; calculateEpsilonMH = null;
checkTransferMH = null; computePidMH = null; resetPidMH = null;
calcInflationMH = null; calcStabilityMH = null; calcDecayMH = null;
computeTierPriceMH = null; computePriceBoundedMH = null; computeBatchPricesMH = null;
}
public static double calcInflation(double heat, double m1) {
if (!isLoaded()) return 0.0;
try { return (double) calcInflationMH.invokeExact(heat, m1); } catch (Throwable t) { return 0.0; }
}
public static double calcStability(long lastTs, long currTs) {
if (!isLoaded()) return 1.0;
try { return (double) calcStabilityMH.invokeExact(lastTs, currTs); } catch (Throwable t) { return 1.0; }
}
public static double calcDecay(double heat, double rate) {
if (!isLoaded()) return 0.0;
try { return (double) calcDecayMH.invokeExact(heat, rate); } catch (Throwable t) { return 0.0; }
}
public static double computeTierPrice(double base, double qty, boolean isSell) {
if (!isLoaded()) return base;
try { return (double) computeTierPriceMH.invokeExact(base, qty, isSell); } catch (Throwable t) { return base; }
}
public static double computePriceBounded(double base, double neff, double amt, double lambda, double eps, double histAvg) {
if (!isLoaded()) return base;
try { return (double) computePriceBoundedMH.invokeExact(base, neff, amt, lambda, eps, histAvg); } catch (Throwable t) { return base; }
}
public static void getHealthStats(MemorySegment outTotal, MemorySegment outDropped) {
if (!isLoaded()) return;
try { getHealthStatsMH.invokeExact(outTotal, outDropped); } catch (Throwable t) {}
}
public static void resetPidState(MemorySegment pidPtr) {
if (!isLoaded()) return;
try { resetPidMH.invokeExact(pidPtr); } catch (Throwable t) { LogUtil.error("PID reset failed", t); }
}
public static double computePrice(double base, double nEff, double amount, double lambda, double epsilon) {
if (!isLoaded()) return base;
try { return (double) computePriceMH.invokeExact(base, nEff, amount, lambda, epsilon); } catch (Throwable t) { return base; }
}
public static double queryNeffVectorized(long now, double tau) {
if (!isLoaded()) return 0.0;
try { return (double) queryNeffVectorizedMH.invokeExact(now, tau); } catch (Throwable t) { return 0.0; }
}
public static void pushToDuckDB(long ts, String uuid, double amount, double bal, String meta) {
if (!isLoaded()) return;
try (Arena arena = Arena.ofConfined()) {
pushToDuckDBMH.invokeExact(ts, arena.allocateFrom(uuid), amount, bal, arena.allocateFrom(meta));
} catch (Throwable t) { LogUtil.error("DuckDB logging failed", t); }
}
public static double calculateEpsilon(MemorySegment tradeCtx, MemorySegment marketCfg) {
if (!isLoaded()) return 1.0;
try { return (double) calculateEpsilonMH.invokeExact(tradeCtx, marketCfg); } catch (Throwable t) { return 1.0; }
}
public static TransferResult checkTransfer(MemorySegment ctxSeg, MemorySegment cfgSeg) {
if (!isLoaded()) return new TransferResult(0.0, true, -1);
try (Arena arena = Arena.ofConfined()) {
MemorySegment resultSeg = arena.allocate(Layouts.TRANSFER_RESULT);
checkTransferMH.invokeExact(resultSeg, ctxSeg, cfgSeg);
double tax = ((Number) VH_RES_TAX.get(resultSeg)).doubleValue();
boolean isBlocked = ((Number) VH_RES_BLOCKED.get(resultSeg)).intValue() != 0;
int warningCode = ((Number) VH_RES_CODE.get(resultSeg)).intValue();
return new TransferResult(tax, isBlocked, warningCode);
} catch (Throwable t) {
LogUtil.error("Critical error in checkTransfer FFI call", t);
return new TransferResult(0.0, true, -2);
}
}
public static double computePidAdjustment(MemorySegment pidPtr, double target, double current, double dt, double inflation, double heat) {
if (!isLoaded()) return 0.0;
try { return (double) computePidMH.invokeExact(pidPtr, target, current, dt, inflation, heat); } catch (Throwable t) { return 0.0; }
}
public static void computeBatchPrices(long count, double neff, MemorySegment ctxArr, MemorySegment cfgArr, MemorySegment histAvgs, MemorySegment lambdas, MemorySegment results) {
if (!isLoaded()) return;
try {
computeBatchPricesMH.invokeExact(count, neff, ctxArr, cfgArr, histAvgs, lambdas, results);
} catch (Throwable t) {
LogUtil.error("SIMD Batch calculation failed.", t);
}
}
public static class Layouts {
public static final GroupLayout TRADE_CONTEXT = TradeContext.layout();
public static final GroupLayout MARKET_CONFIG = MarketConfig.layout();
public static final GroupLayout TRANSFER_CONTEXT = TransferContext.layout();
public static final GroupLayout REGULATOR_CONFIG = RegulatorConfig.layout();
public static final GroupLayout PID_STATE = PidState.layout();
public static final GroupLayout TRANSFER_RESULT = top.ellan.ecobridge.gen.TransferResult.layout();
}
public record TransferResult(double tax, boolean isBlocked, int warningCode) {}
}

==================================================
FILE: ecobridge-java\src\main\java\top\ellan\ecobridge\bridge\NativeContextBuilder.java
==================================================

package top.ellan.ecobridge.bridge;
import top.ellan.ecobridge.manager.EconomyManager;
import top.ellan.ecobridge.util.HolidayManager;
import top.ellan.ecobridge.util.LogUtil;
import java.lang.foreign.MemorySegment;
import java.time.OffsetDateTime;
public class NativeContextBuilder {
private static final int TIMEZONE_OFFSET = OffsetDateTime.now().getOffset().getTotalSeconds();
public static void fillGlobalContext(MemorySegment ctxSeg, long now) {
if (!NativeBridge.isLoaded()) {
return;
}
try {
NativeBridge.VH_CTX_TIMESTAMP.set(ctxSeg, 0L, now);
EconomyManager eco = EconomyManager.getInstance();
if (eco != null) {
NativeBridge.VH_CTX_INF_RATE.set(ctxSeg, 0L, eco.getInflationRate());
NativeBridge.VH_CTX_MARKET_HEAT.set(ctxSeg, 0L, eco.getMarketHeat());
NativeBridge.VH_CTX_ECO_SAT.set(ctxSeg, 0L, eco.getEcoSaturation());
}
NativeBridge.VH_CTX_TIMEZONE_OFFSET.set(ctxSeg, 0L, TIMEZONE_OFFSET);
int mask = (HolidayManager.isTodayHoliday() ? 1 : 0) << 1;
NativeBridge.VH_CTX_NEWBIE_MASK.set(ctxSeg, 0L, mask);
NativeBridge.VH_CTX_PLAY_TIME.set(ctxSeg, 0L, 0L);
NativeBridge.VH_CTX_CURR_AMT.set(ctxSeg, 0L, 0.0);
} catch (Exception e) {
LogUtil.error("填充 GlobalContext 失败: 内存段可能已失效", e);
}
}
public static void updateItemContext(MemorySegment ctxSeg, double basePrice) {
if (!NativeBridge.isLoaded()) return;
try {
NativeBridge.VH_CTX_BASE_PRICE.set(ctxSeg, 0L, basePrice);
} catch (Exception e) {
LogUtil.error("更新 ItemContext 失败", e);
}
}
}

==================================================
FILE: ecobridge-java\src\main\java\top\ellan\ecobridge\bridge\NativeLoader.java
==================================================

package top.ellan.ecobridge.bridge;
import top.ellan.ecobridge.EcoBridge;
import top.ellan.ecobridge.util.LogUtil;
import java.io.ByteArrayInputStream;
import java.io.IOException;
import java.io.InputStream;
import java.lang.foreign.Arena;
import java.lang.foreign.MemorySegment;
import java.lang.foreign.SymbolLookup;
import java.nio.file.Files;
import java.nio.file.Path;
import java.nio.file.StandardCopyOption;
import java.security.MessageDigest;
import java.util.Optional;
public class NativeLoader {
private static final String LIB_NAME = "ecobridge_rust";
private static Arena globalArena;
private static SymbolLookup symbolLookup;
private static volatile boolean isReady = false;
public static synchronized void load(EcoBridge plugin) {
if (isReady) return;
try {
Path libPath = extractLibrary(plugin);
globalArena = Arena.ofShared();
symbolLookup = SymbolLookup.libraryLookup(libPath, globalArena);
isReady = true;
LogUtil.debug("NativeLoader: Native 符号表已就绪。");
} catch (Throwable e) {
throw new RuntimeException("无法加载 Native 库: " + e.getMessage(), e);
}
}
public static synchronized void unload() {
if (!isReady) return;
try {
if (globalArena != null && globalArena.scope().isAlive()) {
globalArena.close();
LogUtil.debug("NativeLoader: 共享内存域已安全关闭。");
}
} catch (Throwable e) {
LogUtil.error("NativeLoader: 内存域关闭失败", e);
} finally {
globalArena = null;
symbolLookup = null;
isReady = false;
}
}
public static Optional<SymbolLookup> getLookup() {
return Optional.ofNullable(symbolLookup);
}
public static Optional<MemorySegment> findSymbol(String name) {
if (!isReady || symbolLookup == null) return Optional.empty();
try {
return symbolLookup.find(name);
} catch (Throwable t) {
return Optional.empty();
}
}
public static boolean isReady() {
return isReady;
}
private static Path extractLibrary(EcoBridge plugin) throws IOException {
String os = System.getProperty("os.name").toLowerCase();
String suffix = os.contains("win") ? ".dll" : (os.contains("mac") ? ".dylib" : ".so");
String name = (os.contains("win") ? "" : "lib") + LIB_NAME + suffix;
Path target = plugin.getDataFolder().toPath().resolve("natives").resolve(name);
byte[] resourceBytes;
try (InputStream in = plugin.getResource(name)) {
if (in == null) throw new IOException("Native lib not found in jar: " + name);
resourceBytes = in.readAllBytes();
}
String newHash = calculateHash(resourceBytes);
if (Files.exists(target)) {
try {
byte[] existingBytes = Files.readAllBytes(target);
String oldHash = calculateHash(existingBytes);
if (newHash.equals(oldHash)) return target;
} catch (IOException e) {
LogUtil.warn("校验现有 Native 库失败，准备覆盖: " + e.getMessage());
}
}
Files.createDirectories(target.getParent());
try (ByteArrayInputStream bin = new ByteArrayInputStream(resourceBytes)) {
Files.copy(bin, target, StandardCopyOption.REPLACE_EXISTING);
}
LogUtil.info("已提取 Native 库至: " + target + " (Hash: " + newHash.substring(0, 8) + ")");
return target;
}
private static String calculateHash(byte[] data) {
try {
MessageDigest md = MessageDigest.getInstance("SHA-256");
byte[] hash = md.digest(data);
StringBuilder sb = new StringBuilder();
for (byte b : hash) sb.append(String.format("%02x", b));
return sb.toString();
} catch (Exception e) {
throw new RuntimeException("SHA-256 algorithm not found", e);
}
}
}

==================================================
FILE: ecobridge-java\src\main\java\top\ellan\ecobridge\cache\HotDataCache.java
==================================================

package top.ellan.ecobridge.cache;
import com.github.benmanes.caffeine.cache.Cache;
import com.github.benmanes.caffeine.cache.Caffeine;
import com.github.benmanes.caffeine.cache.RemovalCause;
import org.bukkit.Bukkit;
import org.bukkit.entity.Player;
import top.ellan.ecobridge.EcoBridge;
import top.ellan.ecobridge.database.DatabaseManager;
import top.ellan.ecobridge.database.TransactionDao;
import top.ellan.ecobridge.util.LogUtil;
import java.time.Duration;
import java.util.UUID;
import java.util.concurrent.atomic.AtomicLong;
public class HotDataCache {
private static final Cache<UUID, PlayerData> CACHE = Caffeine.newBuilder()
.maximumSize(2000)
.expireAfterAccess(Duration.ofHours(2))
.removalListener((UUID uuid, PlayerData data, RemovalCause cause) -> {
if (data == null) return;
if (cause != RemovalCause.REPLACED) {
saveAsync(uuid, data, "CACHE_" + cause.name());
}
})
.build();
public static void load(UUID uuid) {
DatabaseManager.getExecutor().execute(() -> {
try {
PlayerData data = TransactionDao.loadPlayerData(uuid);
Bukkit.getScheduler().runTask(EcoBridge.getInstance(), () -> {
Player p = Bukkit.getPlayer(uuid);
if (p != null && p.isOnline()) {
CACHE.put(uuid, data);
LogUtil.debug("已为玩家 " + p.getName() + " 完成数据挂载 (Version: " + data.getVersion() + ")");
} else {
LogUtil.debug("拦截到过时加载回调 (" + uuid + ")，玩家已离线。");
}
});
} catch (Exception e) {
LogUtil.error("玩家 " + uuid + " 数据热加载发生致命错误！", e);
}
});
}
public static PlayerData get(UUID uuid) {
return CACHE.getIfPresent(uuid);
}
public static void invalidate(UUID uuid) {
CACHE.invalidate(uuid);
}
private static void saveAsync(UUID uuid, PlayerData data, String reason) {
DatabaseManager.getExecutor().execute(() -> {
try {
TransactionDao.updateBalanceBlocking(uuid, data.getBalance());
if (LogUtil.isDebugEnabled()) {
LogUtil.debug("数据写回成功 [" + reason + "]: " + uuid + " (Balance: " + data.getBalance() + ")");
}
} catch (Exception e) {
LogUtil.error("异步写回失败: " + uuid, e);
}
});
}
public static void saveAllSync() {
LogUtil.info("正在执行关机前的全量热数据强制同步...");
var snapshotMap = CACHE.asMap();
for (var entry : snapshotMap.entrySet()) {
TransactionDao.updateBalanceBlocking(entry.getKey(), entry.getValue().getBalance());
}
CACHE.invalidateAll();
LogUtil.info("所有活跃数据已安全落盘。");
}
public static class PlayerData {
private final UUID uuid;
private final AtomicLong balanceBits;
private volatile long version;
public PlayerData(UUID uuid, double initialBalance, long version) {
this.uuid = uuid;
this.balanceBits = new AtomicLong(Double.doubleToRawLongBits(initialBalance));
this.version = version;
}
public UUID getUuid() { return uuid; }
public double getBalance() {
return Double.longBitsToDouble(balanceBits.get());
}
public long getVersion() {
return version;
}
public void setVersion(long version) {
this.version = version;
}
public void updateFromTruth(double newBalance) {
balanceBits.set(Double.doubleToRawLongBits(newBalance));
}
public void setBalance(double newBalance) {
updateFromTruth(newBalance);
}
}
}

==================================================
FILE: ecobridge-java\src\main\java\top\ellan\ecobridge\collector\ActivityCollector.java
==================================================

package top.ellan.ecobridge.collector;
import net.kyori.adventure.text.Component;
import net.kyori.adventure.text.minimessage.MiniMessage;
import net.kyori.adventure.text.minimessage.tag.resolver.Placeholder;
import org.bukkit.Bukkit;
import org.bukkit.Statistic;
import org.bukkit.entity.Player;
import top.ellan.ecobridge.EcoBridge;
import java.util.concurrent.CompletableFuture;
public class ActivityCollector {
private static final long TICKS_PER_SECOND = 20L;
private static final double SECONDS_PER_HOUR = 3600.0;
public static ActivitySnapshot capture(Player player, double newbieThresholdHours) {
if (!Bukkit.isPrimaryThread()) {
EcoBridge.getInstance().getLogger().warning(
"[线程安全拦截] ActivityCollector.capture 检测到非法异步调用！" +
"调用方必须在主线程执行。玩家: " + player.getName()
);
return new ActivitySnapshot(360000L, 100.0, 0);
}
long totalTicks = player.getStatistic(Statistic.PLAY_ONE_MINUTE);
long totalSeconds = totalTicks / TICKS_PER_SECOND;
double hours = (double) totalSeconds / SECONDS_PER_HOUR;
int newbieBit = (hours < newbieThresholdHours) ? 1 : 0;
return new ActivitySnapshot(totalSeconds, hours, newbieBit);
}
public static CompletableFuture<ActivitySnapshot> captureAsync(Player player, double newbieThresholdHours) {
if (Bukkit.isPrimaryThread()) {
return CompletableFuture.completedFuture(capture(player, newbieThresholdHours));
}
CompletableFuture<ActivitySnapshot> future = new CompletableFuture<>();
Bukkit.getScheduler().runTask(EcoBridge.getInstance(), () -> {
try {
future.complete(capture(player, newbieThresholdHours));
} catch (Exception e) {
future.completeExceptionally(e);
}
});
return future;
}
public record ActivitySnapshot(long seconds, double hours, int isNewbie) {}
public static Component toComponent(Player player) {
var snapshot = capture(player, 48.0);
String color = snapshot.hours() < 10 ? "<red>" : (snapshot.hours() < 50 ? "<yellow>" : "<green>");
double displayHours = Math.floor(snapshot.hours() * 10) / 10.0;
return MiniMessage.miniMessage().deserialize(
"<gray>活跃等级: " + color + "<hours>h <dark_gray>(<sec>s) <gray>新手状态: <newbie>",
Placeholder.unparsed("hours", String.valueOf(displayHours)),
Placeholder.unparsed("sec", String.valueOf(snapshot.seconds())),
Placeholder.unparsed("newbie", (snapshot.isNewbie() & 1) == 1 ? "<yellow>是" : "<green>否")
);
}
}

==================================================
FILE: ecobridge-java\src\main\java\top\ellan\ecobridge\command\TransferCommand.java
==================================================

package top.ellan.ecobridge.command;
import net.kyori.adventure.text.Component;
import org.bukkit.Bukkit;
import org.bukkit.command.Command;
import org.bukkit.command.CommandSender;
import org.bukkit.command.TabExecutor;
import org.bukkit.entity.Player;
import org.jetbrains.annotations.NotNull;
import org.jetbrains.annotations.Nullable;
import top.ellan.ecobridge.EcoBridge;
import top.ellan.ecobridge.manager.TransferManager;
import java.util.Collections;
import java.util.List;
import java.util.stream.Collectors;
public class TransferCommand implements TabExecutor {
private static final String PERMISSION = "ecobridge.command.transfer";
@Override
public boolean onCommand(@NotNull CommandSender sender, @NotNull Command command, @NotNull String label, @NotNull String[] args) {
if (!(sender instanceof Player player)) {
sender.sendMessage(Component.text("该指令仅限玩家在游戏内执行。"));
return true;
}
if (!player.hasPermission(PERMISSION)) {
player.sendMessage(EcoBridge.getMiniMessage().deserialize("<red>权限不足！ <gray>您需要: <yellow>" + PERMISSION));
return true;
}
if (args.length < 2) {
sendUsage(player, label);
return true;
}
Player target = Bukkit.getPlayer(args[0]);
if (target == null || !target.isOnline()) {
player.sendMessage(EcoBridge.getMiniMessage().deserialize("<red>错误: <gray>目标玩家 <yellow>" + args[0] + " <gray>不在线。"));
return true;
}
if (player.getUniqueId().equals(target.getUniqueId())) {
player.sendMessage(EcoBridge.getMiniMessage().deserialize("<red>禁止操作: <gray>您无法向自己发起转账。"));
return true;
}
double amount;
try {
amount = Double.parseDouble(args[1]);
if (amount < 0.01) {
player.sendMessage(EcoBridge.getMiniMessage().deserialize("<red>金额异常: <gray>转账金额必须大于 <yellow>0.01"));
return true;
}
} catch (NumberFormatException e) {
player.sendMessage(EcoBridge.getMiniMessage().deserialize("<red>非法输入: <gray>请输入正确的数字金额。"));
return true;
}
player.sendMessage(EcoBridge.getMiniMessage().deserialize(
"<gray>[<blue>EcoBridge</blue>] <italic>正在启动智能审计，请稍候...</italic>"
));
TransferManager.getInstance().initiateTransfer(player, target, amount);
return true;
}
@Override
public @Nullable List<String> onTabComplete(@NotNull CommandSender sender, @NotNull Command command, @NotNull String alias, @NotNull String[] args) {
if (args.length == 1) {
String input = args[0].toLowerCase();
return Bukkit.getOnlinePlayers().stream()
.map(Player::getName)
.filter(name -> name.toLowerCase().startsWith(input))
.collect(Collectors.toList());
}
if (args.length == 2) {
return List.of("10", "100", "1000");
}
return Collections.emptyList();
}
private void sendUsage(Player player, String label) {
player.sendMessage(EcoBridge.getMiniMessage().deserialize(
"<gradient:aqua:blue><b>EcoBridge 智能结算系统</b></gradient>\n" +
"<gray>用法: <yellow>/" + label + " <玩家> <金额>"
));
}
}

==================================================
FILE: ecobridge-java\src\main\java\top\ellan\ecobridge\database\DatabaseManager.java
==================================================

package top.ellan.ecobridge.database;
import com.zaxxer.hikari.HikariConfig;
import com.zaxxer.hikari.HikariDataSource;
import top.ellan.ecobridge.EcoBridge;
import top.ellan.ecobridge.util.LogUtil;
import java.sql.Connection;
import java.sql.SQLException;
import java.sql.Statement;
import java.util.concurrent.ExecutorService;
import java.util.concurrent.Executors;
import java.util.concurrent.TimeUnit;
public class DatabaseManager {
private static HikariDataSource dataSource;
private static ExecutorService dbExecutor;
public static synchronized void init() {
if (dataSource != null || dbExecutor != null) {
close();
}
var plugin = EcoBridge.getInstance();
var config = plugin.getConfig();
int poolSize = config.getInt("database.pool-size", 15);
dbExecutor = Executors.newFixedThreadPool(
poolSize,
Thread.ofPlatform()
.name("ecobridge-db-worker-", 0)
.factory()
);
HikariConfig hikari = new HikariConfig();
String host = config.getString("database.host", "localhost");
int port = config.getInt("database.port", 3306);
String dbName = config.getString("database.database", "ecobridge");
String user = config.getString("database.username", "root");
String pass = config.getString("database.password", "");
String jdbcUrl = String.format(
"jdbc:mysql:
host, port, dbName
);
hikari.setJdbcUrl(jdbcUrl);
hikari.setUsername(user);
hikari.setPassword(pass);
hikari.setMaximumPoolSize(poolSize);
hikari.setConnectionTimeout(5000);
hikari.setIdleTimeout(600000);
hikari.setMaxLifetime(1800000);
try {
dataSource = new HikariDataSource(hikari);
createTables();
LogUtil.info("<green>SQL 数据源已就绪 (HikariCP + 隔离型平台线程池)。");
} catch (Exception e) {
LogUtil.error("数据库初始化失败！请检查配置及 MySQL 服务状态。", e);
}
}
public static Connection getConnection() throws SQLException {
if (dataSource == null) {
throw new SQLException("DataSource is not initialized");
}
return dataSource.getConnection();
}
public static ExecutorService getExecutor() {
return dbExecutor;
}
public static boolean isConnected() {
return dataSource != null && !dataSource.isClosed();
}
public static synchronized void close() {
LogUtil.info("正在安全释放 SQL 资源...");
if (dbExecutor != null) {
dbExecutor.shutdown();
try {
if (!dbExecutor.awaitTermination(5, TimeUnit.SECONDS)) {
dbExecutor.shutdownNow();
}
} catch (InterruptedException e) {
dbExecutor.shutdownNow();
Thread.currentThread().interrupt();
}
dbExecutor = null;
}
if (dataSource != null) {
if (!dataSource.isClosed()) {
dataSource.close();
}
dataSource = null;
}
}
private static void createTables() {
if (dataSource == null) return;
String sqlSales = """
CREATE TABLE IF NOT EXISTS ecobridge_sales (
id BIGINT AUTO_INCREMENT PRIMARY KEY,
player_uuid CHAR(36) NOT NULL,
product_id VARCHAR(64) NOT NULL,
amount DOUBLE NOT NULL,
timestamp BIGINT NOT NULL,
INDEX idx_history (product_id, timestamp)
) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4;
""";
String sqlPlayers = """
CREATE TABLE IF NOT EXISTS ecobridge_players (
uuid CHAR(36) PRIMARY KEY,
balance DOUBLE NOT NULL DEFAULT 0.0,
version BIGINT NOT NULL DEFAULT 0,
last_updated BIGINT NOT NULL
) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4;
""";
try (Connection conn = getConnection(); Statement stmt = conn.createStatement()) {
stmt.execute(sqlSales);
stmt.execute(sqlPlayers);
} catch (SQLException e) {
LogUtil.error("DDL 初始化失败，请检查数据库权限。", e);
}
}
}

==================================================
FILE: ecobridge-java\src\main\java\top\ellan\ecobridge\database\TransactionDao.java
==================================================

package top.ellan.ecobridge.database;
import top.ellan.ecobridge.cache.HotDataCache;
import top.ellan.ecobridge.cache.HotDataCache.PlayerData;
import top.ellan.ecobridge.model.SaleRecord;
import top.ellan.ecobridge.util.LogUtil;
import java.sql.Connection;
import java.sql.PreparedStatement;
import java.sql.ResultSet;
import java.sql.SQLException;
import java.util.*;
import java.util.concurrent.TimeUnit;
public class TransactionDao {
public static PlayerData loadPlayerData(UUID uuid) {
if (!DatabaseManager.isConnected()) {
return new PlayerData(uuid, 0.0, 0);
}
String sql = "SELECT balance, version FROM ecobridge_players WHERE uuid = ?";
try (Connection conn = DatabaseManager.getConnection();
PreparedStatement pstmt = conn.prepareStatement(sql)) {
pstmt.setString(1, uuid.toString());
try (ResultSet rs = pstmt.executeQuery()) {
if (rs.next()) {
return new PlayerData(uuid, rs.getDouble("balance"), rs.getLong("version"));
}
}
} catch (SQLException e) {
LogUtil.error("读取玩家 SQL 失败: " + uuid, e);
}
return new PlayerData(uuid, 0.0, 0);
}
public static void updateBalance(UUID uuid, double balance) {
if (DatabaseManager.getExecutor() == null) return;
DatabaseManager.getExecutor().execute(() -> updateBalanceBlocking(uuid, balance));
}
public static void updateBalanceBlocking(UUID uuid, double balance) {
if (!DatabaseManager.isConnected()) return;
String updateSql = "UPDATE ecobridge_players SET balance = ?, version = version + 1, last_updated = ? WHERE uuid = ? AND version = ?";
String insertSql = "INSERT IGNORE INTO ecobridge_players (uuid, balance, version, last_updated) VALUES (?, ?, 0, ?)";
long now = System.currentTimeMillis();
int maxRetries = 3;
SQLException lastEx = null;
for (int attempt = 1; attempt <= maxRetries; attempt++) {
PlayerData cached = HotDataCache.get(uuid);
long currentVersion = (cached != null) ? cached.getVersion() : -1;
try (Connection conn = DatabaseManager.getConnection()) {
if (currentVersion == -1) {
try (PreparedStatement ipstmt = conn.prepareStatement(insertSql)) {
ipstmt.setString(1, uuid.toString());
ipstmt.setDouble(2, balance);
ipstmt.setLong(3, now);
if (ipstmt.executeUpdate() > 0) return;
}
}
try (PreparedStatement upstmt = conn.prepareStatement(updateSql)) {
upstmt.setDouble(1, balance);
upstmt.setLong(2, now);
upstmt.setString(3, uuid.toString());
upstmt.setLong(4, Math.max(0, currentVersion));
int affected = upstmt.executeUpdate();
if (affected > 0) {
if (cached != null) cached.setVersion(currentVersion + 1);
return;
}
}
PlayerData fresh = loadPlayerData(uuid);
if (cached != null) cached.setVersion(fresh.getVersion());
if (attempt < maxRetries) {
Thread.sleep(50L * attempt);
}
} catch (SQLException e) {
lastEx = e;
if (isFatalError(e)) break;
try { Thread.sleep(100L * attempt); } catch (InterruptedException ie) { break; }
} catch (InterruptedException e) {
Thread.currentThread().interrupt();
break;
}
}
LogUtil.error("持久化玩家余额最终失败 (乐观锁冲突/重试耗尽): " + uuid, lastEx);
}
public static void saveSaleAsync(UUID uuid, String productId, double amount) {
if (DatabaseManager.getExecutor() == null) return;
DatabaseManager.getExecutor().execute(() -> {
String sql = "INSERT INTO ecobridge_sales(player_uuid, product_id, amount, timestamp) VALUES(?,?,?,?)";
try (Connection conn = DatabaseManager.getConnection();
PreparedStatement pstmt = conn.prepareStatement(sql)) {
pstmt.setString(1, uuid != null ? uuid.toString() : "SYSTEM");
pstmt.setString(2, productId);
pstmt.setDouble(3, amount);
pstmt.setLong(4, System.currentTimeMillis());
pstmt.executeUpdate();
} catch (SQLException e) {
LogUtil.error("写入 SQL 交易历史失败: " + productId, e);
}
});
}
public static double get7DayAverage(String productId) {
if (!DatabaseManager.isConnected()) return 0.0;
String sql = "SELECT AVG(ABS(amount)) FROM ecobridge_sales WHERE product_id = ? AND timestamp > ?";
long cutoff = System.currentTimeMillis() - TimeUnit.DAYS.toMillis(7);
try (Connection conn = DatabaseManager.getConnection();
PreparedStatement pstmt = conn.prepareStatement(sql)) {
pstmt.setString(1, productId);
pstmt.setLong(2, cutoff);
try (ResultSet rs = pstmt.executeQuery()) {
if (rs.next()) {
return rs.getDouble(1);
}
}
} catch (SQLException e) {
LogUtil.error("滑动地板数据回溯异常: " + productId, e);
}
return 0.0;
}
public static Map<String, Double> get7DayAveragesBatch(List<String> productIds) {
if (productIds == null || productIds.isEmpty() || !DatabaseManager.isConnected()) {
return new HashMap<>();
}
Map<String, Double> resultMap = new HashMap<>();
for (String productId : productIds) {
resultMap.put(productId, 0.0);
}
String placeholders = String.join(",", Collections.nCopies(productIds.size(), "?"));
String sql = "SELECT product_id, AVG(ABS(amount)) as avg_amount FROM ecobridge_sales " +
"WHERE product_id IN (" + placeholders + ") " +
"AND timestamp > ? " +
"GROUP BY product_id";
long cutoff = System.currentTimeMillis() - TimeUnit.DAYS.toMillis(7);
try (Connection conn = DatabaseManager.getConnection();
PreparedStatement pstmt = conn.prepareStatement(sql)) {
for (int i = 0; i < productIds.size(); i++) {
pstmt.setString(i + 1, productIds.get(i));
}
pstmt.setLong(productIds.size() + 1, cutoff);
try (ResultSet rs = pstmt.executeQuery()) {
while (rs.next()) {
String productId = rs.getString("product_id");
double avgAmount = rs.getDouble("avg_amount");
resultMap.put(productId, avgAmount);
}
}
} catch (SQLException e) {
LogUtil.error("批量历史均价查询失败", e);
}
return resultMap;
}
public static List<SaleRecord> getProductHistory(String productId, int daysLimit) {
if (!DatabaseManager.isConnected()) return new ArrayList<>();
List<SaleRecord> history = new ArrayList<>();
long cutoff = System.currentTimeMillis() - TimeUnit.DAYS.toMillis(daysLimit);
String sql = "SELECT timestamp, amount FROM ecobridge_sales WHERE product_id = ? AND timestamp > ? " +
"ORDER BY timestamp DESC LIMIT 5000";
try (Connection conn = DatabaseManager.getConnection();
PreparedStatement pstmt = conn.prepareStatement(sql)) {
pstmt.setString(1, productId);
pstmt.setLong(2, cutoff);
try (ResultSet rs = pstmt.executeQuery()) {
while (rs.next()) {
history.add(new SaleRecord(rs.getLong("timestamp"), rs.getDouble("amount")));
}
}
} catch (SQLException e) {
LogUtil.error("回溯商品 SQL 冷数据异常: " + productId, e);
}
return history;
}
private static boolean isFatalError(SQLException e) {
String state = e.getSQLState();
if (state == null) return false;
return state.startsWith("42") || state.startsWith("23");
}
}

==================================================
FILE: ecobridge-java\src\main\java\top\ellan\ecobridge\engine\PriceComputeEngine.java
==================================================

package top.ellan.ecobridge.engine;
import org.bukkit.configuration.ConfigurationSection;
import org.bukkit.configuration.file.FileConfiguration;
import top.ellan.ecobridge.EcoBridge;
import top.ellan.ecobridge.bridge.NativeBridge;
import top.ellan.ecobridge.bridge.NativeBridge.Layouts;
import top.ellan.ecobridge.bridge.NativeContextBuilder;
import top.ellan.ecobridge.database.TransactionDao;
import top.ellan.ecobridge.manager.PricingManager;
import top.ellan.ecobridge.util.LogUtil;
import java.lang.foreign.*;
import java.util.*;
import java.util.concurrent.locks.ReentrantReadWriteLock;
import static java.lang.foreign.ValueLayout.JAVA_DOUBLE;
public class PriceComputeEngine {
private record ItemMeta(
String key,
String shopId,
String productId,
double basePrice,
double lambda,
int index
) {}
public static Map<String, Double> computeSnapshot(EcoBridge plugin, double configTau, double currentLambda) {
long startTime = System.nanoTime();
Map<String, Double> resultMap = new HashMap<>();
if (!NativeBridge.isLoaded()) {
return resultMap;
}
FileConfiguration config = plugin.getConfig();
ConfigurationSection itemSection = config.getConfigurationSection("item-settings");
if (itemSection == null) return resultMap;
List<ItemMeta> activeItems = collectActiveItems(itemSection, currentLambda);
if (activeItems.isEmpty()) return resultMap;
int count = activeItems.size();
long now = System.currentTimeMillis();
Map<String, Double> histAvgMap = loadHistoryAverages(activeItems);
try (Arena arena = Arena.ofConfined()) {
SequenceLayout tradeCtxLayout = MemoryLayout.sequenceLayout(count, Layouts.TRADE_CONTEXT);
SequenceLayout marketCfgLayout = MemoryLayout.sequenceLayout(count, Layouts.MARKET_CONFIG);
SequenceLayout doubleArrLayout = MemoryLayout.sequenceLayout(count, JAVA_DOUBLE);
MemorySegment ctxArray = arena.allocate(tradeCtxLayout);
MemorySegment cfgArray = arena.allocate(marketCfgLayout);
MemorySegment histAvgArray = arena.allocate(doubleArrLayout);
MemorySegment lambdaArray = arena.allocate(doubleArrLayout);
MemorySegment resultsArray = arena.allocate(doubleArrLayout);
double neff = NativeBridge.queryNeffVectorized(now, configTau);
for (ItemMeta meta : activeItems) {
long ctxOffset = (long) meta.index() * Layouts.TRADE_CONTEXT.byteSize();
long cfgOffset = (long) meta.index() * Layouts.MARKET_CONFIG.byteSize();
MemorySegment ctxSlice = ctxArray.asSlice(ctxOffset, Layouts.TRADE_CONTEXT.byteSize());
NativeContextBuilder.fillGlobalContext(ctxSlice, now);
NativeBridge.VH_CTX_BASE_PRICE.set(ctxArray, ctxOffset, meta.basePrice());
ConfigurationSection itemConfig = itemSection.getConfigurationSection(meta.shopId() + "." + meta.productId());
fillMarketConfigAtOffset(cfgArray, cfgOffset, itemConfig, config, meta.lambda());
double histAvg = histAvgMap.getOrDefault(meta.productId(), meta.basePrice());
histAvgArray.setAtIndex(JAVA_DOUBLE, meta.index(), histAvg);
lambdaArray.setAtIndex(JAVA_DOUBLE, meta.index(), meta.lambda());
}
NativeBridge.computeBatchPrices(
(long) count,
neff,
ctxArray,
cfgArray,
histAvgArray,
lambdaArray,
resultsArray
);
extractResultsWithLock(activeItems, resultsArray, resultMap);
} catch (Throwable e) {
LogUtil.error("SIMD 批量计算任务中断，启动带锁降级演算", e);
fallbackToSingleWithLock(activeItems, resultMap, plugin, now, configTau);
}
double durationMs = (System.nanoTime() - startTime) / 1_000_000.0;
LogUtil.debug("快照演算完成: " + count + " 个商品, 耗时: " + String.format("%.2f", durationMs) + "ms");
return resultMap;
}
private static void extractResultsWithLock(List<ItemMeta> activeItems, MemorySegment resultsArray, Map<String, Double> resultMap) {
PricingManager pm = PricingManager.getInstance();
for (ItemMeta meta : activeItems) {
ReentrantReadWriteLock.WriteLock writeLock = pm.getItemLock(meta.productId()).writeLock();
writeLock.lock();
try {
double computedPrice = resultsArray.getAtIndex(JAVA_DOUBLE, meta.index());
if (Double.isFinite(computedPrice) && computedPrice > 0) {
resultMap.put(meta.key(), computedPrice);
} else {
resultMap.put(meta.key(), meta.basePrice());
}
} finally {
writeLock.unlock();
}
}
}
private static void fallbackToSingleWithLock(List<ItemMeta> items, Map<String, Double> map, EcoBridge plugin, long now, double tau) {
PricingManager pm = PricingManager.getInstance();
for (ItemMeta meta : items) {
if (map.containsKey(meta.key())) continue;
ReentrantReadWriteLock.WriteLock writeLock = pm.getItemLock(meta.productId()).writeLock();
writeLock.lock();
try (Arena arena = Arena.ofConfined()) {
MemorySegment ctx = arena.allocate(Layouts.TRADE_CONTEXT);
MemorySegment cfg = arena.allocate(Layouts.MARKET_CONFIG);
NativeContextBuilder.fillGlobalContext(ctx, now);
NativeBridge.VH_CTX_BASE_PRICE.set(ctx, 0L, meta.basePrice());
double histAvg = TransactionDao.get7DayAverage(meta.productId());
double price = NativeBridge.computePriceBounded(
meta.basePrice(), NativeBridge.queryNeffVectorized(now, tau), 0, meta.lambda(),
NativeBridge.calculateEpsilon(ctx, cfg), histAvg
);
map.put(meta.key(), price);
} catch (Exception ex) {
LogUtil.error("单体降级演算失败: " + meta.key(), ex);
map.put(meta.key(), meta.basePrice());
} finally {
writeLock.unlock();
}
}
}
private static List<ItemMeta> collectActiveItems(ConfigurationSection itemSection, double macroLambda) {
List<ItemMeta> items = new ArrayList<>();
int index = 0;
for (String shopId : itemSection.getKeys(false)) {
ConfigurationSection shopSec = itemSection.getConfigurationSection(shopId);
if (shopSec == null) continue;
for (String prodId : shopSec.getKeys(false)) {
double p0 = shopSec.getDouble(prodId + ".base-price", -1.0);
if (p0 <= 0) continue;
double lambda = shopSec.getDouble(prodId + ".lambda", macroLambda);
items.add(new ItemMeta(shopId + ":" + prodId, shopId, prodId, p0, lambda, index++));
}
}
return items;
}
private static Map<String, Double> loadHistoryAverages(List<ItemMeta> items) {
List<String> ids = items.stream().map(ItemMeta::productId).distinct().toList();
return TransactionDao.get7DayAveragesBatch(ids);
}
private static void fillMarketConfigAtOffset(MemorySegment cfgBase, long offset, ConfigurationSection itemSec, FileConfiguration globalConfig, double currentLambda) {
NativeBridge.VH_CFG_LAMBDA.set(cfgBase, offset, currentLambda);
NativeBridge.VH_CFG_VOLATILITY.set(cfgBase, offset, 1.0);
NativeBridge.VH_CFG_S_AMP.set(cfgBase, offset, globalConfig.getDouble("economy.seasonal-amplitude", 0.15));
NativeBridge.VH_CFG_W_MULT.set(cfgBase, offset, globalConfig.getDouble("economy.weekend-multiplier", 1.2));
NativeBridge.VH_CFG_N_PROT.set(cfgBase, offset, globalConfig.getDouble("economy.newbie-protection", 0.2));
if (itemSec != null) {
NativeBridge.VH_CFG_W_SEASONAL.set(cfgBase, offset, itemSec.getDouble("weights.seasonal", 0.25));
NativeBridge.VH_CFG_W_WEEKEND.set(cfgBase, offset, itemSec.getDouble("weights.weekend", 0.25));
NativeBridge.VH_CFG_W_NEWBIE.set(cfgBase, offset, itemSec.getDouble("weights.newbie", 0.25));
NativeBridge.VH_CFG_W_INFLATION.set(cfgBase, offset, itemSec.getDouble("weights.inflation", 0.25));
} else {
NativeBridge.VH_CFG_W_SEASONAL.set(cfgBase, offset, 0.25);
NativeBridge.VH_CFG_W_WEEKEND.set(cfgBase, offset, 0.25);
NativeBridge.VH_CFG_W_NEWBIE.set(cfgBase, offset, 0.25);
NativeBridge.VH_CFG_W_INFLATION.set(cfgBase, offset, 0.25);
}
}
}

==================================================
FILE: ecobridge-java\src\main\java\top\ellan\ecobridge\hook\EcoPlaceholderExpansion.java
==================================================

package top.ellan.ecobridge.hook;
import cn.superiormc.ultimateshop.managers.ConfigManager;
import cn.superiormc.ultimateshop.objects.ObjectShop;
import cn.superiormc.ultimateshop.objects.buttons.ObjectItem;
import me.clip.placeholderapi.expansion.PlaceholderExpansion;
import org.bukkit.OfflinePlayer;
import org.bukkit.entity.Player;
import org.jetbrains.annotations.NotNull;
import org.jetbrains.annotations.Nullable;
import top.ellan.ecobridge.EcoBridge;
import top.ellan.ecobridge.bridge.NativeBridge;
import top.ellan.ecobridge.collector.ActivityCollector;
import top.ellan.ecobridge.manager.EconomicStateManager;
import top.ellan.ecobridge.manager.EconomyManager;
import top.ellan.ecobridge.manager.PricingManager;
import top.ellan.ecobridge.util.HolidayManager;
import top.ellan.ecobridge.util.InternalPlaceholder;
import top.ellan.ecobridge.util.InternalPlaceholder.QuotaData;
import java.lang.foreign.Arena;
import java.lang.foreign.MemorySegment;
import java.lang.foreign.ValueLayout;
public class EcoPlaceholderExpansion extends PlaceholderExpansion {
private final EcoBridge plugin;
public EcoPlaceholderExpansion(EcoBridge plugin) {
this.plugin = plugin;
}
@Override
public @NotNull String getIdentifier() {
return "ecobridge";
}
@Override
public @NotNull String getAuthor() {
return "Ellan";
}
@Override
public @NotNull String getVersion() {
return plugin.getPluginMeta().getVersion();
}
@Override
public boolean persist() {
return true;
}
@Override
public @Nullable String onRequest(OfflinePlayer offlinePlayer, @NotNull String params) {
EconomyManager eco = EconomyManager.getInstance();
if (params.equals("inflation")) return String.format("%.2f%%", eco.getInflationRate() * 100);
if (params.equals("stability")) return String.format("%.2f", eco.getStabilityFactor());
if (params.equals("market_heat")) return String.format("%.1f", eco.getMarketHeat());
if (params.equals("eco_saturation")) return String.format("%.2f%%", eco.getEcoSaturation() * 100);
if (params.startsWith("pid_")) {
if (!NativeBridge.isLoaded() || PricingManager.getInstance() == null) return "0.000";
MemorySegment pidSeg = PricingManager.getInstance().getGlobalPidState();
if (pidSeg == null || pidSeg.address() == 0) return "0.000";
return switch (params) {
case "pid_kp" -> String.format("%.3f", pidSeg.get(ValueLayout.JAVA_DOUBLE, 0));
case "pid_ki" -> String.format("%.3f", pidSeg.get(ValueLayout.JAVA_DOUBLE, 8));
case "pid_kd" -> String.format("%.3f", pidSeg.get(ValueLayout.JAVA_DOUBLE, 16));
default -> "0.000";
};
}
if (params.equals("is_holiday")) return HolidayManager.isTodayHoliday() ? "是" : "否";
if (params.equals("holiday_mult")) return String.format("%.1fx", HolidayManager.getHolidayEpsilonFactor());
if (params.startsWith("native_")) {
if (!NativeBridge.isLoaded()) return "未加载";
if (params.equals("native_status")) return "已就绪";
try (Arena arena = Arena.ofConfined()) {
MemorySegment totalPtr = arena.allocate(ValueLayout.JAVA_LONG);
MemorySegment droppedPtr = arena.allocate(ValueLayout.JAVA_LONG);
NativeBridge.getHealthStats(totalPtr, droppedPtr);
if (params.equals("native_logs")) return String.valueOf(totalPtr.get(ValueLayout.JAVA_LONG, 0));
if (params.equals("native_dropped")) return String.valueOf(droppedPtr.get(ValueLayout.JAVA_LONG, 0));
} catch (Throwable e) { return "Error"; }
}
if (offlinePlayer != null && offlinePlayer.isOnline()) {
Player player = offlinePlayer.getPlayer();
var snapshot = ActivityCollector.capture(player, 48.0);
if (params.equals("player_hours")) return String.format("%.1f", snapshot.hours());
if (params.equals("player_is_newbie")) {
return (snapshot.isNewbie() == 1) ? "新手" : "资深";
}
if (params.startsWith("quota_")) {
return handleQuotaRequest(player, params);
}
}
if (params.startsWith("state_color_")) {
String pid = params.substring(12);
var phase = EconomicStateManager.getInstance().analyzeMarketAndNotify(pid, 0.0);
return switch (phase) {
case STABLE -> "&a";
case SATURATED -> "&e";
case EMERGENCY -> "&c";
case HEALING -> "&b";
};
}
if (params.startsWith("state_")) {
String pid = params.substring(6);
return EconomicStateManager.getInstance().analyzeMarketAndNotify(pid, 0.0).name();
}
return null;
}
private String handleQuotaRequest(Player player, String params) {
String type;
String productId;
if (params.startsWith("quota_optimal_")) {
type = "optimal";
productId = params.substring("quota_optimal_".length());
} else if (params.startsWith("quota_limit_")) {
type = "limit";
productId = params.substring("quota_limit_".length());
} else if (params.startsWith("quota_remaining_")) {
type = "remaining";
productId = params.substring("quota_remaining_".length());
} else if (params.startsWith("quota_used_")) {
type = "used";
productId = params.substring("quota_used_".length());
} else if (params.startsWith("quota_percent_")) {
type = "percent";
productId = params.substring("quota_percent_".length());
} else {
return null;
}
ObjectItem targetItem = findObjectItem(productId);
if (targetItem == null) return "Unknown";
QuotaData data = InternalPlaceholder.calculateQuota(player, targetItem);
return switch (type) {
case "optimal" -> String.valueOf(data.optimalLimit());
case "limit" -> String.valueOf(data.hardLimit());
case "remaining" -> String.valueOf(data.remaining());
case "used" -> String.valueOf(data.used());
case "percent" -> String.format("%.1f%%", data.percent());
default -> "Error";
};
}
private ObjectItem findObjectItem(String productId) {
ConfigManager cm = ConfigManager.configManager;
if (cm == null) return null;
for (ObjectShop shop : cm.getShops()) {
ObjectItem item = shop.getProduct(productId);
if (item != null) return item;
}
return null;
}
}

==================================================
FILE: ecobridge-java\src\main\java\top\ellan\ecobridge\hook\UShopHookManager.java
==================================================

package top.ellan.ecobridge.hook;
import cn.superiormc.ultimateshop.managers.ConfigManager;
import cn.superiormc.ultimateshop.objects.ObjectShop;
import cn.superiormc.ultimateshop.objects.buttons.ObjectItem;
import cn.superiormc.ultimateshop.objects.items.GiveResult;
import cn.superiormc.ultimateshop.objects.items.ObjectLimit;
import cn.superiormc.ultimateshop.objects.items.TakeResult;
import cn.superiormc.ultimateshop.objects.items.prices.ObjectPrices;
import cn.superiormc.ultimateshop.objects.items.prices.PriceMode;
import org.bukkit.configuration.file.YamlConfiguration;
import org.bukkit.entity.Player;
import org.bukkit.inventory.Inventory;
import su.nightexpress.coinsengine.api.CoinsEngineAPI;
import su.nightexpress.coinsengine.api.currency.Currency;
import top.ellan.ecobridge.EcoBridge;
import top.ellan.ecobridge.manager.EconomicStateManager;
import top.ellan.ecobridge.manager.PricingManager;
import top.ellan.ecobridge.util.LogUtil;
import java.lang.reflect.Constructor;
import java.lang.reflect.Field;
import java.util.HashMap;
import java.util.Map;
import java.util.concurrent.ConcurrentHashMap;
public class UShopHookManager {
private static final Map<ObjectItem, ObjectPrices[]> originalPrices = new ConcurrentHashMap<>();
private static final Map<ObjectItem, ObjectLimit[]> originalLimits = new ConcurrentHashMap<>();
private static Field buyPriceField;
private static Field sellPriceField;
private static Field buyLimitField;
private static Field sellLimitField;
private static boolean reflectionReady = false;
static {
try {
buyPriceField = ObjectItem.class.getDeclaredField("buyPrice");
sellPriceField = ObjectItem.class.getDeclaredField("sellPrice");
buyPriceField.setAccessible(true);
sellPriceField.setAccessible(true);
buyLimitField = ObjectItem.class.getDeclaredField("buyLimit");
sellLimitField = ObjectItem.class.getDeclaredField("sellLimit");
buyLimitField.setAccessible(true);
sellLimitField.setAccessible(true);
reflectionReady = true;
} catch (Exception e) {
LogUtil.error("无法初始化 UltimateShop 反射字段，接管引擎已禁用。", e);
}
}
public static void execute(EcoBridge plugin) {
if (!reflectionReady || !plugin.getConfig().getBoolean("integrations.ultimateshop.enabled", true)) {
return;
}
ConfigManager cm = ConfigManager.configManager;
if (cm == null) return;
int priceInjected = 0;
int limitInjected = 0;
try {
for (ObjectShop shop : cm.getShops()) {
if (shop.getConfig() == null) continue;
for (String itemId : shop.getConfig().getConfigurationSection("items").getKeys(false)) {
ObjectItem item = shop.getProduct(itemId);
if (item == null) continue;
synchronized (item) {
if (plugin.getConfig().getBoolean("integrations.ultimateshop.price-takeover", true)) {
if (!originalPrices.containsKey(item)) {
originalPrices.put(item, new ObjectPrices[]{
(ObjectPrices) buyPriceField.get(item),
(ObjectPrices) sellPriceField.get(item)
});
}
buyPriceField.set(item, new EcoBridgeDynamicPrice(item, itemId));
sellPriceField.set(item, new EcoBridgeDynamicPrice(item, itemId));
priceInjected++;
}
if (plugin.getConfig().getBoolean("integrations.ultimateshop.limit-takeover", true)) {
if (!originalLimits.containsKey(item)) {
originalLimits.put(item, new ObjectLimit[]{
(ObjectLimit) buyLimitField.get(item),
(ObjectLimit) sellLimitField.get(item)
});
}
buyLimitField.set(item, new EcoBridgeDynamicLimit(plugin, originalLimits.get(item)[0]));
sellLimitField.set(item, new EcoBridgeDynamicLimit(plugin, originalLimits.get(item)[1]));
limitInjected++;
}
}
}
}
LogUtil.info("UltimateShop 接管完成: [价格代理: " + priceInjected + "] [限额代理: " + limitInjected + "]");
} catch (Exception e) {
LogUtil.error("接管执行过程中发生异常", e);
}
}
public static void revert() {
if (!reflectionReady) return;
originalPrices.forEach((item, originals) -> {
synchronized (item) {
try {
buyPriceField.set(item, originals[0]);
sellPriceField.set(item, originals[1]);
} catch (Exception ignored) {}
}
});
originalLimits.forEach((item, originals) -> {
synchronized (item) {
try {
buyLimitField.set(item, originals[0]);
sellLimitField.set(item, originals[1]);
} catch (Exception ignored) {}
}
});
originalPrices.clear();
originalLimits.clear();
LogUtil.info("UltimateShop 所有接管代理已安全卸载，原始逻辑已还原。");
}
public static class EcoBridgeDynamicPrice extends ObjectPrices {
private final String productId;
private final String currencyId;
private static Constructor<TakeResult> takeResultCtor;
private static Constructor<GiveResult> giveResultCtor;
private static Field takeResultMapField;
private static Field giveResultMapField;
static {
try {
try { takeResultCtor = TakeResult.class.getDeclaredConstructor(); }
catch (NoSuchMethodException e) { takeResultCtor = TakeResult.class.getDeclaredConstructor(boolean.class); }
takeResultCtor.setAccessible(true);
try { giveResultCtor = GiveResult.class.getDeclaredConstructor(); }
catch (NoSuchMethodException e) { giveResultCtor = GiveResult.class.getDeclaredConstructor(boolean.class); }
giveResultCtor.setAccessible(true);
takeResultMapField = findField(TakeResult.class, "resultMap", "results", "map");
giveResultMapField = findField(GiveResult.class, "resultMap", "results", "map");
if (takeResultMapField != null) takeResultMapField.setAccessible(true);
if (giveResultMapField != null) giveResultMapField.setAccessible(true);
} catch (Exception e) { e.printStackTrace(); }
}
public EcoBridgeDynamicPrice(ObjectItem item, String productId) {
super(new YamlConfiguration(), "EcoBridge", item, PriceMode.BUY);
this.productId = productId;
this.currencyId = EcoBridge.getInstance().getConfig().getString("economy.currency-id", "coins");
}
@Override
public TakeResult take(Inventory inv, Player player, int times, int amount, boolean sim) {
PricingManager pm = PricingManager.getInstance();
var lock = pm.getItemLock(productId).readLock();
lock.lock();
try {
double unitPrice = pm.calculateBuyPrice(productId);
double total = unitPrice * amount;
Map<String, Object> map = new HashMap<>();
map.put("money", total);
Currency cur = CoinsEngineAPI.getCurrency(currencyId);
if (cur == null || CoinsEngineAPI.getBalance(player, cur) < total) return createTakeResult(false, map);
if (!sim) {
CoinsEngineAPI.removeBalance(player, cur, total);
EconomicStateManager.getInstance().recordPurchase(player, productId, amount);
}
return createTakeResult(true, map);
} finally { lock.unlock(); }
}
@Override
public GiveResult give(Player player, int times, int amount) {
PricingManager pm = PricingManager.getInstance();
var lock = pm.getItemLock(productId).readLock();
lock.lock();
try {
double unitPrice = pm.calculateSellPrice(productId);
double total = unitPrice * amount;
Map<String, Object> map = new HashMap<>();
map.put("money", total);
if (!isSimulationContext()) {
Currency cur = CoinsEngineAPI.getCurrency(currencyId);
if (cur != null) {
CoinsEngineAPI.addBalance(player, cur, total);
EconomicStateManager.getInstance().recordSale(player, productId, amount);
}
}
return createGiveResult(true, map);
} finally { lock.unlock(); }
}
private static Field findField(Class<?> c, String... ns) {
for (String n : ns) { try { return c.getDeclaredField(n); } catch (Exception ignored) {} }
return null;
}
private TakeResult createTakeResult(boolean s, Map<String, Object> m) {
try {
TakeResult r = (takeResultCtor.getParameterCount() == 0) ? takeResultCtor.newInstance() : takeResultCtor.newInstance(s);
if (takeResultMapField != null) takeResultMapField.set(r, m);
return r;
} catch (Exception e) { return null; }
}
private GiveResult createGiveResult(boolean s, Map<String, Object> m) {
try {
GiveResult r = (giveResultCtor.getParameterCount() == 0) ? giveResultCtor.newInstance() : giveResultCtor.newInstance(s);
if (giveResultMapField != null) giveResultMapField.set(r, m);
return r;
} catch (Exception e) { return null; }
}
private boolean isSimulationContext() {
return StackWalker.getInstance().walk(s -> s.anyMatch(f -> f.getClassName().contains("ModifyDisplayItem")));
}
}
public static class EcoBridgeDynamicLimit extends ObjectLimit {
private final EcoBridge plugin;
private final ObjectLimit original;
public EcoBridgeDynamicLimit(EcoBridge plugin, ObjectLimit original) {
this.plugin = plugin;
this.original = original;
}
@Override
public int getPlayerLimits(Player player) {
if (plugin.getConfig().getBoolean("economy.macro.panic-mode", false)) return 20;
return original != null ? original.getPlayerLimits(player) : -1;
}
@Override
public int getServerLimits(Player player) {
return original != null ? original.getServerLimits(player) : -1;
}
}
}

==================================================
FILE: ecobridge-java\src\main\java\top\ellan\ecobridge\listener\CacheListener.java
==================================================

package top.ellan.ecobridge.listener;
import org.bukkit.event.EventHandler;
import org.bukkit.event.EventPriority;
import org.bukkit.event.Listener;
import org.bukkit.event.player.PlayerJoinEvent;
import org.bukkit.event.player.PlayerQuitEvent;
import top.ellan.ecobridge.cache.HotDataCache;
import top.ellan.ecobridge.util.LogUtil;
import java.util.UUID;
public class CacheListener implements Listener {
@EventHandler(priority = EventPriority.LOW)
public void onJoin(PlayerJoinEvent event) {
UUID uuid = event.getPlayer().getUniqueId();
HotDataCache.load(uuid);
LogUtil.debug("已为玩家 " + event.getPlayer().getName() + " 开启数据热路径缓存。");
}
@EventHandler(priority = EventPriority.MONITOR)
public void onQuit(PlayerQuitEvent event) {
UUID uuid = event.getPlayer().getUniqueId();
HotDataCache.invalidate(uuid);
LogUtil.debug("玩家 " + event.getPlayer().getName() + " 已下线，正在执行热数据卸载。");
}
}

==================================================
FILE: ecobridge-java\src\main\java\top\ellan\ecobridge\listener\CoinsEngineListener.java
==================================================

package top.ellan.ecobridge.listener;
import org.bukkit.event.EventHandler;
import org.bukkit.event.EventPriority;
import org.bukkit.event.Listener;
import su.nightexpress.coinsengine.api.currency.Currency;
import su.nightexpress.coinsengine.api.event.ChangeBalanceEvent;
import su.nightexpress.coinsengine.data.impl.CoinsUser;
import top.ellan.ecobridge.EcoBridge;
import top.ellan.ecobridge.cache.HotDataCache;
import top.ellan.ecobridge.database.TransactionDao;
import top.ellan.ecobridge.manager.EconomyManager;
import top.ellan.ecobridge.storage.AsyncLogger;
import java.util.UUID;
public class CoinsEngineListener implements Listener {
private final String targetCurrencyId;
private static final double EPSILON = 1e-6;
public CoinsEngineListener(EcoBridge plugin) {
this.targetCurrencyId = plugin.getConfig().getString("economy.currency-id", "coins");
}
@EventHandler(priority = EventPriority.MONITOR, ignoreCancelled = true)
public void onBalanceChange(ChangeBalanceEvent event) {
Currency currency = event.getCurrency();
if (!targetCurrencyId.equals(currency.getId())) {
return;
}
double oldAmount = event.getOldAmount();
double newAmount = event.getNewAmount();
double delta = newAmount - oldAmount;
if (Math.abs(delta) < EPSILON) {
return;
}
EconomyManager.getInstance().onTransaction(delta, true);
CoinsUser user = event.getUser();
UUID userUuid = user.getId();
var cachedData = HotDataCache.get(userUuid);
if (cachedData != null) {
cachedData.updateFromTruth(newAmount);
}
TransactionDao.updateBalance(userUuid, newAmount);
long timestamp = System.currentTimeMillis();
AsyncLogger.log(
userUuid,
delta,
newAmount,
timestamp
);
}
}

==================================================
FILE: ecobridge-java\src\main\java\top\ellan\ecobridge\listener\CommandInterceptor.java
==================================================

package top.ellan.ecobridge.listener;
import org.bukkit.Bukkit;
import org.bukkit.entity.Player;
import org.bukkit.event.EventHandler;
import org.bukkit.event.EventPriority;
import org.bukkit.event.Listener;
import org.bukkit.event.player.PlayerCommandPreprocessEvent;
import su.nightexpress.coinsengine.api.CoinsEngineAPI;
import su.nightexpress.coinsengine.api.currency.Currency;
import top.ellan.ecobridge.EcoBridge;
import top.ellan.ecobridge.manager.TransferManager;
import top.ellan.ecobridge.util.LogUtil;
import java.util.*;
public class CommandInterceptor implements Listener {
private final Map<String, Currency> interceptMap = new HashMap<>();
public CommandInterceptor(EcoBridge plugin) {
reloadCache();
}
public void reloadCache() {
interceptMap.clear();
if (CoinsEngineAPI.getCurrencyRegistry() == null) {
LogUtil.warn("CoinsEngine 注册表尚未就绪，指令拦截器暂缓加载。");
return;
}
CoinsEngineAPI.getCurrencyRegistry().getCurrencies().forEach(currency -> {
Arrays.stream(currency.getCommandAliases())
.map(String::toLowerCase)
.forEach(alias -> interceptMap.put(alias, currency));
});
List<String> commonCmds = Arrays.asList("pay", "transfer", "epay", "balance", "money");
commonCmds.forEach(cmd -> interceptMap.put(cmd, null));
LogUtil.info("指令拦截器已就绪，监控指令数: " + interceptMap.size());
}
@EventHandler(priority = EventPriority.HIGHEST, ignoreCancelled = true)
public void onCommandPreprocess(PlayerCommandPreprocessEvent event) {
Player sender = event.getPlayer();
if (sender.hasPermission("ecobridge.admin.bypass")) {
return;
}
String rawMessage = event.getMessage().substring(1);
String[] parts = rawMessage.split("\\s+");
if (parts.length < 1) return;
String fullLabel = parts[0].toLowerCase();
String label = fullLabel.contains(":") ? fullLabel.split(":")[1] : fullLabel;
if (!interceptMap.containsKey(label)) {
return;
}
Currency currency = interceptMap.get(label);
boolean isTransfer = false;
int targetIdx = -1;
int amountIdx = -1;
if (currency == null) {
if (label.equals("pay") || label.equals("transfer") || label.equals("epay")) {
isTransfer = true;
targetIdx = 1;
amountIdx = 2;
currency = CoinsEngineAPI.getCurrencyRegistry().getCurrencies().stream()
.filter(Currency::isPrimary)
.findFirst()
.orElse(null);
}
}
else {
if (parts.length > 1) {
String subCmd = parts[1].toLowerCase();
if (subCmd.equals("pay") || subCmd.equals("send")) {
isTransfer = true;
targetIdx = 2;
amountIdx = 3;
}
}
}
if (!isTransfer) return;
event.setCancelled(true);
if (parts.length <= amountIdx) {
sender.sendMessage(EcoBridge.getMiniMessage().deserialize(
"<yellow>EcoBridge 用法: /" + label + (interceptMap.get(label) == null ? "" : " pay") + " <玩家> <金额>"
));
return;
}
if (currency == null) {
sender.sendMessage(EcoBridge.getMiniMessage().deserialize("<red>错误: 系统未配置主货币 (isPrimary=true)。"));
return;
}
handleTransfer(sender, currency, parts[targetIdx], parts[amountIdx]);
}
private void handleTransfer(Player sender, Currency currency, String targetName, String amountStr) {
if (sender.getName().equalsIgnoreCase(targetName)) {
sender.sendMessage(EcoBridge.getMiniMessage().deserialize("<red>错误: 无法对自己转账。"));
return;
}
Player receiver = Bukkit.getPlayer(targetName);
if (receiver == null) {
sender.sendMessage(EcoBridge.getMiniMessage().deserialize("<red>错误: 目标玩家不在线。"));
return;
}
try {
double amount = Double.parseDouble(amountStr);
if (Double.isNaN(amount) || Double.isInfinite(amount) || amount <= 0) {
sender.sendMessage(EcoBridge.getMiniMessage().deserialize("<red>错误: 无效的金额。"));
return;
}
double minAmount = currency.getMinTransferAmount();
if (minAmount > 0 && amount < minAmount) {
sender.sendMessage(EcoBridge.getMiniMessage().deserialize("<red>错误: 转账金额低于最小限制 (" + minAmount + ")"));
return;
}
TransferManager.getInstance().initiateTransfer(sender, receiver, amount);
} catch (NumberFormatException e) {
sender.sendMessage(EcoBridge.getMiniMessage().deserialize("<red>错误: 金额必须为纯数字。"));
}
}
}

==================================================
FILE: ecobridge-java\src\main\java\top\ellan\ecobridge\listener\TradeListener.java
==================================================

package top.ellan.ecobridge.listener;
import cn.superiormc.ultimateshop.api.ItemFinishTransactionEvent;
import cn.superiormc.ultimateshop.objects.buttons.ObjectItem;
import net.kyori.adventure.text.minimessage.tag.resolver.Placeholder;
import org.bukkit.Bukkit;
import org.bukkit.entity.Player;
import org.bukkit.event.EventHandler;
import org.bukkit.event.EventPriority;
import org.bukkit.event.Listener;
import org.bukkit.event.player.PlayerQuitEvent;
import top.ellan.ecobridge.EcoBridge;
import top.ellan.ecobridge.manager.EconomyManager;
import top.ellan.ecobridge.manager.PricingManager;
import top.ellan.ecobridge.util.LogUtil;
import top.ellan.ecobridge.util.TimeMonitor;
import java.util.Map;
import java.util.UUID;
import java.util.concurrent.ConcurrentHashMap;
public class TradeListener implements Listener {
private final EcoBridge plugin;
private final Map<UUID, Long> tradeThrottle = new ConcurrentHashMap<>();
private final long throttleThresholdMs;
public TradeListener(EcoBridge plugin) {
this.plugin = plugin;
this.throttleThresholdMs = plugin.getConfig().getLong("system.trade-throttle-ms", 150L);
}
@EventHandler(priority = EventPriority.MONITOR, ignoreCancelled = true)
public void onShopTrade(ItemFinishTransactionEvent event) {
final Player player = event.getPlayer();
final ObjectItem item = event.getItem();
if (item == null || item.empty) return;
final double rawAmount = (double) event.getAmount();
final boolean isBuy = event.isBuyOrSell();
final long now = System.currentTimeMillis();
if (isThrottled(player.getUniqueId(), now)) return;
TimeMonitor.checkAndResetQuota(player, item);
final String playerName = player.getName();
final UUID playerUuid = player.getUniqueId();
plugin.getVirtualExecutor().execute(() -> {
try {
double effectiveAmount = isBuy ? -rawAmount : rawAmount;
EconomyManager.getInstance().onTransaction(effectiveAmount, true);
PricingManager.getInstance().onTradeComplete(item, effectiveAmount);
if (!isBuy && rawAmount > 500) {
Bukkit.getScheduler().runTask(plugin, () -> {
Player onlinePlayer = Bukkit.getPlayer(playerUuid);
if (onlinePlayer != null && onlinePlayer.isOnline()) {
sendBehavioralGuidance(onlinePlayer, rawAmount);
}
});
}
logTrade(playerName, item, isBuy, rawAmount, effectiveAmount);
} catch (Throwable e) {
LogUtil.error("交易演算流水线异常 [" + item.getProduct() + "]", e);
}
});
}
private void sendBehavioralGuidance(Player player, double amount) {
player.sendMessage(EcoBridge.getMiniMessage().deserialize(
"<blue>⚖</blue> <gray>大宗交易提醒：本次出售量为 <white><amt></white>。",
Placeholder.unparsed("amt", String.format("%.0f", amount))
));
if (amount > 2000) {
player.sendMessage(EcoBridge.getMiniMessage().deserialize(
"<red>⚠</red> <yellow>市场饱和警告：单次抛售超 2000 件已触发深度折价。建议分段出售以保护利润。"
));
} else {
player.sendMessage(EcoBridge.getMiniMessage().deserialize(
"<aqua>ℹ</aqua> <gray>提示：单次交易过大会产生边际效用递减，小额多次交易收益更高。"
));
}
}
private boolean isThrottled(UUID uuid, long now) {
Long lastTime = tradeThrottle.get(uuid);
if (lastTime != null && (now - lastTime) < throttleThresholdMs) {
return true;
}
tradeThrottle.put(uuid, now);
return false;
}
private void logTrade(String playerName, ObjectItem item, boolean isBuy, double raw, double eff) {
if (!plugin.getConfig().getBoolean("system.log-transactions", true)) return;
LogUtil.logTransactionSampled(
"<gray>[EcoBridge] <action> <white><id> <gray>x<amt> <dark_gray>(权重: <eff>) <gray>玩家: <p>",
Placeholder.unparsed("action", isBuy ? "<gold>买入" : "<aqua>卖出"),
Placeholder.unparsed("id", item.getProduct()),
Placeholder.unparsed("amt", String.format("%.1f", raw)),
Placeholder.unparsed("eff", String.format("%.1f", eff)),
Placeholder.unparsed("p", playerName)
);
}
@EventHandler
public void onQuit(PlayerQuitEvent e) {
tradeThrottle.remove(e.getPlayer().getUniqueId());
}
}

==================================================
FILE: ecobridge-java\src\main\java\top\ellan\ecobridge\manager\EconomicStateManager.java
==================================================

package top.ellan.ecobridge.manager;
import com.github.benmanes.caffeine.cache.Cache;
import com.github.benmanes.caffeine.cache.Caffeine;
import org.bukkit.Bukkit;
import org.bukkit.entity.Player;
import top.ellan.ecobridge.EcoBridge;
import top.ellan.ecobridge.database.TransactionDao;
import top.ellan.ecobridge.util.LogUtil;
import java.util.Map;
import java.util.concurrent.ConcurrentHashMap;
import java.util.concurrent.TimeUnit;
public class EconomicStateManager {
private static EconomicStateManager instance;
private final Map<String, MarketPhase> lastKnownPhases = new ConcurrentHashMap<>();
private final Cache<String, Double> anchorCache = Caffeine.newBuilder()
.expireAfterWrite(5, TimeUnit.MINUTES)
.maximumSize(1000)
.build();
public enum MarketPhase {
STABLE,
SATURATED,
EMERGENCY,
HEALING
}
private EconomicStateManager() {}
public static void init(EcoBridge plugin) {
instance = new EconomicStateManager();
}
public static EconomicStateManager getInstance() {
return instance;
}
public void recordPurchase(Player player, String productId, int amount) {
LogUtil.debug("记录购买: " + player.getName() + " -> " + productId + " x" + amount);
if (PricingManager.getInstance() != null) {
}
}
public void recordSale(Player player, String productId, int amount) {
LogUtil.debug("记录出售: " + player.getName() + " -> " + productId + " x" + amount);
if (PricingManager.getInstance() != null) {
PricingManager.getInstance().onTradeComplete(productId, amount);
}
Bukkit.getScheduler().runTaskAsynchronously(EcoBridge.getInstance(), () -> {
double currentNeff = amount;
analyzeMarketAndNotify(productId, currentNeff);
});
}
public MarketPhase analyzeMarketAndNotify(String productId, double currentNeff) {
Double anchorValue = anchorCache.get(productId, k -> TransactionDao.get7DayAverage(k));
if (anchorValue == null || anchorValue <= 0) return MarketPhase.STABLE;
double impactIndex = currentNeff / anchorValue;
MarketPhase currentPhase;
MarketPhase oldPhase = lastKnownPhases.getOrDefault(productId, MarketPhase.STABLE);
if (impactIndex > 3.5) {
currentPhase = MarketPhase.EMERGENCY;
} else if (impactIndex > 1.8) {
currentPhase = MarketPhase.SATURATED;
} else if (oldPhase == MarketPhase.EMERGENCY && impactIndex < 1.5) {
currentPhase = MarketPhase.HEALING;
} else if (impactIndex < 1.2) {
currentPhase = MarketPhase.STABLE;
} else {
currentPhase = oldPhase;
}
checkAndBroadcast(productId, currentPhase);
return currentPhase;
}
private void checkAndBroadcast(String productId, MarketPhase newPhase) {
MarketPhase oldPhase = lastKnownPhases.get(productId);
if (oldPhase != newPhase) {
lastKnownPhases.put(productId, newPhase);
executeBroadcast(productId, newPhase);
}
}
private void executeBroadcast(String productId, MarketPhase phase) {
String msg = switch (phase) {
case EMERGENCY -> "<red>⚖ [商会紧急干预] <white><id> <red>遭遇抛售狂潮！开启“价格保护”模式。";
case SATURATED -> "<yellow>⚠ [市场警告] <white><id> <yellow>库存积压，收购价将下调。";
case HEALING -> "<aqua>❈ [秩序恢复] <white><id> <aqua>市场正在回暖。";
case STABLE -> "<green>✔ [贸易正常化] <white><id> <green>恢复自由贸易定价。";
};
Bukkit.getScheduler().runTask(EcoBridge.getInstance(), () -> {
Bukkit.broadcast(EcoBridge.getMiniMessage().deserialize(
msg.replace("<id>", productId)
));
});
}
public double getBehavioralLambdaModifier(MarketPhase phase) {
return switch (phase) {
case EMERGENCY -> 0.35;
case SATURATED -> 0.60;
case HEALING -> 0.85;
default -> 1.0;
};
}
}

==================================================
FILE: ecobridge-java\src\main\java\top\ellan\ecobridge\manager\EconomyManager.java
==================================================

package top.ellan.ecobridge.manager;
import org.bukkit.Bukkit;
import top.ellan.ecobridge.EcoBridge;
import top.ellan.ecobridge.bridge.NativeBridge;
import top.ellan.ecobridge.util.LogUtil;
import java.util.concurrent.Executors;
import java.util.concurrent.ScheduledExecutorService;
import java.util.concurrent.TimeUnit;
import java.util.concurrent.atomic.AtomicLong;
import java.util.concurrent.atomic.DoubleAdder;
import java.util.concurrent.locks.ReentrantLock;
public class EconomyManager {
private static EconomyManager instance;
private final EcoBridge plugin;
private volatile double inflationRate = 0.0;
private volatile double marketHeat = 0.0;
private volatile double ecoSaturation = 0.0;
private final DoubleAdder circulationHeat = new DoubleAdder();
private final DoubleAdder tradeVolumeAccumulator = new DoubleAdder();
private final AtomicLong lastVolatileTimestamp = new AtomicLong(0);
private long lastMacroUpdateTime = System.currentTimeMillis();
private double m1MoneySupply;
private double volatilityThreshold;
private double decayRate;
private double capacityPerUser;
private final ScheduledExecutorService economicScheduler;
private final ReentrantLock configLock = new ReentrantLock();
private EconomyManager(EcoBridge plugin) {
this.plugin = plugin;
this.economicScheduler = Executors.newSingleThreadScheduledExecutor(
Thread.ofVirtual().name("EcoBridge-Economy-Worker").factory()
);
loadState();
startEconomicTasks();
startMacroAnalyticsTask();
}
public static void init(EcoBridge plugin) {
instance = new EconomyManager(plugin);
}
public static EconomyManager getInstance() {
return instance;
}
public void loadState() {
var config = plugin.getConfig();
this.m1MoneySupply = config.getDouble("economy.m1-supply", 10_000_000.0);
this.volatilityThreshold = config.getDouble("economy.volatility-threshold", 50_000.0);
this.decayRate = config.getDouble("economy.daily-decay-rate", 0.05);
this.capacityPerUser = config.getDouble("economy.macro.capacity-per-user", 5000.0);
double savedHeat = config.getDouble("internal.economy-heat", 0.0);
circulationHeat.reset();
circulationHeat.add(savedHeat);
LogUtil.info("EconomyManager 初始化: M1=" + m1MoneySupply + ", 初始累积热度=" + savedHeat);
}
public void onTransaction(double amount, boolean isMarketActivity) {
double absAmount = Math.abs(amount);
if (!isMarketActivity) {
this.m1MoneySupply += amount;
return;
}
tradeVolumeAccumulator.add(absAmount);
circulationHeat.add(absAmount);
if (absAmount >= volatilityThreshold) {
lastVolatileTimestamp.set(System.currentTimeMillis());
}
}
public void recordTradeVolume(double amount) {
onTransaction(amount, true);
}
private void startMacroAnalyticsTask() {
economicScheduler.scheduleAtFixedRate(() -> {
try {
long now = System.currentTimeMillis();
double dt = (now - lastMacroUpdateTime) / 1000.0;
if (dt < 0.1) return;
double currentWindowVolume = tradeVolumeAccumulator.sumThenReset();
this.marketHeat = currentWindowVolume / dt;
int online = Bukkit.getOnlinePlayers().size();
double totalCapacity = Math.max(1, online) * capacityPerUser;
this.ecoSaturation = Math.min(1.0, marketHeat / totalCapacity);
if (NativeBridge.isLoaded()) {
this.inflationRate = NativeBridge.calcInflation(marketHeat, m1MoneySupply);
}
lastMacroUpdateTime = now;
} catch (Exception e) {
LogUtil.warn("宏观画像任务异常: " + e.getMessage());
}
}, 1, 1, TimeUnit.SECONDS);
}
private void startEconomicTasks() {
economicScheduler.scheduleAtFixedRate(this::runEconomicDecay, 30, 30, TimeUnit.MINUTES);
}
private void runEconomicDecay() {
if (!NativeBridge.isLoaded()) return;
double currentTotal = circulationHeat.sum();
double reduction = NativeBridge.calcDecay(currentTotal, decayRate);
if (Math.abs(reduction) > 0.01) {
circulationHeat.add(-reduction);
if (reduction > 100.0) saveState();
}
}
public void saveState() {
double currentTotal = circulationHeat.sum();
plugin.getVirtualExecutor().execute(() -> {
configLock.lock();
try {
plugin.getConfig().set("internal.economy-heat", currentTotal);
plugin.saveConfig();
} finally {
configLock.unlock();
}
});
}
public double getMarketHeat() { return this.marketHeat; }
public double getEcoSaturation() { return this.ecoSaturation; }
public double getInflationRate() { return this.inflationRate; }
public double getStabilityFactor() {
if (!NativeBridge.isLoaded()) return 1.0;
return NativeBridge.calcStability(lastVolatileTimestamp.get(), System.currentTimeMillis());
}
public void shutdown() {
economicScheduler.shutdown();
saveState();
}
}

==================================================
FILE: ecobridge-java\src\main\java\top\ellan\ecobridge\manager\PricingManager.java
==================================================

package top.ellan.ecobridge.manager;
import cn.superiormc.ultimateshop.managers.ConfigManager;
import cn.superiormc.ultimateshop.objects.ObjectShop;
import cn.superiormc.ultimateshop.objects.buttons.ObjectItem;
import com.github.benmanes.caffeine.cache.Cache;
import com.github.benmanes.caffeine.cache.Caffeine;
import com.github.benmanes.caffeine.cache.RemovalCause;
import org.bukkit.Bukkit;
import org.bukkit.entity.Player;
import top.ellan.ecobridge.EcoBridge;
import top.ellan.ecobridge.api.event.PriceCalculatedEvent;
import top.ellan.ecobridge.bridge.NativeBridge;
import top.ellan.ecobridge.database.TransactionDao;
import top.ellan.ecobridge.engine.PriceComputeEngine;
import top.ellan.ecobridge.model.SaleRecord;
import top.ellan.ecobridge.network.RedisManager;
import top.ellan.ecobridge.storage.AsyncLogger;
import top.ellan.ecobridge.util.LogUtil;
import top.ellan.ecobridge.util.PriceOracle;
import java.lang.foreign.Arena;
import java.lang.foreign.MemorySegment;
import java.time.Duration;
import java.util.*;
import java.util.concurrent.CompletableFuture;
import java.util.concurrent.TimeUnit;
import java.util.concurrent.atomic.AtomicLong;
import java.util.concurrent.atomic.AtomicReference;
import java.util.concurrent.locks.ReentrantReadWriteLock;
public class PricingManager {
private static PricingManager instance;
private final EcoBridge plugin;
private final Arena managerArena = Arena.ofShared();
private final MemorySegment globalPidState;
private final AtomicReference<Map<String, Double>> priceSnapshot =
new AtomicReference<>(Collections.emptyMap());
private final Cache<String, ReentrantReadWriteLock> itemLocks;
private final AtomicLong globalTradeCounter = new AtomicLong(0);
private long lastComputeTime = System.currentTimeMillis();
private final Cache<String, ThreadSafeHistory> historyCache;
private volatile boolean isRunning = true;
private double defaultLambda;
private double configTau;
private double sellRatio;
private int historyDaysLimit;
private int maxHistorySize;
private double targetTradesPerUser;
private PricingManager(EcoBridge plugin) {
this.plugin = plugin;
this.itemLocks = Caffeine.newBuilder()
.expireAfterAccess(Duration.ofMinutes(10))
.build();
this.historyCache = Caffeine.newBuilder()
.maximumSize(2000)
.expireAfterAccess(Duration.ofMinutes(30))
.removalListener((String key, ThreadSafeHistory value, RemovalCause cause) -> {
if (cause.wasEvicted()) {
LogUtil.debug("缓存清理: 商品 " + key + " 已从内存安全释放 (" + cause.name() + ")");
}
})
.build();
this.globalPidState = managerArena.allocate(NativeBridge.Layouts.PID_STATE);
NativeBridge.resetPidState(globalPidState);
loadConfig();
startSnapshotEngine();
}
public static void init(EcoBridge plugin) {
instance = new PricingManager(plugin);
}
public static PricingManager getInstance() {
return instance;
}
public ReentrantReadWriteLock getItemLock(String productId) {
return itemLocks.get(productId, k -> new ReentrantReadWriteLock());
}
public void loadConfig() {
var config = plugin.getConfig();
this.defaultLambda = config.getDouble("economy.default-lambda", 0.002);
this.configTau = config.getDouble("economy.tau", 7.0);
this.sellRatio = config.getDouble("economy.sell-ratio", 0.5);
this.historyDaysLimit = config.getInt("economy.history-days-limit", 7);
this.maxHistorySize = config.getInt("economy.max-history-records", 3000);
this.targetTradesPerUser = config.getDouble("economy.macro.target-velocity", 0.05);
}
public void shutdown() {
this.isRunning = false;
try {
this.historyCache.invalidateAll();
this.itemLocks.invalidateAll();
LogUtil.info("PricingManager 正在安全释放 FFM 资源...");
} finally {
if (managerArena.scope().isAlive()) {
managerArena.close();
}
}
}
private void startSnapshotEngine() {
Thread.ofVirtual().name("EcoBridge-Macro-Engine").start(() -> {
while (isRunning && plugin.isEnabled()) {
try {
long now = System.currentTimeMillis();
double dt = (now - lastComputeTime) / 1000.0;
lastComputeTime = now;
int onlineCount = CompletableFuture.supplyAsync(
() -> Bukkit.getOnlinePlayers().size(),
runnable -> Bukkit.getScheduler().runTask(plugin, runnable)
).get(100, TimeUnit.MILLISECONDS);
long currentTrades = globalTradeCounter.getAndSet(0);
double currentHeat = currentTrades / Math.max(dt, 0.1);
double targetHeat = Math.max(0.1, onlineCount * targetTradesPerUser);
double inflation = EconomyManager.getInstance().getInflationRate();
double macroAdjustment = NativeBridge.computePidAdjustment(
globalPidState, targetHeat, currentHeat, dt, inflation, currentHeat
);
Map<String, Double> nextPrices = PriceComputeEngine.computeSnapshot(
plugin, configTau, defaultLambda * macroAdjustment
);
if (!nextPrices.isEmpty()) {
priceSnapshot.set(Map.copyOf(nextPrices));
}
Thread.sleep(2000);
} catch (InterruptedException e) {
Thread.currentThread().interrupt();
break;
} catch (Throwable e) {
LogUtil.warn("宏观引擎演算异常: " + e.getMessage());
}
}
});
}
public double calculateBuyPrice(String productId) {
ObjectItem item = findObjectItem(productId);
if (item == null) return 100.0;
double dynamicPrice = getSnapshotPrice(item.getShop(), productId);
if (dynamicPrice <= 0) {
dynamicPrice = PriceOracle.getOriginalBasePrice(item, true);
}
return dynamicPrice;
}
public double calculateSellPrice(String productId) {
return calculateBuyPrice(productId) * this.sellRatio;
}
public double calculateDynamicPrice(Player player, ObjectItem item, double amount) {
String shopId = item.getShop();
String productId = item.getProduct();
var lock = getItemLock(productId).readLock();
lock.lock();
try {
double basePrice = getSnapshotPrice(shopId, productId);
if (basePrice <= 0) {
basePrice = PriceOracle.getOriginalBasePrice(item, amount < 0);
}
double calculatedPrice = NativeBridge.computeTierPrice(basePrice, Math.abs(amount), amount > 0);
PriceCalculatedEvent event = new PriceCalculatedEvent(player, shopId, productId, calculatedPrice);
if (Bukkit.isPrimaryThread()) {
Bukkit.getPluginManager().callEvent(event);
return event.getFinalPrice();
}
return CompletableFuture.runAsync(() -> Bukkit.getPluginManager().callEvent(event),
runnable -> Bukkit.getScheduler().runTask(plugin, runnable))
.thenApply(v -> event.getFinalPrice())
.orTimeout(200, TimeUnit.MILLISECONDS)
.join();
} catch (Exception e) {
return PriceOracle.getOriginalBasePrice(item, amount < 0);
} finally {
lock.unlock();
}
}
public void onTradeComplete(ObjectItem item, double effectiveAmount) {
onTradeComplete(item.getProduct(), effectiveAmount);
}
public void onTradeComplete(String productId, double effectiveAmount) {
var lock = getItemLock(productId).writeLock();
lock.lock();
try {
long now = System.currentTimeMillis();
globalTradeCounter.incrementAndGet();
SaleRecord record = new SaleRecord(now, effectiveAmount);
getHistoryContainer(productId).add(record, maxHistorySize);
plugin.getVirtualExecutor().execute(() -> {
try {
AsyncLogger.log(java.util.UUID.nameUUIDFromBytes(productId.getBytes()), effectiveAmount, 0, now, "TRX_WRITE_THROUGH");
TransactionDao.saveSaleAsync(null, productId, effectiveAmount);
} catch (Exception e) {
LogUtil.error("写穿透 SQL 任务失败: " + productId, e);
}
});
if (RedisManager.getInstance() != null) {
RedisManager.getInstance().publishTrade(productId, effectiveAmount);
}
} finally {
lock.unlock();
}
}
public void onRemoteTradeReceived(String productId, double amount, long timestamp) {
var lock = getItemLock(productId).writeLock();
lock.lock();
try {
SaleRecord record = new SaleRecord(timestamp, amount);
getHistoryContainer(productId).add(record, maxHistorySize);
} finally {
lock.unlock();
}
}
public List<SaleRecord> getGlobalHistory(String productId) {
return getHistoryContainer(productId).getSnapshot();
}
private ObjectItem findObjectItem(String productId) {
if (ConfigManager.configManager == null) return null;
for (ObjectShop shop : ConfigManager.configManager.getShops()) {
ObjectItem item = shop.getProduct(productId);
if (item != null) return item;
}
return null;
}
public double getSnapshotPrice(String shopId, String productId) {
Map<String, Double> current = priceSnapshot.get();
if (shopId == null) {
return current.entrySet().stream()
.filter(e -> e.getKey().endsWith(":" + productId))
.map(Map.Entry::getValue).findFirst().orElse(-1.0);
}
return current.getOrDefault(shopId + ":" + productId, -1.0);
}
private ThreadSafeHistory getHistoryContainer(String productId) {
ThreadSafeHistory container = historyCache.getIfPresent(productId);
if (container == null) {
container = new ThreadSafeHistory(new ArrayList<>());
historyCache.put(productId, container);
final ThreadSafeHistory finalContainer = container;
plugin.getVirtualExecutor().execute(() -> {
List<SaleRecord> initialData = TransactionDao.getProductHistory(productId, historyDaysLimit);
finalContainer.loadBatch(initialData);
});
}
return container;
}
public void clearCache() {
historyCache.invalidateAll();
itemLocks.invalidateAll();
}
private static class ThreadSafeHistory {
private final ArrayDeque<SaleRecord> deque;
private final ReentrantReadWriteLock lock = new ReentrantReadWriteLock();
public ThreadSafeHistory(List<SaleRecord> initialData) {
this.deque = new ArrayDeque<>(initialData);
}
public void loadBatch(List<SaleRecord> records) {
lock.writeLock().lock();
try {
deque.clear();
deque.addAll(records);
} finally {
lock.writeLock().unlock();
}
}
public void add(SaleRecord record, int maxSize) {
lock.writeLock().lock();
try {
deque.addFirst(record);
if (deque.size() > maxSize) deque.removeLast();
} finally {
lock.writeLock().unlock();
}
}
public List<SaleRecord> getSnapshot() {
lock.readLock().lock();
try {
return new ArrayList<>(deque);
} finally {
lock.readLock().unlock();
}
}
}
public MemorySegment getGlobalPidState() {
return globalPidState;
}
}

==================================================
FILE: ecobridge-java\src\main\java\top\ellan\ecobridge\manager\TransferManager.java
==================================================

package top.ellan.ecobridge.manager;
import com.google.common.base.Preconditions;
import net.kyori.adventure.text.Component;
import net.kyori.adventure.text.minimessage.tag.resolver.Placeholder;
import org.bukkit.Bukkit;
import org.bukkit.entity.Player;
import su.nightexpress.coinsengine.api.CoinsEngineAPI;
import su.nightexpress.coinsengine.api.currency.Currency;
import top.ellan.ecobridge.EcoBridge;
import top.ellan.ecobridge.bridge.NativeBridge;
import top.ellan.ecobridge.bridge.NativeBridge.TransferResult;
import top.ellan.ecobridge.network.RedisManager;
import top.ellan.ecobridge.storage.ActivityCollector;
import top.ellan.ecobridge.storage.AsyncLogger;
import top.ellan.ecobridge.util.LogUtil;
import java.lang.foreign.Arena;
import java.lang.foreign.MemoryLayout;
import java.lang.foreign.MemorySegment;
import java.lang.invoke.VarHandle;
import java.util.concurrent.ExecutorService;
import java.util.concurrent.Executors;
import java.util.concurrent.TimeUnit;
import static java.lang.foreign.ValueLayout.*;
public class TransferManager {
private static TransferManager instance;
private final EcoBridge plugin;
private final ExecutorService vExecutor;
private final String mainCurrencyId;
private static final String BYPASS_TAX_PERMISSION = "ecobridge.bypass.tax";
private static final String BYPASS_BLOCK_PERMISSION = "ecobridge.bypass.block";
private static final VarHandle VH_TR_AMOUNT;
private static final VarHandle VH_TR_S_BAL;
private static final VarHandle VH_TR_R_BAL;
private static final VarHandle VH_TR_INF;
private static final VarHandle VH_TR_LIMIT;
private static final VarHandle VH_TR_S_TIME;
private static final VarHandle VH_TR_R_TIME;
private static final VarHandle VH_TCTX_SCORE;
private static final VarHandle VH_TCTX_VELOCITY;
private static final VarHandle VH_RCFG_V_THRESHOLD;
static {
var layout = NativeBridge.Layouts.TRANSFER_CONTEXT;
VH_TR_AMOUNT = layout.varHandle(MemoryLayout.PathElement.groupElement("amount"));
VH_TR_S_BAL = layout.varHandle(MemoryLayout.PathElement.groupElement("sender_balance"));
VH_TR_R_BAL = layout.varHandle(MemoryLayout.PathElement.groupElement("receiver_balance"));
VH_TR_INF = layout.varHandle(MemoryLayout.PathElement.groupElement("inflation_rate"));
VH_TR_LIMIT = layout.varHandle(MemoryLayout.PathElement.groupElement("newbie_limit"));
VH_TR_S_TIME = layout.varHandle(MemoryLayout.PathElement.groupElement("sender_play_time"));
VH_TR_R_TIME = layout.varHandle(MemoryLayout.PathElement.groupElement("receiver_play_time"));
VH_TCTX_SCORE = layout.varHandle(MemoryLayout.PathElement.groupElement("sender_activity_score"));
VH_TCTX_VELOCITY = layout.varHandle(MemoryLayout.PathElement.groupElement("sender_velocity"));
var regLayout = NativeBridge.Layouts.REGULATOR_CONFIG;
VH_RCFG_V_THRESHOLD = regLayout.varHandle(MemoryLayout.PathElement.groupElement("velocity_threshold"));
}
private TransferManager(EcoBridge plugin) {
this.plugin = plugin;
this.vExecutor = Executors.newVirtualThreadPerTaskExecutor();
this.mainCurrencyId = plugin.getConfig().getString("economy.currency-id", "coins");
}
public static void init(EcoBridge plugin) {
instance = new TransferManager(plugin);
}
public static TransferManager getInstance() {
return instance;
}
public void initiateTransfer(Player sender, Player receiver, double amount) {
Currency currency = CoinsEngineAPI.getCurrency(mainCurrencyId);
if (currency == null) {
sender.sendMessage(Component.text("系统故障：找不到核心货币配置。"));
return;
}
double senderBal = CoinsEngineAPI.getBalance(sender, currency);
if (senderBal < amount) {
sender.sendMessage(EcoBridge.getMiniMessage().deserialize("<red>余额不足，转账中止。"));
return;
}
captureAndAudit(sender, receiver, currency, amount, senderBal);
}
private void captureAndAudit(Player sender, Player receiver, Currency currency, double amount, double senderBal) {
var sSnapshot = ActivityCollector.getSafeSnapshot(sender.getUniqueId());
var rSnapshot = ActivityCollector.getSafeSnapshot(receiver.getUniqueId());
double receiverBal = CoinsEngineAPI.getBalance(receiver, currency);
if (!sender.hasPermission(BYPASS_BLOCK_PERMISSION)) {
sender.sendMessage(EcoBridge.getMiniMessage().deserialize("<gray><italic>EcoKernel 正在注入宏观流速并进行行为审计..."));
}
vExecutor.submit(() -> {
try (Arena arena = Arena.ofConfined()) {
EconomyManager macro = EconomyManager.getInstance();
double inflation = macro.getInflationRate();
int currentMarketHeat = (int) macro.getMarketHeat();
MemorySegment ctx = arena.allocate(NativeBridge.Layouts.TRANSFER_CONTEXT);
VH_TR_AMOUNT.set(ctx, 0L, amount);
VH_TR_S_BAL.set(ctx, 0L, senderBal);
VH_TR_R_BAL.set(ctx, 0L, receiverBal);
VH_TR_INF.set(ctx, 0L, inflation);
VH_TR_LIMIT.set(ctx, 0L, plugin.getConfig().getDouble("economy.audit-settings.newbie-limit", 50000.0));
VH_TR_S_TIME.set(ctx, 0L, sSnapshot.playTimeSeconds());
VH_TR_R_TIME.set(ctx, 0L, rSnapshot.playTimeSeconds());
VH_TCTX_SCORE.set(ctx, 0L, sSnapshot.activityScore());
VH_TCTX_VELOCITY.set(ctx, 0L, currentMarketHeat);
MemorySegment cfg = arena.allocate(NativeBridge.Layouts.REGULATOR_CONFIG);
populateRegulatorConfig(cfg);
TransferResult result = NativeBridge.checkTransfer(ctx, cfg);
Bukkit.getScheduler().runTask(plugin, () ->
executeSettlement(sender, receiver, currency, amount, result));
} catch (Throwable e) {
LogUtil.error("审计内核响应超时或崩溃 (Macro Violation)", e);
Bukkit.getScheduler().runTask(plugin, () ->
sender.sendMessage(Component.text("内核安全屏障异常，转账已拦截。")));
}
});
}
private void executeSettlement(Player sender, Player receiver, Currency currency, double amount, TransferResult audit) {
Preconditions.checkState(Bukkit.isPrimaryThread(), "结算逻辑必须在主线程执行！");
boolean canBypassBlock = sender.isOp() || sender.hasPermission(BYPASS_BLOCK_PERMISSION);
if (audit.isBlocked() && !canBypassBlock) {
handleBlocked(sender, audit.warningCode());
return;
}
double currentSenderBal = CoinsEngineAPI.getBalance(sender, currency);
if (currentSenderBal < amount) {
sender.sendMessage(EcoBridge.getMiniMessage().deserialize("<red>转账失败：审计期间账户资金发生异常变动。"));
return;
}
boolean canBypassTax = sender.isOp() || sender.hasPermission(BYPASS_TAX_PERMISSION);
double tax = canBypassTax ? 0.0 : audit.tax();
double netAmount = amount - tax;
try {
if (!CoinsEngineAPI.removeBalance(sender.getUniqueId(), currency, amount)) {
throw new IllegalStateException("底层经济接口 CoinsEngine 拒绝扣款");
}
CoinsEngineAPI.addBalance(receiver, currency, netAmount);
EconomyManager.getInstance().recordTradeVolume(amount);
long ts = System.currentTimeMillis();
String meta = "TAX:" + tax + "|SCORE:" + ActivityCollector.getScore(sender.getUniqueId());
AsyncLogger.log(sender.getUniqueId(), -amount, currentSenderBal - amount, ts, meta);
if (RedisManager.getInstance() != null) {
RedisManager.getInstance().publishTrade("SYSTEM_TRANSFER", amount);
}
notifySuccess(sender, receiver, currency, amount, netAmount, tax, canBypassTax);
} catch (Exception e) {
LogUtil.severe("结算链路断裂！正在回滚玩家资产: " + sender.getName());
CoinsEngineAPI.addBalance(sender, currency, amount);
sender.sendMessage(Component.text("§c[系统] 结算冲突，资金已安全原路回滚。"));
}
}
private void populateRegulatorConfig(MemorySegment cfg) {
var section = plugin.getConfig().getConfigurationSection("economy.audit-settings");
if (section == null) return;
cfg.set(JAVA_DOUBLE, 0, section.getDouble("base-tax-rate", 0.05));
cfg.set(JAVA_DOUBLE, 8, section.getDouble("luxury-threshold", 100000.0));
cfg.set(JAVA_DOUBLE, 16, section.getDouble("luxury-tax-rate", 0.1));
cfg.set(JAVA_DOUBLE, 24, section.getDouble("wealth-gap-tax-rate", 0.2));
cfg.set(JAVA_DOUBLE, 32, section.getDouble("poor-threshold", 10000.0));
cfg.set(JAVA_DOUBLE, 40, section.getDouble("rich-threshold", 1000000.0));
cfg.set(JAVA_DOUBLE, 48, section.getDouble("newbie-receive-limit", 50000.0));
cfg.set(JAVA_DOUBLE, 56, section.getDouble("warning-ratio", 0.9));
cfg.set(JAVA_DOUBLE, 64, section.getDouble("warning-min-amount", 50000.0));
cfg.set(JAVA_DOUBLE, 72, section.getDouble("newbie-hours", 10.0));
cfg.set(JAVA_DOUBLE, 80, section.getDouble("veteran-hours", 100.0));
VH_RCFG_V_THRESHOLD.set(cfg, 0L, section.getDouble("velocity-threshold", 20.0));
}
private void handleBlocked(Player sender, int code) {
String reason = switch (code) {
case 1 -> "涉嫌非正常资金归集 (风险评级过高)";
case 2 -> "拦截逆向流转 (新手向老手异常输送)";
case 3 -> "拦截非正常注资 (老手向新手违规注资)";
case 4 -> "账户余额不足 (结算冲突)";
case 5 -> "财富流速异常 (疑似洗钱/拆分转账)";
default -> "违反服务器金融合规协议 (Audit Code: " + code + ")";
};
sender.sendMessage(EcoBridge.getMiniMessage().deserialize("<red>⚠ 审计拒绝: <yellow>" + reason));
}
private void notifySuccess(Player s, Player r, Currency cur, double total, double net, double tax, boolean isTaxFree) {
String suffix = isTaxFree ? " <dark_gray>[免税特权]</dark_gray>" : "";
s.sendMessage(EcoBridge.getMiniMessage().deserialize("<green>✔ 成功转出 <gold><amt><gray> (税费: <tax>)" + suffix,
Placeholder.unparsed("amt", cur.format(total)),
Placeholder.unparsed("tax", cur.format(tax))));
r.sendMessage(EcoBridge.getMiniMessage().deserialize("<green>➕ 收到 <gold><amt><gray> 来自 <p>",
Placeholder.unparsed("amt", cur.format(net)),
Placeholder.unparsed("p", s.getName())));
}
public void shutdown() {
vExecutor.shutdown();
try {
if (!vExecutor.awaitTermination(5, TimeUnit.SECONDS)) vExecutor.shutdownNow();
} catch (InterruptedException e) {
vExecutor.shutdownNow();
}
}
}

==================================================
FILE: ecobridge-java\src\main\java\top\ellan\ecobridge\model\SaleRecord.java
==================================================

package top.ellan.ecobridge.model;
import net.kyori.adventure.text.Component;
import net.kyori.adventure.text.minimessage.MiniMessage;
import net.kyori.adventure.text.minimessage.tag.resolver.Placeholder;
import java.lang.foreign.GroupLayout;
import java.lang.foreign.MemoryLayout;
import java.lang.foreign.MemorySegment;
import java.lang.invoke.VarHandle;
import java.time.Instant;
import java.time.ZoneId;
import java.time.format.DateTimeFormatter;
import static java.lang.foreign.ValueLayout.JAVA_DOUBLE;
import static java.lang.foreign.ValueLayout.JAVA_LONG;
public record SaleRecord(
long timestamp,
double amount
) {
public static final GroupLayout LAYOUT = MemoryLayout.structLayout(
JAVA_LONG.withName("timestamp"),
JAVA_DOUBLE.withName("amount")
).withByteAlignment(8);
public static final long LAYOUT_SIZE = LAYOUT.byteSize();
private static final VarHandle VH_TIMESTAMP = LAYOUT.varHandle(MemoryLayout.PathElement.groupElement("timestamp"));
private static final VarHandle VH_AMOUNT = LAYOUT.varHandle(MemoryLayout.PathElement.groupElement("amount"));
public long getTimestamp() {
return timestamp;
}
public double getAmount() {
return amount;
}
public void writeToMemory(MemorySegment segment, long baseOffset) {
VH_TIMESTAMP.set(segment, baseOffset, this.timestamp);
VH_AMOUNT.set(segment, baseOffset, this.amount);
}
public static SaleRecord fromMemory(MemorySegment segment, long baseOffset) {
return new SaleRecord(
(long) VH_TIMESTAMP.get(segment, baseOffset),
(double) VH_AMOUNT.get(segment, baseOffset)
);
}
private static final DateTimeFormatter DATE_FORMAT = DateTimeFormatter.ofPattern("MM-dd HH:mm")
.withZone(ZoneId.systemDefault());
public SaleRecord {
if (Double.isNaN(amount) || Double.isInfinite(amount) || Math.abs(amount) > 10_000_000) {
throw new IllegalArgumentException("交易数据溢出风险: " + amount);
}
}
public Component toComponent() {
String color = amount >= 0 ? "<aqua>" : "<gold>";
String prefix = amount >= 0 ? "+" : "";
String timeStr = DATE_FORMAT.format(Instant.ofEpochMilli(timestamp));
String amtStr = String.format("%.1f", amount);
return MiniMessage.miniMessage().deserialize(
"<gray>[<time>] " + color + "<prefix><amt>",
Placeholder.unparsed("time", timeStr),
Placeholder.unparsed("prefix", prefix),
Placeholder.unparsed("amt", amtStr)
);
}
}

==================================================
FILE: ecobridge-java\src\main\java\top\ellan\ecobridge\network\RedisManager.java
==================================================

package top.ellan.ecobridge.network;
import tools.jackson.core.JacksonException;
import tools.jackson.databind.ObjectMapper;
import tools.jackson.databind.json.JsonMapper;
import tools.jackson.databind.DeserializationFeature;
import redis.clients.jedis.Connection;
import redis.clients.jedis.ConnectionPoolConfig;
import redis.clients.jedis.DefaultJedisClientConfig;
import redis.clients.jedis.HostAndPort;
import redis.clients.jedis.Jedis;
import redis.clients.jedis.JedisPubSub;
import redis.clients.jedis.providers.PooledConnectionProvider;
import top.ellan.ecobridge.EcoBridge;
import top.ellan.ecobridge.manager.PricingManager;
import top.ellan.ecobridge.util.LogUtil;
import java.util.concurrent.LinkedBlockingDeque;
import java.util.concurrent.atomic.AtomicBoolean;
public class RedisManager {
private static RedisManager instance;
private final EcoBridge plugin;
private final ObjectMapper mapper;
private PooledConnectionProvider provider;
private volatile JedisPubSub subscriber;
private final boolean enabled;
private final String serverId;
private final String tradeChannel;
private final AtomicBoolean active = new AtomicBoolean(false);
private final LinkedBlockingDeque<TradePacket> offlineQueue = new LinkedBlockingDeque<>(5000);
private final AtomicBoolean isFlushing = new AtomicBoolean(false);
private RedisManager(EcoBridge plugin) {
this.plugin = plugin;
var config = plugin.getConfig();
this.enabled = config.getBoolean("redis.enabled", false);
this.serverId = config.getString("redis.server-id", "unknown_server");
this.tradeChannel = config.getString("redis.channels.trade", "ecobridge:global_trade");
this.mapper = JsonMapper.builder()
.disable(DeserializationFeature.FAIL_ON_TRAILING_TOKENS)
.build();
if (enabled) {
try {
connect();
} catch (Exception e) {
LogUtil.error("Redis 初始化失败，跨服同步功能已禁用。", e);
}
}
}
public static void init(EcoBridge plugin) {
instance = new RedisManager(plugin);
}
public static RedisManager getInstance() {
return instance;
}
private void connect() {
var config = plugin.getConfig();
String host = config.getString("redis.host", "127.0.0.1");
int port = config.getInt("redis.port", 6379);
HostAndPort address = new HostAndPort(host, port);
DefaultJedisClientConfig.Builder clientConfigBuilder = DefaultJedisClientConfig.builder();
String user = config.getString("redis.user", "");
String password = config.getString("redis.password", "");
if (user != null && !user.isBlank()) clientConfigBuilder.user(user);
if (password != null && !password.isBlank()) clientConfigBuilder.password(password);
clientConfigBuilder.ssl(config.getBoolean("redis.ssl", false));
clientConfigBuilder.timeoutMillis(5000);
clientConfigBuilder.socketTimeoutMillis(5000);
ConnectionPoolConfig poolConfig = new ConnectionPoolConfig();
poolConfig.setMaxTotal(32);
poolConfig.setMaxIdle(8);
poolConfig.setMinIdle(4);
poolConfig.setTestOnBorrow(true);
poolConfig.setJmxEnabled(false);
this.provider = new PooledConnectionProvider(address, clientConfigBuilder.build(), poolConfig);
this.active.set(true);
LogUtil.info("<green>Redis 通道已打开 (Jackson 3.x 驱动)。ID: " + serverId);
startSubscriberLoop();
}
private void startSubscriberLoop() {
Thread.ofVirtual().name("EcoBridge-Redis-Sub").start(() -> {
int retryCount = 0;
while (active.get() && plugin.isEnabled()) {
try (Connection connection = provider.getConnection();
Jedis jedis = new Jedis(connection)) {
retryCount = 0;
flushOfflineQueueAsync();
this.subscriber = new JedisPubSub() {
@Override
public void onMessage(String channel, String message) {
if (channel.equals(tradeChannel)) handleTradePacket(message);
}
};
LogUtil.debug("已启动 Redis 全球贸易监听...");
jedis.subscribe(subscriber, tradeChannel);
} catch (Exception e) {
if (active.get() && plugin.isEnabled()) {
retryCount++;
long sleepTime = Math.min(retryCount * 2000L, 20000L);
LogUtil.warn("Redis 通信链路中断，将在 " + (sleepTime/1000) + "s 后尝试重连...");
try { Thread.sleep(sleepTime); }
catch (InterruptedException ie) { Thread.currentThread().interrupt(); break; }
}
}
}
});
}
public void publishTrade(String productId, double amount) {
if (!enabled || !active.get()) return;
TradePacket packet = new TradePacket(serverId, productId, amount, System.currentTimeMillis());
offerToQueue(packet);
flushOfflineQueueAsync();
}
private void offerToQueue(TradePacket packet) {
if (!offlineQueue.offer(packet)) {
offlineQueue.poll();
offlineQueue.offer(packet);
if (LogUtil.isDebugEnabled()) LogUtil.debug("Redis 发送缓冲区溢出，已滑动覆盖。");
}
}
private void flushOfflineQueueAsync() {
if (isFlushing.compareAndSet(false, true)) {
plugin.getVirtualExecutor().execute(this::flushLoop);
}
}
private void flushLoop() {
final int BATCH_SIZE = 100;
final long MAX_FLUSH_TIME_MS = 5000;
try {
long startTime = System.currentTimeMillis();
try (Connection connection = provider.getConnection();
Jedis jedis = new Jedis(connection)) {
int processed = 0;
while (!offlineQueue.isEmpty() && active.get()) {
TradePacket packet = offlineQueue.peek();
if (packet == null) break;
try {
String json = mapper.writeValueAsString(packet);
jedis.publish(tradeChannel, json);
offlineQueue.poll();
} catch (JacksonException e) {
LogUtil.error("Redis 序列化坏包，已丢弃: " + e.getMessage(), e);
offlineQueue.poll();
}
processed++;
if (processed >= BATCH_SIZE ||
(System.currentTimeMillis() - startTime) > MAX_FLUSH_TIME_MS) {
break;
}
}
}
} catch (Exception e) {
LogUtil.warn("Redis 批量冲刷中止: " + e.getMessage());
} finally {
isFlushing.set(false);
if (!offlineQueue.isEmpty() && active.get()) {
flushOfflineQueueAsync();
}
}
}
private void handleTradePacket(String json) {
try {
if (json == null || json.isBlank()) return;
TradePacket packet = mapper.readValue(json, TradePacket.class);
if (packet == null || serverId.equals(packet.sourceServer)) return;
if (PricingManager.getInstance() != null) {
PricingManager.getInstance().onRemoteTradeReceived(
packet.productId, packet.amount, packet.timestamp
);
}
} catch (JacksonException e) {
LogUtil.warn("收到格式错误的贸易包: " + e.getMessage());
} catch (Exception e) {
LogUtil.warn("处理跨服贸易包失败: " + e.getMessage());
}
}
public void shutdown() {
active.set(false);
if (!offlineQueue.isEmpty() && provider != null) {
try (Connection connection = provider.getConnection();
Jedis jedis = new Jedis(connection)) {
LogUtil.info("正在执行 Redis 临终同步，剩余包: " + offlineQueue.size());
while (!offlineQueue.isEmpty()) {
TradePacket p = offlineQueue.poll();
if (p != null) {
try {
jedis.publish(tradeChannel, mapper.writeValueAsString(p));
} catch (JacksonException ignored) {}
}
}
} catch (Exception ignored) {}
}
if (subscriber != null) try { subscriber.unsubscribe(); } catch (Exception ignored) {}
if (provider != null) provider.close();
}
private record TradePacket(
String sourceServer,
String productId,
double amount,
long timestamp
) {}
}

==================================================
FILE: ecobridge-java\src\main\java\top\ellan\ecobridge\storage\ActivityCollector.java
==================================================

package top.ellan.ecobridge.storage;
import org.bukkit.Bukkit;
import org.bukkit.Statistic;
import org.bukkit.entity.Player;
import org.jetbrains.annotations.NotNull;
import top.ellan.ecobridge.EcoBridge;
import java.util.Map;
import java.util.UUID;
import java.util.concurrent.ConcurrentHashMap;
public final class ActivityCollector {
private static final Map<UUID, ActivitySnapshot> SNAPSHOT_CACHE = new ConcurrentHashMap<>();
public record ActivitySnapshot(long playTimeSeconds, double activityScore, int status) {}
public static void updateSnapshot(@NotNull Player player) {
if (!Bukkit.isPrimaryThread()) {
return;
}
long totalTicks = player.getStatistic(Statistic.PLAY_ONE_MINUTE);
long seconds = totalTicks / 20;
double score = Math.min(1.0, (double) seconds / 72000.0);
SNAPSHOT_CACHE.put(player.getUniqueId(), new ActivitySnapshot(seconds, score, 0));
}
public static double getScore(@NotNull UUID uuid) {
return getSafeSnapshot(uuid).activityScore();
}
@NotNull
public static ActivitySnapshot getSafeSnapshot(@NotNull UUID uuid) {
return SNAPSHOT_CACHE.getOrDefault(uuid, new ActivitySnapshot(0, 0.0, 1));
}
public static void removePlayer(@NotNull UUID uuid) {
SNAPSHOT_CACHE.remove(uuid);
}
public static void startHeartbeat(@NotNull EcoBridge plugin) {
Bukkit.getScheduler().runTaskTimer(plugin, () -> {
for (Player player : Bukkit.getOnlinePlayers()) {
updateSnapshot(player);
}
}, 100L, 6000L);
}
}

==================================================
FILE: ecobridge-java\src\main\java\top\ellan\ecobridge\storage\AsyncLogger.java
==================================================

package top.ellan.ecobridge.storage;
import top.ellan.ecobridge.EcoBridge;
import top.ellan.ecobridge.bridge.NativeBridge;
import top.ellan.ecobridge.util.LogUtil;
import java.util.ArrayList;
import java.util.List;
import java.util.UUID;
import java.util.concurrent.BlockingQueue;
import java.util.concurrent.LinkedBlockingQueue;
import java.util.concurrent.TimeUnit;
public final class AsyncLogger {
private static AsyncLogger instance;
private final BlockingQueue<LogEntry> queue = new LinkedBlockingQueue<>(50000);
private volatile boolean running = true;
private record LogEntry(UUID uuid, double delta, double balance, long timestamp, String meta) {}
private AsyncLogger(EcoBridge plugin) {
startNativeWorker();
}
public static void init(EcoBridge plugin) {
if (instance == null) {
instance = new AsyncLogger(plugin);
}
}
public static AsyncLogger getInstance() {
return instance;
}
public static void log(UUID uuid, double delta, double balance, long timestamp, String meta) {
if (instance == null || !instance.running) return;
LogEntry entry = new LogEntry(uuid, delta, balance, timestamp, meta);
if (!instance.queue.offer(entry)) {
LogUtil.warn("AsyncLogger 溢出！Rust 引擎产生背压，正在丢弃部分非核心流水。");
}
}
public static void log(UUID uuid, double delta, double balance, long timestamp) {
log(uuid, delta, balance, timestamp, "NORMAL");
}
private void startNativeWorker() {
Thread.ofVirtual().name("ecobridge-duckdb-worker").start(() -> {
List<LogEntry> batch = new ArrayList<>(1000);
LogUtil.info("AsyncLogger 虚拟线程已就绪，正在监听 Native 写入管线...");
while (running || !queue.isEmpty()) {
try {
LogEntry first = queue.poll(2, TimeUnit.SECONDS);
if (first != null) {
batch.add(first);
queue.drainTo(batch, 999);
pushBatchToNative(batch);
batch.clear();
}
} catch (InterruptedException e) {
Thread.currentThread().interrupt();
break;
} catch (Exception e) {
LogUtil.error("AsyncLogger 运行时发生异常", e);
}
}
LogUtil.info("AsyncLogger 已成功离线，Native 数据管线已安全切断。");
});
}
private void pushBatchToNative(List<LogEntry> entries) {
if (!NativeBridge.isLoaded()) return;
for (LogEntry entry : entries) {
NativeBridge.pushToDuckDB(
entry.timestamp(),
entry.uuid().toString(),
entry.delta(),
entry.balance(),
entry.meta()
);
}
}
public void shutdown() {
LogUtil.info("正在关闭异步记录器，正在将残留流水存入 DuckDB...");
this.running = false;
}
}

==================================================
FILE: ecobridge-java\src\main\java\top\ellan\ecobridge\util\ConfigValidator.java
==================================================

package top.ellan.ecobridge.util;
import org.bukkit.configuration.file.FileConfiguration;
import top.ellan.ecobridge.EcoBridge;
public class ConfigValidator {
public static boolean validate(EcoBridge plugin) {
FileConfiguration config = plugin.getConfig();
boolean healthy = true;
LogUtil.info("正在执行经济内核物理参数审计...");
healthy &= checkRange(config, "economy.macro.target-velocity", 0.001, 10.0, 0.05);
healthy &= checkRange(config, "economy.macro.capacity-per-user", 1.0, 1000000.0, 5000.0);
healthy &= checkRange(config, "economy.macro.heat-sensitivity", 0.01, 2.0, 0.5);
healthy &= checkRange(config, "economy.macro.panic-threshold", 1.0, 1000.0, 50.0);
healthy &= checkRange(config, "economy.pid.kp", 0.0, 5.0, 0.5);
healthy &= checkRange(config, "economy.pid.ki", 0.0, 1.0, 0.1);
healthy &= checkRange(config, "economy.pid.kd", 0.0, 2.0, 0.05);
healthy &= checkRange(config, "economy.pid.lambda", 0.0, 1.0, 0.01);
healthy &= checkRange(config, "economy.decay-rate", 0.0, 1.0, 0.05);
healthy &= checkRange(config, "economy.default-lambda", 0.00001, 0.1, 0.002);
healthy &= checkRange(config, "economy.tau", 0.1, 365.0, 7.0);
healthy &= checkRange(config, "economy.sell-ratio", 0.0, 1.0, 0.5);
healthy &= checkRange(config, "economy.audit-settings.base-tax-rate", 0.0, 1.0, 0.05);
healthy &= checkRange(config, "economy.audit-settings.luxury-tax-rate", 0.0, 1.0, 0.1);
healthy &= checkRange(config, "system.log-sample-rate", 0, 100, 100);
if (!healthy) {
LogUtil.warn("部分参数不合法，内核已自动重置为安全默认值。请检查并校准 config.yml。");
plugin.saveConfig();
} else {
LogUtil.info("物理参数审计通过，内核状态：健康。");
}
return true;
}
private static boolean checkRange(FileConfiguration config, String path, double min, double max, double def) {
if (!config.contains(path)) {
config.set(path, def);
return false;
}
double val = config.getDouble(path);
if (val < min || val > max) {
LogUtil.error("配置校验失败: [" + path + "] 的值 " + val + " 超出安全范围 [" + min + " - " + max + "]");
config.set(path, def);
return false;
}
return true;
}
private static boolean checkRange(FileConfiguration config, String path, int min, int max, int def) {
int val = config.getInt(path);
if (val < min || val > max) {
LogUtil.error("配置校验失败: [" + path + "] 的值 " + val + " 超出安全范围 [" + min + " - " + max + "]");
config.set(path, def);
return false;
}
return true;
}
}

==================================================
FILE: ecobridge-java\src\main\java\top\ellan\ecobridge\util\HolidayManager.java
==================================================

package top.ellan.ecobridge.util;
import com.google.gson.JsonParser;
import net.kyori.adventure.text.minimessage.MiniMessage;
import net.kyori.adventure.text.minimessage.tag.resolver.Placeholder;
import org.bukkit.Bukkit;
import top.ellan.ecobridge.EcoBridge;
import java.io.IOException;
import java.net.URI;
import java.net.http.HttpClient;
import java.net.http.HttpRequest;
import java.net.http.HttpResponse;
import java.nio.file.Files;
import java.nio.file.Path;
import java.time.*;
import java.time.format.DateTimeFormatter;
import java.util.Collections;
import java.util.HashSet;
import java.util.Set;
import java.util.concurrent.Executors;
import java.util.concurrent.ScheduledExecutorService;
import java.util.concurrent.TimeUnit;
import java.util.concurrent.atomic.AtomicReference;
public class HolidayManager {
private static final MiniMessage MM = MiniMessage.miniMessage();
private static final DateTimeFormatter DATE_KEY_FORMAT = DateTimeFormatter.ofPattern("MM-dd");
private static final AtomicReference<Set<String>> holidayCache =
new AtomicReference<>(Collections.emptySet());
private static double holidayMultiplier = 1.2;
private static ScheduledExecutorService scheduler;
private static Path cacheFile;
private static final HttpClient HTTP_CLIENT = HttpClient.newBuilder()
.followRedirects(HttpClient.Redirect.NORMAL)
.connectTimeout(Duration.ofSeconds(10))
.build();
public static void init() {
var config = EcoBridge.getInstance().getConfig();
holidayMultiplier = config.getDouble("economy.holiday-multiplier", 1.2);
cacheFile = EcoBridge.getInstance().getDataFolder().toPath().resolve("cache/holidays.json");
loadFromLocalCache();
startAutoRefreshTask();
}
private static void startAutoRefreshTask() {
if (scheduler != null && !scheduler.isShutdown()) return;
scheduler = Executors.newSingleThreadScheduledExecutor(r ->
Thread.ofVirtual().name("EcoBridge-Holiday-Worker").unstarted(r));
fetchHolidayData();
LocalDateTime now = LocalDateTime.now();
LocalDateTime nextMidnight = now.toLocalDate().plusDays(1).atStartOfDay().plusMinutes(5);
long initialDelaySeconds = Duration.between(now, nextMidnight).getSeconds();
sendConsole("<gray>[环境] 日历同步已对齐，下次完整对时将在 <white><delay></white> 秒后。",
Placeholder.unparsed("delay", String.valueOf(initialDelaySeconds)));
scheduler.scheduleAtFixedRate(HolidayManager::fetchHolidayData, initialDelaySeconds,
TimeUnit.DAYS.toSeconds(1), TimeUnit.SECONDS);
}
public static double getHolidayEpsilonFactor() {
return isTodayHoliday() ? holidayMultiplier : 1.0;
}
public static boolean isTodayHoliday() {
return isHoliday(System.currentTimeMillis());
}
public static boolean isHoliday(long timestamp) {
Set<String> currentCache = holidayCache.get();
if (currentCache.isEmpty()) return false;
String dateKey = LocalDate.ofInstant(Instant.ofEpochMilli(timestamp), ZoneId.systemDefault())
.format(DATE_KEY_FORMAT);
return currentCache.contains(dateKey);
}
private static void fetchHolidayData() {
int year = LocalDate.now().getYear();
String url = EcoBridge.getInstance().getConfig().getString(
"holiday-api.url-template",
"https:
).replace("{year}", String.valueOf(year));
HttpRequest request = HttpRequest.newBuilder()
.uri(URI.create(url))
.header("User-Agent", "EcoBridge-Core/0.6.7")
.GET()
.build();
HTTP_CLIENT.sendAsync(request, HttpResponse.BodyHandlers.ofString())
.thenAccept(res -> {
if (res.statusCode() == 200) {
parseAndCache(res.body());
saveToLocalCache(res.body());
}
})
.exceptionally(ex -> {
sendConsole("<red>[环境] 节假日网络同步异常，已回退至本地快照。");
return null;
});
}
private static void parseAndCache(String json) {
try {
var root = JsonParser.parseString(json).getAsJsonObject();
if (!root.has("holiday")) return;
var holidays = root.getAsJsonObject("holiday");
Set<String> newSet = new HashSet<>();
holidays.keySet().forEach(date -> {
var info = holidays.getAsJsonObject(date);
if (info.has("holiday") && info.get("holiday").getAsBoolean()) {
if (date.length() >= 10) newSet.add(date.substring(5, 10));
}
});
holidayCache.set(Collections.unmodifiableSet(newSet));
sendConsole("<green>[环境] 节假日数据库已对齐最新自然日。");
} catch (Exception e) {
sendConsole("<red>[环境] 数据格式异常: <white><error>", Placeholder.unparsed("error", e.getMessage()));
}
}
private static void saveToLocalCache(String json) {
try {
Files.createDirectories(cacheFile.getParent());
Files.writeString(cacheFile, json);
} catch (IOException ignored) {}
}
private static void loadFromLocalCache() {
if (!Files.exists(cacheFile)) return;
try {
parseAndCache(Files.readString(cacheFile));
} catch (IOException ignored) {}
}
public static void shutdown() {
if (scheduler != null) scheduler.shutdownNow();
}
private static void sendConsole(String msg, net.kyori.adventure.text.minimessage.tag.resolver.TagResolver... resolvers) {
Bukkit.getConsoleSender().sendMessage(MM.deserialize(msg, resolvers));
}
}

==================================================
FILE: ecobridge-java\src\main\java\top\ellan\ecobridge\util\InternalPlaceholder.java
==================================================

package top.ellan.ecobridge.util;
import cn.superiormc.ultimateshop.api.ShopHelper;
import cn.superiormc.ultimateshop.objects.buttons.ObjectItem;
import cn.superiormc.ultimateshop.objects.caches.ObjectUseTimesCache;
import net.kyori.adventure.text.minimessage.tag.resolver.Placeholder;
import net.kyori.adventure.text.minimessage.tag.resolver.TagResolver;
import org.bukkit.entity.Player;
import org.jetbrains.annotations.NotNull;
import org.jetbrains.annotations.Nullable;
import top.ellan.ecobridge.bridge.NativeBridge;
import top.ellan.ecobridge.collector.ActivityCollector;
import top.ellan.ecobridge.manager.EconomicStateManager;
import top.ellan.ecobridge.manager.EconomyManager;
import top.ellan.ecobridge.manager.PricingManager;
import java.lang.foreign.Arena;
import java.lang.foreign.MemorySegment;
import java.lang.foreign.ValueLayout;
public final class InternalPlaceholder {
public static final int PHYSICAL_HARD_CAP = 2000;
public static final int PHYSICAL_OPTIMAL_CAP = 500;
private InternalPlaceholder() {}
@NotNull
public static TagResolver getGlobalResolver() {
EconomyManager eco = EconomyManager.getInstance();
double currentKp = 0, currentKi = 0, currentKd = 0;
if (NativeBridge.isLoaded() && PricingManager.getInstance() != null) {
MemorySegment pidSeg = PricingManager.getInstance().getGlobalPidState();
if (pidSeg != null && pidSeg.address() != 0) {
currentKp = pidSeg.get(ValueLayout.JAVA_DOUBLE, 0);
currentKi = pidSeg.get(ValueLayout.JAVA_DOUBLE, 8);
currentKd = pidSeg.get(ValueLayout.JAVA_DOUBLE, 16);
}
}
return TagResolver.resolver(
Placeholder.unparsed("inflation", String.format("%.2f%%", eco.getInflationRate() * 100)),
Placeholder.unparsed("stability", String.format("%.2f", eco.getStabilityFactor())),
Placeholder.unparsed("market_heat", String.format("%.1f", eco.getMarketHeat())),
Placeholder.unparsed("eco_saturation", String.format("%.2f%%", eco.getEcoSaturation() * 100)),
Placeholder.unparsed("pid_kp", String.format("%.3f", currentKp)),
Placeholder.unparsed("pid_ki", String.format("%.3f", currentKi)),
Placeholder.unparsed("pid_kd", String.format("%.3f", currentKd)),
Placeholder.unparsed("holiday_status", HolidayManager.isTodayHoliday() ? "是" : "否"),
Placeholder.unparsed("holiday_mult", String.format("%.1fx", HolidayManager.getHolidayEpsilonFactor()))
);
}
@NotNull
public static TagResolver getSystemResolver() {
String status = NativeBridge.isLoaded() ? "已就绪" : "未加载";
long totalLogs = 0;
long droppedLogs = 0;
if (NativeBridge.isLoaded()) {
try (Arena arena = Arena.ofConfined()) {
MemorySegment totalPtr = arena.allocate(ValueLayout.JAVA_LONG);
MemorySegment droppedPtr = arena.allocate(ValueLayout.JAVA_LONG);
NativeBridge.getHealthStats(totalPtr, droppedPtr);
totalLogs = totalPtr.get(ValueLayout.JAVA_LONG, 0L);
droppedLogs = droppedPtr.get(ValueLayout.JAVA_LONG, 0L);
} catch (Throwable ignored) {}
}
return TagResolver.resolver(
Placeholder.unparsed("native_status", status),
Placeholder.unparsed("native_logs", String.valueOf(totalLogs)),
Placeholder.unparsed("native_dropped", String.valueOf(droppedLogs))
);
}
@NotNull
public static TagResolver getPlayerResolver(@Nullable Player player) {
if (player == null) return TagResolver.empty();
var snapshot = ActivityCollector.capture(player, 48.0);
String tag = (snapshot.isNewbie() == 1) ? "新手" : "资深";
return TagResolver.resolver(
getGlobalResolver(),
Placeholder.unparsed("player_hours", String.format("%.1f", snapshot.hours())),
Placeholder.unparsed("newbie_tag", tag)
);
}
@NotNull
public static TagResolver getMarketResolver(@NotNull String productId) {
var phase = EconomicStateManager.getInstance().analyzeMarketAndNotify(productId, 0.0);
String color = switch (phase) {
case STABLE -> "<green>";
case SATURATED -> "<yellow>";
case EMERGENCY -> "<red>";
case HEALING -> "<aqua>";
};
return TagResolver.resolver(
Placeholder.unparsed("market_phase", phase.name()),
Placeholder.parsed("market_color", color)
);
}
@NotNull
public static TagResolver getQuotaResolver(@NotNull Player player, @NotNull ObjectItem item) {
QuotaData data = calculateQuota(player, item);
return TagResolver.resolver(
Placeholder.unparsed("quota_used", String.valueOf(data.used())),
Placeholder.unparsed("quota_limit", String.valueOf(data.hardLimit())),
Placeholder.unparsed("quota_optimal", String.valueOf(data.optimalLimit())),
Placeholder.unparsed("quota_remaining", String.valueOf(data.remaining())),
Placeholder.unparsed("quota_percent", String.format("%.1f%%", data.percent()))
);
}
public record QuotaData(int used, int hardLimit, int optimalLimit, int remaining, double percent) {}
public static QuotaData calculateQuota(@NotNull Player player, @NotNull ObjectItem item) {
ObjectUseTimesCache cache = ShopHelper.getPlayerUseTimesCache(item, player);
int used = (cache != null) ? cache.getSellUseTimes() : 0;
int hardLimit = PHYSICAL_HARD_CAP;
int optimalLimit = PHYSICAL_OPTIMAL_CAP;
int remaining = Math.max(0, hardLimit - used);
double percent = ((double) used / hardLimit) * 100.0;
if (percent > 100.0) percent = 100.0;
return new QuotaData(used, hardLimit, optimalLimit, remaining, percent);
}
}

==================================================
FILE: ecobridge-java\src\main\java\top\ellan\ecobridge\util\LogUtil.java
==================================================

package top.ellan.ecobridge.util;
import net.kyori.adventure.text.minimessage.MiniMessage;
import net.kyori.adventure.text.minimessage.tag.resolver.Placeholder;
import net.kyori.adventure.text.minimessage.tag.resolver.TagResolver;
import org.bukkit.Bukkit;
import top.ellan.ecobridge.EcoBridge;
import java.util.Map;
import java.util.concurrent.ConcurrentHashMap;
import java.util.concurrent.atomic.AtomicLong;
public final class LogUtil {
private static final MiniMessage MM = MiniMessage.miniMessage();
private static final AtomicLong TRANSACTION_COUNTER = new AtomicLong(0);
private static final Map<String, Long> RATE_LIMIT_CACHE = new ConcurrentHashMap<>();
private static final long LOG_COOLDOWN_MS = 5 * 60 * 1000;
private static volatile boolean debugEnabled = false;
private static volatile int sampleRate = 100;
private LogUtil() {}
public static void init() {
var config = EcoBridge.getInstance().getConfig();
debugEnabled = config.getBoolean("system.debug", false);
sampleRate = Math.max(1, config.getInt("system.log-sample-rate", 100));
RATE_LIMIT_CACHE.clear();
if (debugEnabled) {
info("<gradient:aqua:blue>系统调试模式已激活</gradient> <dark_gray>| <gray>采样率: <white>1/<rate>",
Placeholder.unparsed("rate", String.valueOf(sampleRate)));
}
}
public static boolean isDebugEnabled() {
return debugEnabled;
}
public static void info(String message, TagResolver... resolvers) {
sendConsole("<blue>ℹ</blue> <gray>" + message, resolvers);
}
public static void debug(String message) {
if (debugEnabled) {
sendConsole("<dark_gray>[DEBUG]</dark_gray> <gray>" + message);
}
}
public static void warn(String message) {
sendConsole("<yellow>⚠</yellow> <white>" + message);
}
public static void warnOnce(String key, String message) {
if (shouldLog(key)) {
sendConsole("<yellow>⚠</yellow> <white>" + message + " <dark_gray>(已折叠同类警告)</dark_gray>");
}
}
public static void errorOnce(String key, String message) {
if (shouldLog(key)) {
sendConsole("<red>✘</red> <white>" + message + " <dark_gray>(已折叠同类错误)</dark_gray>");
}
}
private static boolean shouldLog(String key) {
long now = System.currentTimeMillis();
Long last = RATE_LIMIT_CACHE.get(key);
if (last == null || (now - last) > LOG_COOLDOWN_MS) {
RATE_LIMIT_CACHE.put(key, now);
return true;
}
return false;
}
public static void severe(String message) {
sendConsole("<red>✘</red> <bold><red>致命故障: </red></bold><white>" + message);
}
public static void logTransactionSampled(String message, TagResolver... resolvers) {
if (!debugEnabled) return;
long count = TRANSACTION_COUNTER.incrementAndGet();
if (count % sampleRate == 0) {
EcoBridge.getInstance().getVirtualExecutor().execute(() -> {
TagResolver combined = TagResolver.resolver(
TagResolver.resolver(resolvers),
Placeholder.unparsed("count", String.valueOf(count))
);
sendConsole("<blue>⚖</blue> <gray>" + message + " <dark_gray>(#<count>)", combined);
});
}
}
public static void error(String message) {
error(message, null);
}
public static void error(String message, Throwable e) {
EcoBridge.getInstance().getVirtualExecutor().execute(() -> {
sendConsole("<red>╔══════════════ EcoBridge 异常报告 ══════════════");
sendConsole("<red>║ <white>描述: <msg>", Placeholder.unparsed("msg", message));
if (e != null) {
sendConsole("<red>║ <white>类型: <yellow><type>", Placeholder.unparsed("type", e.getClass().getSimpleName()));
sendConsole("<red>║ <white>原因: <gray><reason>", Placeholder.unparsed("reason", String.valueOf(e.getMessage())));
sendConsole("<red>╚════════════════════════════════════════════════");
EcoBridge.getInstance().getLogger().severe("--- 详细堆栈追踪 ---");
e.printStackTrace();
} else {
sendConsole("<red>╚════════════════════════════════════════════════");
}
});
}
private static void sendConsole(String msg, TagResolver... resolvers) {
Bukkit.getConsoleSender().sendMessage(MM.deserialize(msg, resolvers));
}
}

==================================================
FILE: ecobridge-java\src\main\java\top\ellan\ecobridge\util\PriceOracle.java
==================================================

package top.ellan.ecobridge.util;
import cn.superiormc.ultimateshop.objects.buttons.ObjectItem;
import cn.superiormc.ultimateshop.objects.items.ThingType;
import cn.superiormc.ultimateshop.objects.items.prices.ObjectPrices;
import cn.superiormc.ultimateshop.objects.items.prices.ObjectSinglePrice;
import net.kyori.adventure.text.minimessage.tag.resolver.Placeholder;
import top.ellan.ecobridge.bridge.NativeBridge;
import org.bukkit.configuration.ConfigurationSection;
import org.jetbrains.annotations.NotNull;
import java.math.BigDecimal;
import java.util.Collection;
import java.util.Map;
import java.util.Optional;
public final class PriceOracle {
private static final double MIN_SAFE_P0 = 0.01;
private PriceOracle() {}
public static boolean isValidEconomyItem(ObjectItem item) {
if (item == null || item.empty) return false;
ObjectPrices buyPrice = item.getBuyPrice();
if (buyPrice == null || buyPrice.empty) return false;
Collection<ObjectSinglePrice> prices = buyPrice.singlePrices;
return prices != null && prices.stream()
.anyMatch(sp -> sp.type == ThingType.HOOK_ECONOMY && isVaultHook(sp));
}
private static boolean isVaultHook(ObjectSinglePrice sp) {
ConfigurationSection section = sp.singleSection;
if (section == null) return false;
String economyPlugin = section.getString("economy-plugin");
return "Vault".equalsIgnoreCase(economyPlugin);
}
public static double getOriginalBasePrice(@NotNull ObjectItem item, boolean isBuy) {
String primaryPath = isBuy ? "buy-prices" : "sell-prices";
String secondaryPath = "prices";
ConfigurationSection config = item.getItemConfig();
if (config != null) {
Optional<Double> yamlPrice = tryExtractFromPaths(config, primaryPath, secondaryPath);
if (yamlPrice.isPresent()) {
return Math.max(MIN_SAFE_P0, yamlPrice.get());
}
}
return fetchStaticPriceFromApi(item, isBuy);
}
public static double calculateTierPrice(double basePrice, double quantity, boolean isSell) {
if (!NativeBridge.isLoaded()) {
return basePrice;
}
return NativeBridge.computeTierPrice(basePrice, quantity, isSell);
}
private static Optional<Double> tryExtractFromPaths(ConfigurationSection root, String... paths) {
for (String path : paths) {
Object section = root.get(path);
if (section != null) {
var result = deepSearchAmount(section);
if (result.isPresent()) return result;
}
}
return Optional.empty();
}
private static Optional<Double> deepSearchAmount(Object obj) {
return switch (obj) {
case ConfigurationSection sec when sec.contains("amount") ->
Optional.of(sec.getDouble("amount"));
case ConfigurationSection sec -> sec.getKeys(false).stream()
.map(sec::get)
.map(PriceOracle::deepSearchAmount)
.flatMap(Optional::stream)
.findFirst();
case Map<?, ?> map when map.get("amount") instanceof Number n ->
Optional.of(n.doubleValue());
case Map<?, ?> map -> map.values().stream()
.map(PriceOracle::deepSearchAmount)
.flatMap(Optional::stream)
.findFirst();
case Number n -> Optional.of(n.doubleValue());
case null, default -> Optional.empty();
};
}
private static double fetchStaticPriceFromApi(ObjectItem item, boolean isBuy) {
try {
ObjectPrices prices = isBuy ? item.getBuyPrice() : item.getSellPrice();
if (prices == null || prices.empty) return MIN_SAFE_P0;
Map<?, BigDecimal> resultMap = prices.getAmount(null, 0, 1);
if (resultMap == null || resultMap.isEmpty()) return MIN_SAFE_P0;
boolean isAnyMode = prices.getMode().name().contains("ANY");
BigDecimal calculatedPrice = isAnyMode ?
resultMap.values().stream()
.filter(val -> val.compareTo(BigDecimal.ZERO) > 0)
.findFirst()
.orElse(BigDecimal.ZERO)
:
resultMap.values().stream()
.filter(val -> val.compareTo(BigDecimal.ZERO) > 0)
.reduce(BigDecimal.ZERO, BigDecimal::add);
return Math.max(MIN_SAFE_P0, calculatedPrice.doubleValue());
} catch (Exception e) {
logOracleWarning(item, "API 提取异常 (可能存在变量依赖): " + e.getMessage());
return MIN_SAFE_P0;
}
}
private static void logOracleWarning(ObjectItem item, String reason) {
LogUtil.logTransactionSampled(
"<yellow>[预言机]</yellow> <gray>物品 <white><id></white> 基准价提取降级。原因: <white><reason></white>",
Placeholder.unparsed("id", item.getProduct()),
Placeholder.unparsed("reason", reason)
);
}
}

==================================================
FILE: ecobridge-java\src\main\java\top\ellan\ecobridge\util\TimeMonitor.java
==================================================

package top.ellan.ecobridge.util;
import cn.superiormc.ultimateshop.api.ShopHelper;
import cn.superiormc.ultimateshop.objects.caches.ObjectUseTimesCache;
import cn.superiormc.ultimateshop.objects.buttons.ObjectItem;
import net.kyori.adventure.text.minimessage.tag.resolver.Placeholder;
import org.bukkit.Bukkit;
import org.bukkit.entity.Player;
import org.jetbrains.annotations.NotNull;
import top.ellan.ecobridge.EcoBridge;
public final class TimeMonitor {
private TimeMonitor() {}
public static void checkAndResetQuota(@NotNull Player player, @NotNull ObjectItem item) {
Bukkit.getScheduler().runTask(EcoBridge.getInstance(), () -> {
ObjectUseTimesCache cache = ShopHelper.getPlayerUseTimesCache(item, player);
if (cache == null) return;
cache.refreshSellTimes();
if (LogUtil.isDebugEnabled()) {
LogUtil.logTransactionSampled(
"<gray>[限额] 触发玩家 <white><p></white> 的配额状态同步自检。",
Placeholder.unparsed("p", player.getName())
);
}
});
}
public static void forceReset(@NotNull Player player, @NotNull ObjectItem item) {
Bukkit.getScheduler().runTask(EcoBridge.getInstance(), () -> {
ObjectUseTimesCache cache = ShopHelper.getPlayerUseTimesCache(item, player);
if (cache == null) return;
cache.setSellUseTimes(0, false, true);
player.sendMessage(EcoBridge.getMiniMessage().deserialize(
"<green>⚖</green> <gray>您的商品 <white><id></white> 交易配额已被重置！",
Placeholder.unparsed("id", item.getProduct())
));
LogUtil.info("管理员/系统 已强制重置玩家 <p> 的商品 <id> 配额",
Placeholder.unparsed("p", player.getName()),
Placeholder.unparsed("id", item.getProduct()));
});
}
}

==================================================
FILE: ecobridge-rust\build.rs
==================================================

use std::env;
use std::path::PathBuf;
fn main() {
let crate_dir = env::var("CARGO_MANIFEST_DIR").unwrap();
let output_file = PathBuf::from(&crate_dir).join("ecobridge_rust.h");
let mut config = cbindgen::Config::default();
config.language = cbindgen::Language::C;
config.style = cbindgen::Style::Type;
config.header = Some(String::from(
"\n\
\n\
"
));
config.include_guard = Some(String::from("ECOBRIDGE_RUST_H"));
config.sys_includes = vec![
String::from("stdint.h"),
String::from("stdbool.h"),
];
config.no_includes = true;
config.parse.parse_deps = false;
config.parse.clean = true;
config.export.prefix = None;
config.structure.rename_fields = cbindgen::RenameRule::None;
config.enumeration.rename_variants = cbindgen::RenameRule::ScreamingSnakeCase;
config.documentation = true;
config.documentation_style = cbindgen::DocumentationStyle::C;
cbindgen::Builder::new()
.with_crate(&crate_dir)
.with_config(config)
.generate()
.expect("Critical Error: Unable to generate C bindings via cbindgen")
.write_to_file(&output_file);
println!("cargo:rerun-if-changed=src/");
println!("cargo:rerun-if-changed=Cargo.toml");
println!("cargo:rerun-if-changed=build.rs");
configure_platform_linker();
}
fn configure_platform_linker() {
let target_os = env::var("CARGO_CFG_TARGET_OS").unwrap_or_default();
match target_os.as_str() {
"windows" => {
println!("cargo:rustc-link-lib=Rstrtmgr");
}
"macos" => {
println!("cargo:rustc-link-arg=-Wl,-install_name,@rpath/libecobridge_rust.dylib");
}
"linux" => {
println!("cargo:rustc-link-arg=-Wl,-rpath,$ORIGIN");
}
_ => {}
}
}

==================================================
FILE: ecobridge-rust\Cargo.toml
==================================================

[package]
name = "ecobridge_rust"
version = "0.9.1"
edition = "2021"
authors = ["Ellan"]
description = "EcoBridge Economy Core - Macro Adaptive & Parallel Engine"
[lib]
crate-type = ["cdylib"]
[dependencies]
libc = "0.2.180"
duckdb = { version = "1.4.3", features = ["bundled", "chrono"] }
crossbeam-channel = "0.5.15"
rayon = "1.11.0"
chrono = { version = "0.4.43", features = ["std"] }
lazy_static = "1.5"
[build-dependencies]
cbindgen = "0.29.2"
[features]
default = ["parallel"]
parallel = []
[profile.release]
opt-level = 3
lto = "fat"
codegen-units = 1
strip = "symbols"
panic = "unwind"

==================================================
FILE: ecobridge-rust\cbindgen.toml
==================================================

language = "C"
header = "/* Generated by cbindgen. Do not edit manually. */"
style = "type"
[export]
include = [
"PidState",
"TradeContext",
"MarketConfig",
"TransferResult",
"TransferContext",
"RegulatorConfig"
]
[parse]
parse_deps = true
clean = true

==================================================
FILE: ecobridge-rust\src\lib.rs
==================================================

use libc::{c_char, c_double, c_int, c_longlong, c_ulonglong};
use std::ffi::CStr;
use std::panic::{self, AssertUnwindSafe};
use std::sync::atomic::{AtomicU64, Ordering};
use std::ptr;
pub mod models;
pub mod economy {
pub mod pricing;
pub mod summation;
pub mod environment;
pub mod control;
pub mod macro_eco;
}
pub mod security;
pub mod storage;
use crate::models::*;
static PANIC_COUNTER: AtomicU64 = AtomicU64::new(0);
macro_rules! ffi_guard {
($fallback:expr, $body:block) => {
match panic::catch_unwind(AssertUnwindSafe(|| $body)) {
Ok(result) => result,
Err(e) => {
let count = PANIC_COUNTER.fetch_add(1, Ordering::Relaxed);
let msg = if let Some(s) = e.downcast_ref::<&str>() {
*s
} else if let Some(s) = e.downcast_ref::<String>() {
s.as_str()
} else {
"Unknown panic origin"
};
eprintln!("[EcoBridge-Native] CRITICAL PANIC detected: {}", msg);
if count > 100 {
eprintln!("CRITICAL: Native panic count exceeded threshold (100). System instability imminent.");
}
$fallback
}
}
};
}
#[no_mangle]
pub extern "C" fn ecobridge_abi_version() -> u32 {
0x0009_0000
}
#[no_mangle]
pub extern "C" fn ecobridge_version() -> *const c_char {
ffi_guard!(ptr::null(), {
static VERSION: &[u8] = b"EcoBridge Native Core v0.9.1-Macro (SIMD & Adaptive PID Enabled)\0";
VERSION.as_ptr() as *const c_char
})
}
#[no_mangle]
pub extern "C" fn ecobridge_init_db(path_ptr: *const c_char) -> c_int {
ffi_guard!(-99, {
if path_ptr.is_null() {
-1
} else {
let path_result = unsafe { CStr::from_ptr(path_ptr).to_str() };
match path_result {
Ok(path_str) => {
let res = storage::init_economy_db(path_str);
if res == 0 {
economy::summation::hydrate_hot_store();
}
res
},
Err(_) => -2,
}
}
})
}
#[no_mangle]
pub unsafe extern "C" fn ecobridge_log_to_duckdb(
ts: c_longlong,
uuid_ptr: *const c_char,
trade_amount: c_double,
balance: c_double,
meta_ptr: *const c_char,
) {
ffi_guard!((), {
if !uuid_ptr.is_null() && !meta_ptr.is_null() {
let uuid = CStr::from_ptr(uuid_ptr).to_string_lossy().into_owned();
let meta = CStr::from_ptr(meta_ptr).to_string_lossy().into_owned();
economy::summation::append_trade_to_memory(ts, trade_amount.abs());
storage::log_economy_event(ts, uuid, trade_amount, balance, meta);
}
})
}
#[no_mangle]
pub unsafe extern "C" fn ecobridge_get_health_stats(
out_total: *mut c_ulonglong,
out_dropped: *mut c_ulonglong,
) {
ffi_guard!((), {
if let Some(total) = out_total.as_mut() {
*total = storage::get_total_logs();
}
if let Some(dropped) = out_dropped.as_mut() {
*dropped = storage::get_dropped_logs();
}
})
}
#[no_mangle]
pub unsafe extern "C" fn ecobridge_query_neff_vectorized(
current_ts: c_longlong,
tau: c_double,
) -> c_double {
ffi_guard!(0.0, {
economy::summation::query_neff_internal(current_ts, tau)
})
}
#[no_mangle]
pub unsafe extern "C" fn ecobridge_compute_batch_prices(
count: u64,
neff: f64,
ctx_ptr: *const TradeContext,
cfg_ptr: *const MarketConfig,
hist_avgs_ptr: *const f64,
lambdas_ptr: *const f64,
results_ptr: *mut f64,
) {
ffi_guard!((), {
economy::pricing::compute_batch_prices_internal(
count as usize,
neff,
ctx_ptr,
cfg_ptr,
hist_avgs_ptr,
lambdas_ptr,
results_ptr
);
})
}
#[no_mangle]
pub extern "C" fn ecobridge_compute_price_final(
base: c_double,
n_eff: c_double,
lambda: c_double,
epsilon: c_double,
) -> c_double {
economy::pricing::compute_price_final_internal(base, n_eff, lambda, epsilon)
}
#[no_mangle]
pub extern "C" fn ecobridge_compute_price_humane(
base: c_double,
n_eff: c_double,
trade_amount: c_double,
lambda: c_double,
epsilon: c_double,
) -> c_double {
economy::pricing::compute_price_humane_internal(base, n_eff, trade_amount, lambda, epsilon)
}
#[no_mangle]
pub extern "C" fn ecobridge_compute_price_bounded(
base: c_double,
n_eff: c_double,
amt: c_double,
lambda: c_double,
eps: c_double,
hist_avg: c_double,
) -> c_double {
economy::pricing::compute_price_bounded_internal(base, n_eff, amt, lambda, eps, hist_avg)
}
#[no_mangle]
pub extern "C" fn ecobridge_compute_tier_price(base: c_double, qty: c_double, is_sell: bool) -> c_double {
ffi_guard!(base, {
economy::pricing::compute_tier_price_internal(base, qty, is_sell)
})
}
#[no_mangle]
pub unsafe extern "C" fn ecobridge_calculate_epsilon(
ctx_ptr: *const TradeContext,
cfg_ptr: *const MarketConfig,
) -> c_double {
ffi_guard!(1.0, {
match (ctx_ptr.as_ref(), cfg_ptr.as_ref()) {
(Some(ctx), Some(cfg)) => {
economy::environment::calculate_epsilon_internal(ctx, cfg)
},
_ => 1.0
}
})
}
#[no_mangle]
pub unsafe extern "C" fn ecobridge_compute_pid_adjustment(
pid_ptr: *mut PidState,
target: c_double,
current: c_double,
dt: c_double,
inflation: c_double,
market_heat: c_double,
) -> c_double {
ffi_guard!(0.0, {
match pid_ptr.as_mut() {
Some(pid) => {
economy::control::compute_pid_adjustment_internal(pid, target, current, dt, inflation, market_heat)
},
None => 0.0,
}
})
}
#[no_mangle]
pub unsafe extern "C" fn ecobridge_reset_pid_state(pid_ptr: *mut PidState) {
ffi_guard!((), {
if let Some(pid) = pid_ptr.as_mut() {
*pid = PidState::default();
}
})
}
#[no_mangle]
pub extern "C" fn ecobridge_calc_inflation(current_heat: c_double, m1: c_double) -> c_double {
ffi_guard!(0.0, {
economy::macro_eco::calculate_inflation_rate(current_heat, m1)
})
}
#[no_mangle]
pub extern "C" fn ecobridge_calc_stability(last_ts: c_longlong, curr_ts: c_longlong) -> c_double {
ffi_guard!(1.0, {
economy::macro_eco::calculate_stability(last_ts, curr_ts, 900000.0)
})
}
#[no_mangle]
pub extern "C" fn ecobridge_calc_decay(heat: c_double, rate: c_double) -> c_double {
ffi_guard!(0.0, {
economy::macro_eco::calculate_decay(heat, rate, 48.0)
})
}
#[no_mangle]
pub unsafe extern "C" fn ecobridge_compute_transfer_check(
out_result: *mut TransferResult,
ctx_ptr: *const TransferContext,
cfg_ptr: *const RegulatorConfig,
) {
if out_result.is_null() {
return;
}
let default_result = TransferResult::error(-999);
let result = ffi_guard!(default_result, {
match (ctx_ptr.as_ref(), cfg_ptr.as_ref()) {
(Some(ctx), Some(cfg)) => {
security::regulator::compute_transfer_check_internal(ctx, cfg)
},
_ => TransferResult::error(671),
}
});
unsafe { ptr::write(out_result, result) };
}
#[no_mangle]
pub extern "C" fn ecobridge_shutdown_db() -> c_int {
storage::shutdown_db_internal()
}

==================================================
FILE: ecobridge-rust\src\models.rs
==================================================

use libc::{c_double, c_int, c_longlong};
#[repr(C)]
#[derive(Debug, Clone, Copy)]
pub struct PidState {
pub kp: c_double,
pub ki: c_double,
pub kd: c_double,
pub lambda: c_double,
pub integral: c_double,
pub prev_pv: c_double,
pub filtered_d: c_double,
pub integration_limit: c_double,
pub is_saturated: c_int,
pub _padding: c_int,
}
impl Default for PidState {
fn default() -> Self {
Self {
kp: 0.5, ki: 0.1, kd: 0.05, lambda: 0.01,
integral: 0.0, prev_pv: 0.0, filtered_d: 0.0,
integration_limit: 30.0, is_saturated: 0,
_padding: 0,
}
}
}
#[repr(C)]
#[derive(Debug, Clone, Copy, Default)]
pub struct HistoryRecord {
pub timestamp: c_longlong,
pub amount: c_double,
}
#[repr(C)]
#[derive(Debug, Clone, Copy, Default)]
pub struct TradeContext {
pub base_price: c_double,
pub current_amount: c_double,
pub inflation_rate: c_double,
pub current_timestamp: c_longlong,
pub play_time_seconds: c_longlong,
pub timezone_offset: c_int,
pub newbie_mask: c_int,
pub market_heat: c_double,
pub eco_saturation: c_double,
}
#[repr(C)]
#[derive(Debug, Clone, Copy, Default)]
pub struct TransferContext {
pub amount: c_double,
pub sender_balance: c_double,
pub receiver_balance: c_double,
pub inflation_rate: c_double,
pub newbie_limit: c_double,
pub sender_play_time: c_longlong,
pub receiver_play_time: c_longlong,
pub sender_activity_score: c_double,
pub sender_velocity: c_int,
pub _padding: c_int,
}
#[repr(C)]
#[derive(Debug, Clone, Copy)]
pub struct MarketConfig {
pub base_lambda: c_double,
pub volatility_factor: c_double,
pub seasonal_amplitude: c_double,
pub weekend_multiplier: c_double,
pub newbie_protection_rate: c_double,
pub seasonal_weight: c_double,
pub weekend_weight: c_double,
pub newbie_weight: c_double,
pub inflation_weight: c_double,
}
impl Default for MarketConfig {
fn default() -> Self {
Self {
base_lambda: 0.1, volatility_factor: 1.0,
seasonal_amplitude: 0.15, weekend_multiplier: 1.2,
newbie_protection_rate: 0.2,
seasonal_weight: 0.25, weekend_weight: 0.25,
newbie_weight: 0.25, inflation_weight: 0.25,
}
}
}
#[repr(C)]
#[derive(Debug, Clone, Copy)]
pub struct RegulatorConfig {
pub base_tax_rate: c_double,
pub luxury_threshold: c_double,
pub luxury_tax_rate: c_double,
pub wealth_gap_tax_rate: c_double,
pub poor_threshold: c_double,
pub rich_threshold: c_double,
pub newbie_receive_limit: c_double,
pub warning_ratio: c_double,
pub warning_min_amount: c_double,
pub newbie_hours: c_double,
pub veteran_hours: c_double,
pub velocity_threshold: c_double,
}
impl Default for RegulatorConfig {
fn default() -> Self {
Self {
base_tax_rate: 0.05, luxury_threshold: 100_000.0,
luxury_tax_rate: 0.10, wealth_gap_tax_rate: 0.20,
poor_threshold: 10_000.0, rich_threshold: 1_000_000.0,
newbie_receive_limit: 50_000.0, warning_ratio: 0.9,
warning_min_amount: 50_000.0, newbie_hours: 10.0, veteran_hours: 100.0,
velocity_threshold: 20.0,
}
}
}
#[repr(C)]
#[derive(Debug, Clone, Copy, Default)]
pub struct TransferResult {
pub final_tax: c_double,
pub is_blocked: c_int,
pub warning_code: c_int,
}
impl TransferResult {
pub fn error(code: i32) -> Self {
Self { final_tax: 0.0, is_blocked: 1, warning_code: code }
}
}
#[cfg(test)]
mod tests {
use super::*;
use std::mem;
#[test]
fn verify_ssot_alignment() {
assert_eq!(mem::size_of::<PidState>(), 72);
assert_eq!(mem::size_of::<TradeContext>(), 64);
assert_eq!(mem::size_of::<TransferContext>(), 72);
assert_eq!(mem::size_of::<MarketConfig>(), 72);
assert_eq!(mem::size_of::<RegulatorConfig>(), 96);
assert_eq!(mem::size_of::<TransferResult>(), 16);
assert_eq!(mem::offset_of!(TradeContext, market_heat), 48);
assert_eq!(mem::offset_of!(TradeContext, eco_saturation), 56);
assert_eq!(mem::offset_of!(TransferContext, sender_activity_score), 56);
assert_eq!(mem::offset_of!(RegulatorConfig, velocity_threshold), 88);
}
}

==================================================
FILE: ecobridge-rust\src\economy\control.rs
==================================================

use crate::models::PidState;
pub const DEFAULT_INTEGRATION_LIMIT: f64 = 30.0;
pub const MAX_SAFE_DT: f64 = 1.0;
pub const MIN_TIME_STEP: f64 = 1e-6;
pub const OUTPUT_MIN_CLAMP: f64 = 0.5;
pub const OUTPUT_MAX_CLAMP: f64 = 5.0;
pub const OUTPUT_BASELINE: f64 = 1.0;
pub const INTEGRAL_DECAY: f64 = 0.99999;
pub const BACK_CALC_GAIN: f64 = 0.2;
pub const DERIVATIVE_FILTER_ALPHA: f64 = 0.3;
pub const PANIC_THRESHOLD: f64 = 50.0;
pub const PANIC_DAMPING: f64 = 1.8;
pub const HEAT_SENSITIVITY: f64 = 0.5;
#[inline]
fn sigmoid(x: f64) -> f64 {
1.0 / (1.0 + (-x).exp())
}
pub fn compute_adaptive_gain(cfg: &PidState, heat: f64) -> (f64, f64) {
let sensitivity = (heat * HEAT_SENSITIVITY).tanh();
let adaptive_kp = cfg.kp * (1.0 + sensitivity);
let adaptive_ki = cfg.ki * (1.0 - sensitivity * 0.5);
(adaptive_kp, adaptive_ki)
}
pub fn compute_pid_adjustment_internal(
pid: &mut PidState,
target_vel: f64,
current_vel: f64,
dt: f64,
inflation: f64,
market_heat: f64,
) -> f64 {
if !target_vel.is_finite() || !current_vel.is_finite()
|| !dt.is_finite() || dt < 0.0
|| !inflation.is_finite() || !market_heat.is_finite() {
return OUTPUT_BASELINE;
}
let error = target_vel - current_vel;
let dt_safe = dt.clamp(0.0, MAX_SAFE_DT);
let (base_kp, base_ki) = compute_adaptive_gain(pid, market_heat);
let schedule_gamma = 1.0 + sigmoid((inflation - 0.05) * 20.0);
let active_kp = base_kp * schedule_gamma;
let active_ki = base_ki * schedule_gamma;
let combined_leakage = (1.0 - pid.lambda.clamp(0.0, 1.0)) * INTEGRAL_DECAY;
if pid.is_saturated != 0 {
let back_calc = error * BACK_CALC_GAIN;
pid.integral = pid.integral.mul_add(combined_leakage, back_calc * dt_safe);
} else {
pid.integral = pid.integral.mul_add(combined_leakage, error * dt_safe);
}
let limit = if pid.integration_limit > 0.0 { pid.integration_limit } else { DEFAULT_INTEGRATION_LIMIT };
pid.integral = pid.integral.clamp(-limit, limit);
let delta_pv = current_vel - pid.prev_pv;
let raw_derivative = if dt_safe > MIN_TIME_STEP { delta_pv / dt_safe } else { 0.0 };
pid.filtered_d = DERIVATIVE_FILTER_ALPHA.mul_add(
raw_derivative,
(1.0 - DERIVATIVE_FILTER_ALPHA) * pid.filtered_d
);
pid.prev_pv = current_vel;
let d_multiplier = if pid.filtered_d.abs() > PANIC_THRESHOLD {
PANIC_DAMPING
} else {
1.0
};
let p_term = active_kp * error;
let i_term = active_ki * pid.integral;
let d_term = pid.kd * pid.filtered_d * d_multiplier;
let raw_output = OUTPUT_BASELINE + p_term + i_term - d_term;
let final_output = raw_output.clamp(OUTPUT_MIN_CLAMP, OUTPUT_MAX_CLAMP);
pid.is_saturated = if (raw_output - final_output).abs() > 1e-6 { 1 } else { 0 };
if final_output.is_finite() { final_output } else { OUTPUT_BASELINE }
}
pub fn validate_pid_params(pid: &PidState) -> bool {
pid.kp.is_finite() && pid.kp >= 0.0
&& pid.ki.is_finite() && pid.ki >= 0.0
&& pid.kd.is_finite() && pid.kd >= 0.0
&& pid.lambda.is_finite() && (0.0..=1.0).contains(&pid.lambda)
}
#[cfg(test)]
mod tests {
use super::*;
#[test]
fn test_macro_adaptive_gains() {
let pid = PidState::default();
let (kp_low, _) = compute_adaptive_gain(&pid, 0.1);
let (kp_high, _) = compute_adaptive_gain(&pid, 10.0);
assert!(kp_high > kp_low, "高流速下市场弹性应自动增强");
}
#[test]
fn test_anti_windup_clamping() {
let mut pid = PidState::default();
pid.ki = 10.0;
for _ in 0..100 {
compute_pid_adjustment_internal(&mut pid, 100.0, 50.0, 0.1, 0.0, 1.0);
}
assert_eq!(pid.is_saturated, 1, "系统应正确识别饱和状态");
}
#[test]
fn test_panic_damping_logic() {
let mut pid = PidState::default();
pid.kd = 1.0;
compute_pid_adjustment_internal(&mut pid, 10.0, 0.0, 0.1, 0.0, 1.0);
let out = compute_pid_adjustment_internal(&mut pid, 10.0, 80.0, 0.1, 0.0, 1.0);
assert!(out < OUTPUT_BASELINE, "恐慌状态下 D项应产生强力反向压制");
}
}

==================================================
FILE: ecobridge-rust\src\economy\environment.rs
==================================================

use crate::models::{TradeContext, MarketConfig};
const SECONDS_PER_DAY: f64 = 86400.0;
const SECONDS_PER_WEEK: f64 = 604800.0;
const SECONDS_PER_MONTH: f64 = 2592000.0;
#[inline]
fn sigmoid(x: f64) -> f64 {
1.0 / (1.0 + (-x * 10.0).exp())
}
pub fn calculate_epsilon_internal(
ctx: &TradeContext,
cfg: &MarketConfig,
) -> f64 {
let ts_sec_utc = (ctx.current_timestamp as f64) / 1000.0;
let offset_sec = ctx.timezone_offset as f64;
let ts_sec_local = ts_sec_utc + offset_sec;
let safe_ln = |factor: f64| factor.max(0.01).ln();
let day_wave = (ts_sec_local * 2.0 * std::f64::consts::PI / SECONDS_PER_DAY).sin();
let week_wave = (ts_sec_local * 2.0 * std::f64::consts::PI / SECONDS_PER_WEEK).sin();
let month_wave = (ts_sec_local * 2.0 * std::f64::consts::PI / SECONDS_PER_MONTH).sin();
let seasonal_factor = 0.6 * day_wave + 0.3 * week_wave + 0.1 * month_wave;
let mut f_sea = 1.0 + cfg.seasonal_amplitude * seasonal_factor;
if (ctx.newbie_mask >> 1) & 1 == 1 {
f_sea *= 1.15;
}
let day_index = (ts_sec_local / SECONDS_PER_DAY).floor() as i64;
let day_of_week = (day_index + 4).rem_euclid(7);
let f_wk = if day_of_week >= 5 { cfg.weekend_multiplier } else { 1.0 };
let f_nb = if (ctx.newbie_mask & 1) == 1 {
1.0 - cfg.newbie_protection_rate
} else {
1.0
};
let sigmoid_trigger = sigmoid(ctx.inflation_rate - 0.05);
let f_inf = 1.0 + (ctx.inflation_rate * 0.2 * sigmoid_trigger);
let log_eps =
cfg.seasonal_weight   * safe_ln(f_sea)
+ cfg.weekend_weight    * safe_ln(f_wk)
+ cfg.newbie_weight     * safe_ln(f_nb)
+ cfg.inflation_weight  * safe_ln(f_inf);
log_eps.exp().clamp(0.1, 10.0)
}
#[cfg(test)]
mod tests {
use super::*;
use crate::models::{TradeContext, MarketConfig};
#[test]
fn test_weekend_logic_utc() {
let mut cfg = MarketConfig::default();
cfg.weekend_multiplier = 2.0;
cfg.weekend_weight = 1.0;
cfg.seasonal_weight = 0.0;
cfg.newbie_weight = 0.0;
cfg.inflation_weight = 0.0;
let sat_ts = 2 * 86400 * 1000;
let ctx = TradeContext {
current_timestamp: sat_ts,
timezone_offset: 0,
..Default::default()
};
let eps = calculate_epsilon_internal(&ctx, &cfg);
assert!((eps - 2.0).abs() < 1e-4);
}
#[test]
fn test_weekend_logic_timezone_shift() {
let mut cfg = MarketConfig::default();
cfg.weekend_multiplier = 2.0;
cfg.weekend_weight = 1.0;
cfg.seasonal_weight = 0.0;
cfg.newbie_weight = 0.0;
cfg.inflation_weight = 0.0;
let thu_night_utc = 82_800 * 1000;
let ctx_london = TradeContext {
current_timestamp: thu_night_utc,
timezone_offset: 0,
..Default::default()
};
let eps_london = calculate_epsilon_internal(&ctx_london, &cfg);
assert!((eps_london - 1.0).abs() < 1e-4, "London should be Thursday (1.0)");
let ctx_sg = TradeContext {
current_timestamp: thu_night_utc,
timezone_offset: 8 * 3600,
..Default::default()
};
let eps_sg = calculate_epsilon_internal(&ctx_sg, &cfg);
assert!((eps_sg - 2.0).abs() < 1e-4, "Singapore should be Friday (2.0)");
}
}

==================================================
FILE: ecobridge-rust\src\economy\macro_eco.rs
==================================================

#[inline(always)]
pub fn calculate_inflation_rate(current_heat: f64, m1_supply: f64) -> f64 {
if m1_supply <= 1.0 {
return 0.0;
}
let raw_rate = current_heat / m1_supply;
raw_rate.clamp(-0.15, 0.45)
}
#[inline(always)]
pub fn calculate_stability(
last_volatile_ts: i64,
current_ts: i64,
recovery_window_ms: f64
) -> f64 {
if last_volatile_ts <= 0 {
return 1.0;
}
let diff = (current_ts - last_volatile_ts) as f64;
if diff < 0.0 {
return 1.0;
}
(diff / recovery_window_ms).clamp(0.0, 1.0)
}
#[inline(always)]
pub fn calculate_decay(current_heat: f64, daily_decay_rate: f64, cycles_per_day: f64) -> f64 {
if current_heat.abs() < 1.0 {
return current_heat;
}
let per_cycle_rate = daily_decay_rate / cycles_per_day;
current_heat * per_cycle_rate
}
#[cfg(test)]
mod tests {
use super::*;
#[test]
fn test_inflation_clamp() {
assert_eq!(calculate_inflation_rate(100.0, 1000.0), 0.10);
assert_eq!(calculate_inflation_rate(5000.0, 1000.0), 0.45);
assert_eq!(calculate_inflation_rate(-200.0, 1000.0), -0.15);
}
#[test]
fn test_stability_recovery() {
let window = 1000.0;
assert_eq!(calculate_stability(0, 100, window), 1.0);
assert_eq!(calculate_stability(1000, 1500, window), 0.5);
assert_eq!(calculate_stability(1000, 2500, window), 1.0);
}
#[test]
fn test_decay_logic() {
let reduction = calculate_decay(1000.0, 0.48, 48.0);
assert_eq!(reduction, 10.0);
let reset_val = calculate_decay(0.5, 0.1, 48.0);
assert_eq!(reset_val, 0.5);
}
}

==================================================
FILE: ecobridge-rust\src\economy\mod.rs
==================================================

pub mod control;
pub mod environment;
pub mod pricing;
pub mod summation;
pub use crate::models::{PidState, MarketConfig, TradeContext, HistoryRecord};
pub use control::{
compute_pid_adjustment_internal,
validate_pid_params
};
pub use environment::{
calculate_epsilon_internal
};
pub use pricing::{
compute_price_final_internal,
predict_price_advanced
};
pub use summation::{
query_neff_internal
};
pub const DEFAULT_LAMBDA: f64 = 0.01;
pub const DEFAULT_TAU: f64 = 7.0;
pub const MIN_PHYSICAL_PRICE: f64 = 0.01;
#[inline]
pub fn get_default_params() -> (f64, f64) {
(DEFAULT_LAMBDA, DEFAULT_TAU)
}
#[inline]
pub fn validate_params(lambda: f64, tau: f64) -> bool {
lambda.is_finite() && lambda > 0.0 &&
tau.is_finite() && tau > 0.0
}
#[cfg(test)]
mod tests {
use super::*;
#[test]
fn test_params_safety_check() {
assert!(validate_params(0.01, 7.0));
assert!(!validate_params(0.0, 7.0));
assert!(!validate_params(f64::NAN, 7.0));
}
#[test]
fn test_economic_pipeline_integration() {
let mut pid = PidState::default();
assert!(validate_pid_params(&pid));
let config = MarketConfig::default();
let ctx = TradeContext {
base_price: 100.0,
current_timestamp: 1736851200000,
newbie_mask: 1,
inflation_rate: 0.02,
..Default::default()
};
let eps = calculate_epsilon_internal(&ctx, &config);
assert!(eps > 0.1 && eps < 10.0);
let vol = 36.5;
let adjustment = compute_pid_adjustment_internal(&mut pid, 100.0, 95.0, 1.0, ctx.inflation_rate);
assert!(adjustment.is_finite());
let final_price = compute_price_final_internal(100.0, vol, 0.01, eps);
assert!(final_price > MIN_PHYSICAL_PRICE);
}
#[test]
fn test_extreme_clamping_logic() {
let base_price = 100.0;
let infinite_vol = 1e18;
let lambda = 0.5;
let eps = 1.0;
let price = compute_price_final_internal(base_price, infinite_vol, lambda, eps);
assert!(price >= MIN_PHYSICAL_PRICE);
}
}

==================================================
FILE: ecobridge-rust\src\economy\pricing.rs
==================================================

use crate::models::{TradeContext, MarketConfig};
use rayon::prelude::*;
use crate::economy::environment;
fn compute_price_behavioral_core(
base_price: f64,
n_eff: f64,
trade_amount: f64,
lambda: f64,
epsilon: f64,
) -> f64 {
if !base_price.is_finite() || !n_eff.is_finite() ||
!lambda.is_finite() || !epsilon.is_finite() {
return 0.01;
}
let adj_lambda = if trade_amount > 0.0 {
lambda * 0.6
} else {
lambda
};
let total_n = n_eff + trade_amount;
let raw_exponent = (-adj_lambda * total_n).clamp(-100.0, 100.0);
let clamped_exponent = 10.0 * (raw_exponent / 10.0).tanh();
let final_price = base_price * epsilon * clamped_exponent.exp();
final_price.max(0.01)
}
pub fn compute_tier_price_internal(
base_price: f64,
quantity: f64,
is_sell: bool
) -> f64 {
if !is_sell || quantity <= 500.0 || quantity <= 0.0 {
return base_price;
}
let mut total_value = 0.0;
let mut remaining = quantity;
let t1 = remaining.min(500.0);
total_value += t1 * base_price;
remaining -= t1;
if remaining > 0.0 {
let t2 = remaining.min(1500.0);
total_value += t2 * (base_price * 0.85);
remaining -= t2;
}
if remaining > 0.0 {
total_value += remaining * (base_price * 0.60);
}
total_value / quantity
}
pub fn compute_price_bounded_internal(
base: f64, n_eff: f64, amt: f64, lambda: f64, eps: f64,
hist_avg: f64
) -> f64 {
let raw_price = compute_price_behavioral_core(base, n_eff, amt, lambda, eps);
let floor = (hist_avg * 0.2).max(0.01);
if raw_price < floor {
floor
} else {
raw_price
}
}
pub fn compute_price_final_internal(base: f64, n_eff: f64, lambda: f64, eps: f64) -> f64 {
compute_price_behavioral_core(base, n_eff, 0.0, lambda, eps)
}
pub fn compute_price_humane_internal(base: f64, n_eff: f64, amt: f64, lambda: f64, eps: f64) -> f64 {
compute_price_behavioral_core(base, n_eff, amt, lambda, eps)
}
pub unsafe fn compute_batch_prices_internal(
count: usize,
neff: f64,
ctx_ptr: *const TradeContext,
cfg_ptr: *const MarketConfig,
hist_avgs_ptr: *const f64,
lambdas_ptr: *const f64,
output_ptr: *mut f64,
) {
let ctx_slice = std::slice::from_raw_parts(ctx_ptr, count);
let cfg_slice = std::slice::from_raw_parts(cfg_ptr, count);
let hist_avgs = std::slice::from_raw_parts(hist_avgs_ptr, count);
let lambdas = std::slice::from_raw_parts(lambdas_ptr, count);
let output = std::slice::from_raw_parts_mut(output_ptr, count);
output.par_iter_mut()
.enumerate()
.for_each(|(i, price_out)| {
let ctx = &ctx_slice[i];
let cfg = &cfg_slice[i];
let lambda = lambdas[i];
let hist_avg = hist_avgs[i];
let epsilon = environment::calculate_epsilon_internal(ctx, cfg);
*price_out = compute_price_bounded_internal(
ctx.base_price,
neff,
0.0,
lambda,
epsilon,
hist_avg
);
});
}

==================================================
FILE: ecobridge-rust\src\economy\summation.rs
==================================================

use crate::models::HistoryRecord;
use crate::storage;
use std::sync::RwLock;
use lazy_static::lazy_static;
#[cfg(target_arch = "x86_64")]
use std::arch::x86_64::*;
#[cfg(feature = "parallel")]
use rayon::prelude::*;
const PARALLEL_THRESHOLD: usize = 750;
const MS_PER_DAY: f64 = 86_400_000.0;
const MAX_FUTURE_TOLERANCE: i64 = 60_000;
lazy_static! {
static ref HOT_HISTORY: RwLock<Vec<HistoryRecord>> = RwLock::new(Vec::with_capacity(100_000));
}
pub fn hydrate_hot_store() {
let records = storage::load_recent_history(30);
let len = records.len();
let mut lock = HOT_HISTORY.write().unwrap();
*lock = records;
println!("[EcoBridge-Native] SIMD 引擎热数据装填完成: {} 条记录", len);
}
pub fn append_trade_to_memory(ts: i64, amount: f64) {
let mut lock = HOT_HISTORY.write().unwrap();
lock.push(HistoryRecord {
timestamp: ts,
amount,
});
}
pub fn query_neff_internal(
current_ts: i64,
tau: f64,
) -> f64 {
let lock = HOT_HISTORY.read().unwrap();
calculate_volume_in_memory(&lock, current_ts, tau)
}
pub fn calculate_volume_in_memory(
history: &[HistoryRecord],
current_time: i64,
tau: f64,
) -> f64 {
if history.is_empty() || tau <= 0.0 {
return 0.0;
}
let lambda = 1.0 / (tau * MS_PER_DAY);
let valid_future_limit = current_time + MAX_FUTURE_TOLERANCE;
let valid_past_limit = current_time - (tau * MS_PER_DAY * 10.0) as i64;
let is_valid_record = |r: &&HistoryRecord| -> bool {
r.timestamp <= valid_future_limit && r.timestamp >= valid_past_limit
};
let t_min = history.iter()
.filter(is_valid_record)
.map(|r| r.timestamp)
.min()
.unwrap_or(current_time);
let base_multiplier = (-(current_time - t_min) as f64 * lambda).exp();
#[cfg(target_arch = "x86_64")]
if is_x86_feature_detected!("avx2") {
let sum_partial = unsafe {
compute_partial_simd(history, t_min, lambda, valid_future_limit, valid_past_limit)
};
let result = sum_partial * base_multiplier;
return if result.is_finite() { result } else { 0.0 };
}
let compute_partial = |rec: &HistoryRecord| -> f64 {
if rec.timestamp > valid_future_limit || rec.timestamp < valid_past_limit {
return 0.0;
}
let dt_rel = rec.timestamp.saturating_sub(t_min) as f64;
rec.amount * (dt_rel * lambda).exp()
};
let sum_partial: f64 = if history.len() >= PARALLEL_THRESHOLD {
#[cfg(feature = "parallel")]
{
history.par_iter().map(compute_partial).sum()
}
#[cfg(not(feature = "parallel"))]
{
history.iter().map(compute_partial).sum()
}
} else {
history.iter().map(compute_partial).sum()
};
let result = sum_partial * base_multiplier;
if result.is_finite() { result } else { 0.0 }
}
#[cfg(target_arch = "x86_64")]
#[target_feature(enable = "avx2")]
unsafe fn compute_partial_simd(
history: &[HistoryRecord],
t_min: i64,
lambda: f64,
valid_future: i64,
valid_past: i64
) -> f64 {
let mut sum_vec = _mm256_setzero_pd();
let v_tmin = _mm256_set1_pd(t_min as f64);
let v_lambda = _mm256_set1_pd(lambda);
let chunks = history.chunks_exact(4);
let remainder = chunks.remainder();
for chunk in chunks {
let t0 = chunk[0].timestamp; let t1 = chunk[1].timestamp;
let t2 = chunk[2].timestamp; let t3 = chunk[3].timestamp;
if t0 > valid_future || t0 < valid_past ||
t1 > valid_future || t1 < valid_past ||
t2 > valid_future || t2 < valid_past ||
t3 > valid_future || t3 < valid_past {
for r in chunk {
if r.timestamp <= valid_future && r.timestamp >= valid_past {
let dt = (r.timestamp - t_min) as f64;
let val = r.amount * (dt * lambda).exp();
let v_val = _mm256_set_pd(0.0, 0.0, 0.0, val);
sum_vec = _mm256_add_pd(sum_vec, v_val);
}
}
continue;
}
let v_ts = _mm256_set_pd(
chunk[3].timestamp as f64,
chunk[2].timestamp as f64,
chunk[1].timestamp as f64,
chunk[0].timestamp as f64,
);
let v_amount = _mm256_set_pd(
chunk[3].amount,
chunk[2].amount,
chunk[1].amount,
chunk[0].amount,
);
let v_dt = _mm256_sub_pd(v_ts, v_tmin);
let v_exponent = _mm256_mul_pd(v_dt, v_lambda);
let mut arr = [0.0f64; 4];
_mm256_storeu_pd(arr.as_mut_ptr(), v_exponent);
arr[0] = arr[0].exp();
arr[1] = arr[1].exp();
arr[2] = arr[2].exp();
arr[3] = arr[3].exp();
let v_exp = _mm256_loadu_pd(arr.as_ptr());
let v_partial = _mm256_mul_pd(v_amount, v_exp);
sum_vec = _mm256_add_pd(sum_vec, v_partial);
}
let mut temp = [0.0f64; 4];
_mm256_storeu_pd(temp.as_mut_ptr(), sum_vec);
let mut total = temp[0] + temp[1] + temp[2] + temp[3];
for rec in remainder {
if rec.timestamp <= valid_future && rec.timestamp >= valid_past {
let dt = (rec.timestamp - t_min) as f64;
total += rec.amount * (dt * lambda).exp();
}
}
total
}

==================================================
FILE: ecobridge-rust\src\security\mod.rs
==================================================

pub mod regulator;
pub use crate::models::RegulatorConfig;
pub use regulator::{
compute_transfer_check_internal,
is_high_risk_transfer,
CODE_NORMAL,
CODE_WARNING_HIGH_RISK,
CODE_BLOCK_REVERSE_FLOW,
CODE_BLOCK_INJECTION,
CODE_BLOCK_INSUFFICIENT_FUNDS,
CODE_BLOCK_VELOCITY_LIMIT,
};

==================================================
FILE: ecobridge-rust\src\security\regulator.rs
==================================================

use crate::models::{TransferContext, TransferResult, RegulatorConfig};
pub const CODE_NORMAL: i32 = 0;
pub const CODE_WARNING_HIGH_RISK: i32 = 1;
pub const CODE_BLOCK_REVERSE_FLOW: i32 = 2;
pub const CODE_BLOCK_INJECTION: i32 = 3;
pub const CODE_BLOCK_INSUFFICIENT_FUNDS: i32 = 4;
pub const CODE_BLOCK_VELOCITY_LIMIT: i32 = 5;
pub fn compute_transfer_check_internal(
ctx: &TransferContext,
cfg: &RegulatorConfig,
) -> TransferResult {
let amount = ctx.amount.max(0.0);
let sender_bal = ctx.sender_balance.max(0.0);
let receiver_bal = ctx.receiver_balance.max(0.0);
if amount > sender_bal {
return TransferResult {
final_tax: 0.0,
is_blocked: 1,
warning_code: CODE_BLOCK_INSUFFICIENT_FUNDS,
};
}
let puppet_factor = if ctx.sender_activity_score < 0.1 {
ctx.sender_velocity as f64 * 2.0
} else {
ctx.sender_velocity as f64 / ctx.sender_activity_score.max(0.1)
};
if puppet_factor > cfg.velocity_threshold {
return TransferResult {
final_tax: 0.0,
is_blocked: 1,
warning_code: CODE_BLOCK_VELOCITY_LIMIT,
};
}
let newbie_threshold_sec = cfg.newbie_hours * 3600.0;
let veteran_threshold_sec = cfg.veteran_hours * 3600.0;
if (ctx.sender_play_time as f64) < newbie_threshold_sec
&& (ctx.receiver_play_time as f64) > veteran_threshold_sec
&& amount > ctx.newbie_limit
{
return TransferResult {
final_tax: 0.0,
is_blocked: 1,
warning_code: CODE_BLOCK_REVERSE_FLOW
};
}
let mut warning_code = CODE_NORMAL;
let risk_ratio = amount / sender_bal.max(1.0);
if risk_ratio > cfg.warning_ratio || puppet_factor > (cfg.velocity_threshold * 0.7) {
warning_code = CODE_WARNING_HIGH_RISK;
}
let inflation_adj = 1.0 + ctx.inflation_rate.max(0.0);
let mut tax = amount * cfg.base_tax_rate * inflation_adj;
let behavioral_penalty = (ctx.sender_velocity as f64 * 0.05).exp();
tax *= behavioral_penalty;
if amount > cfg.luxury_threshold {
let excess = amount - cfg.luxury_threshold;
tax = excess.mul_add(cfg.luxury_tax_rate, tax);
}
if sender_bal < cfg.poor_threshold && receiver_bal > cfg.rich_threshold {
let gap_tax = amount * cfg.wealth_gap_tax_rate;
tax = tax.max(gap_tax);
}
let tax_clamped = tax.min(amount * 0.8);
TransferResult {
final_tax: tax_clamped,
is_blocked: 0,
warning_code,
}
}
pub fn is_high_risk_transfer(result: &crate::models::TransferResult) -> bool {
result.is_blocked == 1 || result.warning_code == CODE_WARNING_HIGH_RISK
}

==================================================
FILE: ecobridge-rust\src\storage\mod.rs
==================================================

use crossbeam_channel::{bounded, Receiver, Sender};
use duckdb::{params, Connection};
use std::ops::Deref;
use std::path::PathBuf;
use std::sync::atomic::{AtomicU64, Ordering};
use std::sync::{OnceLock, RwLock};
use std::thread;
use libc::c_int;
use lazy_static::lazy_static;
use crate::models::HistoryRecord;
lazy_static! {
static ref GLOBAL_HISTORY: RwLock<Vec<HistoryRecord>> = RwLock::new(Vec::with_capacity(200_000));
}
static LOG_SENDER: OnceLock<Sender<LogEvent>> = OnceLock::new();
static READ_POOL: OnceLock<ConnectionPool> = OnceLock::new();
static TOTAL_LOGS: AtomicU64 = AtomicU64::new(0);
static DROPPED_LOGS: AtomicU64 = AtomicU64::new(0);
struct LogEvent {
ts: i64,
uuid: String,
delta: f64,
balance: f64,
meta: String,
}
struct ConnectionPool {
available: Receiver<Connection>,
recycle: Sender<Connection>,
}
struct DbConnectionGuard {
conn: Option<Connection>,
pool_sender: Sender<Connection>,
}
impl Deref for DbConnectionGuard {
type Target = Connection;
fn deref(&self) -> &Self::Target {
self.conn.as_ref().unwrap()
}
}
impl Drop for DbConnectionGuard {
fn drop(&mut self) {
if let Some(conn) = self.conn.take() {
let _ = self.pool_sender.send(conn);
}
}
}
pub fn shutdown_db_internal() -> c_int {
if let Some(sender) = LOG_SENDER.get() {
let res = sender.send(LogEvent {
ts: -1,
uuid: String::new(),
delta: 0.0,
balance: 0.0,
meta: String::from("SHUTDOWN_SIGNAL"),
});
if res.is_ok() {
return 0;
}
}
-1
}
pub fn init_economy_db(path_str: &str) -> c_int {
if LOG_SENDER.get().is_some() {
return 0;
}
let mut db_path = PathBuf::from(path_str);
db_path.push("ecobridge_vault.db");
let write_conn = match Connection::open(&db_path) {
Ok(c) => c,
Err(e) => {
eprintln!("[EcoBridge-Storage] DB Open Error: {}", e);
return -4;
}
};
let ddl_res = write_conn.execute_batch(
"SET memory_limit='512MB';
CREATE TABLE IF NOT EXISTS economy_log (
ts BIGINT,
player_uuid VARCHAR,
delta DOUBLE,
balance DOUBLE,
metadata VARCHAR
);
CREATE INDEX IF NOT EXISTS idx_ts ON economy_log (ts);"
);
if let Err(e) = ddl_res {
eprintln!("[EcoBridge-Storage] DDL Error: {}", e);
return -5;
}
load_recent_history_to_memory(&write_conn);
let pool_size = 4;
let (pool_tx, pool_rx) = bounded(pool_size);
for _i in 0..pool_size {
if let Ok(c) = write_conn.try_clone() {
let _ = pool_tx.send(c);
}
}
READ_POOL.set(ConnectionPool {
available: pool_rx,
recycle: pool_tx,
}).ok();
let (tx, rx) = bounded(50_000);
thread::Builder::new()
.name("ecobridge-db-writer".into())
.spawn(move || writer_loop(write_conn, rx))
.expect("Failed to spawn DB writer thread");
match LOG_SENDER.set(tx) {
Ok(_) => 0,
Err(_) => -7,
}
}
fn load_recent_history_to_memory(conn: &Connection) {
let now = std::time::SystemTime::now()
.duration_since(std::time::UNIX_EPOCH)
.unwrap_or_default()
.as_millis() as i64;
let cutoff = now - (90i64 * 86_400_000);
println!("[EcoBridge-Storage] 正在预热内存数据 (Cutoff: {})...", cutoff);
let mut stmt = match conn.prepare("SELECT ts, delta FROM economy_log WHERE ts > ? ORDER BY ts ASC") {
Ok(s) => s,
Err(e) => {
eprintln!("[EcoBridge-Storage] Preload Prepare Error: {}", e);
return;
}
};
let records_iter = stmt.query_map(params![cutoff], |row| {
Ok(HistoryRecord {
timestamp: row.get(0)?,
amount: row.get(1)?,
})
});
match records_iter {
Ok(iter) => {
let mut hist = GLOBAL_HISTORY.write().unwrap();
let start_len = hist.len();
for rec in iter {
if let Ok(r) = rec {
hist.push(r);
}
}
println!("[EcoBridge-Storage] 预热完成。加载了 {} 条记录到内存。", hist.len() - start_len);
}
Err(e) => eprintln!("[EcoBridge-Storage] Preload Query Error: {}", e),
}
}
pub fn get_history_read() -> std::sync::RwLockReadGuard<'static, Vec<HistoryRecord>> {
GLOBAL_HISTORY.read().unwrap()
}
pub fn log_economy_event(ts: i64, uuid: String, delta: f64, balance: f64, meta: String) {
TOTAL_LOGS.fetch_add(1, Ordering::Relaxed);
{
if let Ok(mut hist) = GLOBAL_HISTORY.write() {
hist.push(HistoryRecord { timestamp: ts, amount: delta });
if hist.len() > 500_000 {
let keep = 400_000;
let remove_count = hist.len() - keep;
hist.drain(0..remove_count);
}
}
}
if let Some(sender) = LOG_SENDER.get() {
if let Err(_) = sender.try_send(LogEvent { ts, uuid, delta, balance, meta }) {
DROPPED_LOGS.fetch_add(1, Ordering::Relaxed);
}
} else {
DROPPED_LOGS.fetch_add(1, Ordering::Relaxed);
}
}
fn writer_loop(conn: Connection, rx: Receiver<LogEvent>) {
let mut buffer = Vec::with_capacity(1024);
loop {
let first = match rx.recv() {
Ok(msg) => msg,
Err(_) => break,
};
if first.ts == -1 {
eprintln!("[EcoBridge-Storage] 接收到关机信号，正在冲刷缓存并退出...");
break;
}
buffer.push(first);
while buffer.len() < 1024 {
match rx.try_recv() {
Ok(msg) => {
if msg.ts == -1 { break; }
buffer.push(msg);
},
Err(_) => break,
}
}
flush_buffer_to_db(&conn, &mut buffer);
}
if !buffer.is_empty() {
flush_buffer_to_db(&conn, &mut buffer);
}
eprintln!("[EcoBridge-Storage] 后台写入线程已安全终止。");
}
fn flush_buffer_to_db(conn: &Connection, buffer: &mut Vec<LogEvent>) {
if buffer.is_empty() { return; }
match conn.appender("economy_log") {
Ok(mut appender) => {
for ev in buffer.drain(..) {
if appender.append_row(params![ev.ts, ev.uuid, ev.delta, ev.balance, ev.meta]).is_err() {
DROPPED_LOGS.fetch_add(1, Ordering::Relaxed);
}
}
}
Err(e) => {
eprintln!("[EcoBridge-Storage] Appender Error: {}", e);
DROPPED_LOGS.fetch_add(buffer.len() as u64, Ordering::Relaxed);
buffer.clear();
}
}
}
pub fn query_neff_from_db(current_ts: i64, tau: f64) -> f64 {
let pool = match READ_POOL.get() {
Some(p) => p,
None => return 0.0,
};
let raw_conn = match pool.available.recv() {
Ok(c) => c,
Err(_) => return 0.0,
};
let conn_guard = DbConnectionGuard {
conn: Some(raw_conn),
pool_sender: pool.recycle.clone(),
};
let query = "SELECT SUM(ABS(delta) * EXP( -1.0 * (?1 - ts) / (?2 * 86400000.0) )) FROM economy_log WHERE ts > ?3";
let ms_per_day = 86_400_000.0;
let safe_lookback_ms = (tau * ms_per_day * 3.0) as i64;
let min_ts = current_ts - safe_lookback_ms;
conn_guard.query_row(query, params![current_ts, tau, min_ts], |row| row.get(0)).unwrap_or(0.0)
}
pub fn get_total_logs() -> u64 { TOTAL_LOGS.load(Ordering::Relaxed) }
pub fn get_dropped_logs() -> u64 { DROPPED_LOGS.load(Ordering::Relaxed) }
pub fn load_recent_history(days: i64) -> Vec<crate::models::HistoryRecord> {
let pool = match READ_POOL.get() {
Some(p) => p,
None => return Vec::new(),
};
let raw_conn = match pool.available.recv() {
Ok(c) => c,
Err(_) => return Vec::new(),
};
let ms_lookback = days * 86_400_000;
let cutoff = chrono::Utc::now().timestamp_millis() - ms_lookback;
let query = "
SELECT ts, delta
FROM economy_log
WHERE ts > ?
ORDER BY ts ASC
";
let mut stmt = raw_conn.prepare(query).unwrap();
let record_iter = stmt.query_map(params![cutoff], |row| {
Ok(crate::models::HistoryRecord {
timestamp: row.get(0)?,
amount: row.get::<_, f64>(1)?.abs(),
})
}).unwrap();
let mut history = Vec::new();
for record in record_iter {
if let Ok(r) = record {
history.push(r);
}
}
let _ = pool.recycle.send(raw_conn);
history
}
