
==================================================
FILE: ecobridge-java\build.gradle.kts
==================================================

import com.github.jengelman.gradle.plugins.shadow.tasks.ShadowJar
import java.util.Properties
buildscript {
repositories {
mavenCentral()
gradlePluginPortal()
}
dependencies {
// ASM 9.9.1: å®Œç¾æ”¯æŒ Java 25 é¢„è§ˆç‰ˆå­—èŠ‚ç 
classpath("org.ow2.asm:asm-commons:9.9.1")
}
}
plugins {
`java-library`
// ä¸¥æ ¼ä¿ç•™ Shadow 9.3.1
id("com.gradleup.shadow") version "9.3.1"
}
group = "top.ellan"
version = "1.0-SNAPSHOT"
// --- [jextract è‡ªåŠ¨åŒ–é…ç½®é€»è¾‘] ---
val rustHeaderFile = file("${projectDir}/../ecobridge-rust/ecobridge_rust.h")
val generatedSourceDir = layout.buildDirectory.dir("generated/sources/jextract")
val targetPackage = "top.ellan.ecobridge.gen"
fun findJextract(): String {
val os = org.gradle.internal.os.OperatingSystem.current()
val binaryName = if (os.isWindows) "jextract.bat" else "jextract"
// ä¼˜å…ˆè¯»å–ç¯å¢ƒå˜é‡ (é’ˆå¯¹ GitHub Actions)
val envHome = System.getenv("JEXTRACT_HOME")
if (!envHome.isNullOrBlank()) {
val path = file("$envHome/bin/$binaryName")
if (path.exists()) return path.absolutePath
}
// å…¶æ¬¡è¯»å– local.properties (é’ˆå¯¹æœ¬åœ°å¼€å‘)
val localPropsFile = file("local.properties")
if (localPropsFile.exists()) {
val props = Properties()
localPropsFile.inputStream().use { props.load(it) }
val localHome = props.getProperty("jextract.home")
if (localHome != null) {
val possiblePaths = listOf(file("$localHome/bin/$binaryName"), file("$localHome/$binaryName"))
for (path in possiblePaths) if (path.exists()) return path.absolutePath
}
}
return binaryName // é™çº§ä¸ºç³»ç»Ÿ PATH ä¸­çš„ jextract
}
val generateBindings = tasks.register<Exec>("generateBindings") {
group = "build"
description = "ä½¿ç”¨ jextract è‡ªåŠ¨ä» Rust å¤´æ–‡ä»¶ç”Ÿæˆ Java FFM ç»‘å®šã€‚"
doFirst {
if (!rustHeaderFile.exists()) {
throw GradleException("âŒ é”™è¯¯ï¼šæœªæ‰¾åˆ° Rust å¤´æ–‡ä»¶: ${rustHeaderFile.absolutePath}")
}
generatedSourceDir.get().asFile.mkdirs()
}
commandLine(
findJextract(),
"--output", generatedSourceDir.get().asFile.absolutePath,
"--target-package", targetPackage,
"--header-class-name", "ecobridge_rust_h",
"--library", "ecobridge_rust",
rustHeaderFile.absolutePath
)
inputs.file(rustHeaderFile)
outputs.dir(generatedSourceDir)
}
// --- [Java ç¯å¢ƒä¸å·¥å…·é“¾] ---
java {
toolchain {
languageVersion.set(JavaLanguageVersion.of(25))
}
}
sourceSets {
main {
// âœ… æ ¸å¿ƒä¿®å¤ï¼šæ³¨å†Œ jextract è¾“å‡ºã€‚è¿™ä¸ä»…è§£å†³äº†åŒ…åä¸å­˜åœ¨é—®é¢˜ï¼Œ
// è¿˜ä¼šè‡ªåŠ¨è®© compileJava ä»»åŠ¡ä¾èµ–äº generateBindingsã€‚
java.srcDir(generateBindings)
}
}
repositories {
mavenCentral()
// ğŸ”¥ å…³é”®ï¼šJackson 3.0 / 2.20 ç›®å‰ä¸»è¦é€šè¿‡ Sonatype ä»“åº“åˆ†å‘
maven("https://central.sonatype.com/repository/maven-snapshots/")
maven("https://oss.sonatype.org/content/repositories/releases/")
maven("https://oss.sonatype.org/content/repositories/snapshots/")
maven("https://jitpack.io")
maven("https://repo.papermc.io/repository/maven-public/")
maven("https://repo.nightexpressdev.com/releases")
maven("https://repo.lanink.cn/repository/maven-public/")
maven("https://repo.extendedclip.com/content/repositories/placeholderapi/")
flatDir { dirs("libs") }
}
dependencies {
// ä¸¥æ ¼ä¿ç•™ï¼šPaper API
compileOnly("io.papermc.paper:paper-api:1.21.11-R0.1-SNAPSHOT")
compileOnly("me.clip:placeholderapi:2.11.6")
compileOnly("su.nightexpress.nightcore:main:2.13.0")
compileOnly("su.nightexpress.coinsengine:CoinsEngine:2.6.0")
compileOnly("cn.superiormc.ultimateshop:plugin:4.2.3")
compileOnly(fileTree(mapOf("dir" to "libs", "include" to listOf("**/*.jar"))))
// ğŸ”¥ Jackson 3.0 å…¨å®¶æ¡¶é…ç½® (ä¸¥æ ¼éµå¾ªè¿ç§»æŒ‡å—)
implementation(platform("tools.jackson:jackson-bom:3.0.0"))
implementation("tools.jackson.core:jackson-databind")
implementation("tools.jackson.core:jackson-core")
// æ³¨è§£ä¿æŒæ—§åæ ‡ï¼ŒBOM ä¼šè‡ªåŠ¨è§£æåˆ°åŒ¹é…çš„ 2.20 ç³»åˆ—
implementation("com.fasterxml.jackson.core:jackson-annotations")
// ğŸ”¥ 2026 æœ€æ–°ç¨³å®šç‰ˆæ•°æ®åº“/ç¼“å­˜åº“
implementation("org.mariadb.jdbc:mariadb-java-client:3.5.7")
implementation("com.zaxxer:HikariCP:7.0.2")
implementation("com.github.ben-manes.caffeine:caffeine:3.2.3")
implementation("redis.clients:jedis:7.2.0")
compileOnly("com.google.code.gson:gson:2.13.2")
// æµ‹è¯•
testImplementation(platform("org.junit:junit-bom:5.14.1"))
testImplementation("org.junit.jupiter:junit-jupiter")
}
tasks.withType<JavaCompile> {
// å†æ¬¡æ˜¾å¼ä¾èµ–ï¼Œç¡®ä¿å¹¶è¡Œæ„å»ºæ—¶çš„å®‰å…¨æ€§
dependsOn(generateBindings)
options.encoding = "UTF-8"
options.release.set(25)
options.compilerArgs.addAll(listOf(
"--enable-preview",
"-Xlint:unchecked",
"-Xlint:-preview"
))
}
tasks.named<ShadowJar>("shadowJar") {
archiveClassifier.set("")
val prefix = "top.ellan.ecobridge.libs"
// âœ… å¿…é¡»é‡å®šå‘ä¾èµ–ï¼Œå¦åˆ™ä¼šå¯¼è‡´æ’ä»¶å†²çª
relocate("tools.jackson", "$prefix.jackson")
relocate("com.fasterxml.jackson.annotation", "$prefix.jackson.annotations")
relocate("com.zaxxer.hikari", "$prefix.hikari")
relocate("org.mariadb.jdbc", "$prefix.mariadb")
relocate("com.github.benmanes.caffeine", "$prefix.caffeine")
relocate("redis.clients", "$prefix.jedis")
// æ‰“åŒ…èµ„æºæ–‡ä»¶ï¼ŒåŒ…æ‹¬ native åº“
from("src/main/resources") {
include("*.dll", "*.so", "*.dylib", "natives/**")
}
// åˆå¹¶æœåŠ¡å‘ç°æ–‡ä»¶ï¼ˆå¯¹ JDBC å’Œ Jackson å¾ˆé‡è¦ï¼‰
mergeServiceFiles()
}
tasks.withType<ProcessResources> {
val props = mapOf("version" to project.version)
inputs.properties(props)
filesMatching("plugin.yml") {
expand(props)
}
}

==================================================
FILE: ecobridge-java\settings.gradle.kts
==================================================

rootProject.name = "EcoBridge"

==================================================
FILE: ecobridge-java\src\main\java\top\ellan\ecobridge\EcoBridge.java
==================================================

package top.ellan.ecobridge;
import net.kyori.adventure.text.minimessage.MiniMessage;
import net.kyori.adventure.text.minimessage.tag.resolver.TagResolver;
import org.bukkit.Bukkit;
import org.bukkit.event.EventHandler;
import org.bukkit.event.Listener;
import org.bukkit.event.player.PlayerJoinEvent;
import org.bukkit.event.player.PlayerQuitEvent;
import org.bukkit.plugin.java.JavaPlugin;
import top.ellan.ecobridge.bridge.NativeBridge;
import top.ellan.ecobridge.cache.HotDataCache;
import top.ellan.ecobridge.command.TransferCommand;
import top.ellan.ecobridge.database.DatabaseManager;
import top.ellan.ecobridge.hook.EcoPlaceholderExpansion;
import top.ellan.ecobridge.listener.CacheListener;
import top.ellan.ecobridge.listener.CoinsEngineListener;
import top.ellan.ecobridge.listener.CommandInterceptor;
import top.ellan.ecobridge.listener.TradeListener;
import top.ellan.ecobridge.manager.*;
import top.ellan.ecobridge.network.RedisManager;
import top.ellan.ecobridge.storage.ActivityCollector;
import top.ellan.ecobridge.storage.AsyncLogger;
import top.ellan.ecobridge.util.HolidayManager;
import top.ellan.ecobridge.util.LogUtil;
import java.util.concurrent.ExecutorService;
import java.util.concurrent.Executors;
import java.util.concurrent.TimeUnit;
import java.util.concurrent.atomic.AtomicBoolean;
public final class EcoBridge extends JavaPlugin implements Listener {
private static volatile EcoBridge instance;
private static final MiniMessage MM = MiniMessage.miniMessage();
private ExecutorService virtualExecutor;
private final AtomicBoolean fullyInitialized = new AtomicBoolean(false);
@Override
public void onEnable() {
instance = this;
this.virtualExecutor = Executors.newVirtualThreadPerTaskExecutor();
try {
bootstrapInfrastructure();
ActivityCollector.startHeartbeat(this);
} catch (Exception e) {
getLogger().severe("åŸºç¡€æ¶æ„å¼•å¯¼å¤±è´¥ï¼Œç³»ç»Ÿå¼ºåˆ¶æŒ‚èµ·: " + e.getMessage());
Bukkit.getPluginManager().disablePlugin(this);
return;
}
printBanner();
if (!verifyDependencies()) return;
try {
NativeBridge.init(this);
EconomyManager.init(this);
EconomicStateManager.init(this);
PricingManager.init(this);
TransferManager.init(this);
registerCommands();
registerListeners();
registerHooks();
getServer().getScheduler().runTaskLater(this, () -> {
if (getServer().getPluginManager().isPluginEnabled("UltimateShop")) {
LogUtil.info("æ£€æµ‹åˆ° UltimateShopï¼Œæ­£åœ¨æ³¨å…¥ EcoBridge å†…æ ¸...");
UShopLimitInjector.execute(this);
UShopPriceInjector.execute(this);
}
}, 20L);
this.fullyInitialized.set(true);
sendConsole("<blue>â”ƒ <green>ç³»ç»ŸçŠ¶æ€: <white>ç‰©ç†æ¼”ç®—æ ¸å¿ƒå·²è¿›å…¥å®æ—¶åŒæ­¥çŠ¶æ€ (v0.8.9) <blue>â”ƒ");
sendConsole("<gradient:aqua:blue>â”—â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”›</gradient>");
} catch (Throwable e) {
LogUtil.error("è‡´å‘½é”™è¯¯: æ’ä»¶ç»„ä»¶åˆå§‹åŒ–é“¾æ¡ä¸­æ–­", e);
Bukkit.getPluginManager().disablePlugin(this);
}
}
@Override
public void onDisable() {
sendConsole("<yellow>[EcoBridge] æ­£åœ¨å¯åŠ¨å®‰å…¨å…³æœºåºåˆ— (Panic-Safe Shutdown)...");
this.fullyInitialized.set(false);
UShopLimitInjector.revert();
UShopPriceInjector.revert();
if (RedisManager.getInstance() != null) {
RedisManager.getInstance().shutdown();
}
HolidayManager.shutdown();
shutdownPersistenceLayer();
NativeBridge.shutdown();
terminateVirtualPool();
getServer().getScheduler().cancelTasks(this);
instance = null;
sendConsole("<red>[EcoBridge] æ’ä»¶å·²å®‰å…¨å¸è½½ã€‚å†…å­˜å±éšœå·²å…³é—­ï¼Œç‰©ç†èµ„æºå·²å®‰å…¨é‡Šæ”¾ã€‚");
}
private void bootstrapInfrastructure() {
saveDefaultConfig();
LogUtil.init();
DatabaseManager.init();
AsyncLogger.init(this);
HolidayManager.init();
RedisManager.init(this);
}
private void shutdownPersistenceLayer() {
if (AsyncLogger.getInstance() != null) {
AsyncLogger.getInstance().shutdown();
}
LogUtil.info("æ­£åœ¨æ‰§è¡Œçƒ­æ•°æ®ç»ˆç‚¹åˆ·ç›˜...");
HotDataCache.saveAllSync();
DatabaseManager.close();
}
private void terminateVirtualPool() {
if (virtualExecutor != null && !virtualExecutor.isShutdown()) {
virtualExecutor.shutdown();
try {
if (!virtualExecutor.awaitTermination(5, TimeUnit.SECONDS)) {
virtualExecutor.shutdownNow();
}
} catch (InterruptedException e) {
virtualExecutor.shutdownNow();
Thread.currentThread().interrupt();
}
}
}
private boolean verifyDependencies() {
var pm = Bukkit.getPluginManager();
if (!pm.isPluginEnabled("CoinsEngine")) {
sendConsole("<blue>â”ƒ <red>è‡´å‘½é”™è¯¯: æœªæ£€æµ‹åˆ° CoinsEngineï¼Œç³»ç»Ÿå¼ºåˆ¶æŒ‚èµ·ã€‚ <blue>â”ƒ");
pm.disablePlugin(this);
return false;
}
return true;
}
private void registerListeners() {
var pm = getServer().getPluginManager();
pm.registerEvents(this, this);
pm.registerEvents(new CoinsEngineListener(this), this);
pm.registerEvents(new CommandInterceptor(this), this);
pm.registerEvents(new TradeListener(this), this);
pm.registerEvents(new CacheListener(), this);
}
private void registerHooks() {
if (getServer().getPluginManager().isPluginEnabled("PlaceholderAPI")) {
new EcoPlaceholderExpansion(this).register();
LogUtil.info("PlaceholderAPI æ‰©å±•å·²æŒ‚è½½ã€‚");
}
}
private void registerCommands() {
var cmd = getCommand("ecopay");
if (cmd != null) cmd.setExecutor(new TransferCommand());
}
public void reload() {
reloadConfig();
LogUtil.init();
if (EconomyManager.getInstance() != null) EconomyManager.getInstance().loadState();
if (PricingManager.getInstance() != null) PricingManager.getInstance().loadConfig();
if (getServer().getPluginManager().isPluginEnabled("UltimateShop")) {
UShopLimitInjector.execute(this);
UShopPriceInjector.execute(this);
}
sendConsole("<green>[EcoBridge] é€»è¾‘å‚æ•°é‡è½½æˆåŠŸã€‚Native å†…å­˜å¸ƒå±€ä¿æŒé”å®šã€‚");
}
@EventHandler
public void onJoin(PlayerJoinEvent event) {
ActivityCollector.updateSnapshot(event.getPlayer());
}
@EventHandler
public void onQuit(PlayerQuitEvent event) {
ActivityCollector.removePlayer(event.getPlayer().getUniqueId());
}
public static EcoBridge getInstance() { return instance; }
public ExecutorService getVirtualExecutor() { return virtualExecutor; }
public static MiniMessage getMiniMessage() { return MM; }
public boolean isFullyInitialized() { return fullyInitialized.get(); }
private void printBanner() {
String version = getPluginMeta().getVersion();
sendConsole("<gradient:aqua:blue>â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”“</gradient>");
sendConsole("<blue>â”ƒ <green>EcoBridge <white>v" + version + " <gray>| <aqua>Java 25 (Loom/FFM) <blue>â”ƒ");
}
private void sendConsole(String msg, TagResolver... resolvers) {
Bukkit.getConsoleSender().sendMessage(MM.deserialize(msg, resolvers));
}
}

==================================================
FILE: ecobridge-java\src\main\java\top\ellan\ecobridge\api\UShopProvider.java
==================================================

package top.ellan.ecobridge.api;
import cn.superiormc.ultimateshop.objects.buttons.ObjectItem;
import org.bukkit.entity.Player;
import top.ellan.ecobridge.bridge.NativeBridge;
import top.ellan.ecobridge.manager.PricingManager;
import top.ellan.ecobridge.util.PriceOracle;
public final class UShopProvider {
public static double calculateDynamicPrice(Player player, ObjectItem item, int amount) {
if (player == null || item == null) return 0.0;
if (!PriceOracle.isValidEconomyItem(item)) {
return PriceOracle.getOriginalBasePrice(item, amount < 0);
}
if (!NativeBridge.isLoaded()) {
return PriceOracle.getOriginalBasePrice(item, amount < 0);
}
double unitPrice = PricingManager.getInstance().getSnapshotPrice(
item.getShop(),
item.getProduct()
);
if (unitPrice <= 0) {
double p0 = PriceOracle.getOriginalBasePrice(item, amount < 0);
return p0 > 0 ? p0 : 0.0;
}
return unitPrice * Math.abs(amount);
}
}

==================================================
FILE: ecobridge-java\src\main\java\top\ellan\ecobridge\api\event\PriceCalculatedEvent.java
==================================================

package top.ellan.ecobridge.api.event;
import net.kyori.adventure.text.Component;
import net.kyori.adventure.text.minimessage.tag.resolver.Placeholder;
import org.bukkit.entity.Player;
import org.bukkit.event.Event;
import org.bukkit.event.HandlerList;
import org.jetbrains.annotations.NotNull;
import org.jetbrains.annotations.Nullable;
import top.ellan.ecobridge.EcoBridge;
import java.util.ArrayList;
import java.util.Collections;
import java.util.List;
import java.util.function.UnaryOperator;
public class PriceCalculatedEvent extends Event {
private static final HandlerList handlers = new HandlerList();
private final @Nullable Player player;
private final String shopId;
private final String productId;
private final double rustBasePrice;
private volatile double finalPrice;
private final List<String> modificationLog = new ArrayList<>(4);
public PriceCalculatedEvent(@Nullable Player player, @NotNull String shopId, @NotNull String productId, double calculated) {
super(false);
this.player = player;
this.shopId = shopId;
this.productId = productId;
this.rustBasePrice = calculated;
this.finalPrice = calculated;
this.modificationLog.add("EcoKernel-v0.8.9");
}
public @Nullable Player getPlayer() { return player; }
@NotNull
public String getShopId() { return shopId; }
@NotNull
public String getProductId() { return productId; }
public double getRustBasePrice() { return rustBasePrice; }
public double getFinalPrice() { return finalPrice; }
public synchronized void modifyPrice(@NotNull String source, @NotNull UnaryOperator<Double> modifier) {
double oldPrice = this.finalPrice;
this.finalPrice = Math.max(0.01, modifier.apply(this.finalPrice));
if (Double.compare(oldPrice, finalPrice) != 0) {
this.modificationLog.add(source);
}
}
public synchronized void setFinalPrice(double finalPrice, @NotNull String source) {
this.finalPrice = Math.max(0.01, finalPrice);
this.modificationLog.add(source + "(Overwrite)");
}
public synchronized boolean isModified() {
return modificationLog.size() > 1;
}
@NotNull
public synchronized List<String> getModificationLog() {
return Collections.unmodifiableList(new ArrayList<>(modificationLog));
}
@NotNull
public Component toComponent() {
String lastSource;
double currentFinal;
boolean modified;
synchronized (this) {
if (modificationLog.isEmpty()) {
lastSource = "Unknown";
} else {
lastSource = modificationLog.get(modificationLog.size() - 1);
}
currentFinal = this.finalPrice;
modified = modificationLog.size() > 1;
}
String template = modified
? "<gray>[EcoBridge] <white><product> <yellow><final> <dark_gray>(åŸ:<base>, æ”¹è‡ª:<source>)"
: "<gray>[EcoBridge] <white><product> <green><final> <dark_gray>(ç‰©ç†å®šä»·)";
return EcoBridge.getMiniMessage().deserialize(template,
Placeholder.unparsed("product", productId),
Placeholder.unparsed("final", String.format("%.2f", currentFinal)),
Placeholder.unparsed("base", String.format("%.2f", rustBasePrice)),
Placeholder.unparsed("source", lastSource)
);
}
@NotNull
@Override
public HandlerList getHandlers() { return handlers; }
public static HandlerList getHandlerList() { return handlers; }
}

==================================================
FILE: ecobridge-java\src\main\java\top\ellan\ecobridge\bridge\NativeBridge.java
==================================================

package top.ellan.ecobridge.bridge;
import top.ellan.ecobridge.EcoBridge;
import top.ellan.ecobridge.gen.*;
import top.ellan.ecobridge.util.LogUtil;
import java.lang.foreign.*;
import java.lang.invoke.MethodHandle;
import java.lang.invoke.VarHandle;
import static java.lang.foreign.ValueLayout.*;
public class NativeBridge {
private static final int EXPECTED_ABI_VERSION = 0x0009_0000;
public static final int CODE_NORMAL = 0;
public static final int CODE_WARNING_HIGH_RISK = 1;
public static final int CODE_BLOCK_REVERSE_FLOW = 2;
public static final int CODE_BLOCK_INJECTION = 3;
public static final int CODE_BLOCK_INSUFFICIENT_FUNDS = 4;
public static final int CODE_BLOCK_VELOCITY_LIMIT = 5;
private static MethodHandle getAbiVersionMH;
private static MethodHandle initDBMH;
private static MethodHandle getVersionMH;
private static MethodHandle getHealthStatsMH;
private static MethodHandle shutdownDBMH;
private static MethodHandle pushToDuckDBMH;
private static MethodHandle queryNeffVectorizedMH;
private static MethodHandle computePriceMH;
private static MethodHandle calculateEpsilonMH;
private static MethodHandle checkTransferMH;
private static MethodHandle computePidMH;
private static MethodHandle resetPidMH;
private static MethodHandle calcInflationMH;
private static MethodHandle calcStabilityMH;
private static MethodHandle calcDecayMH;
private static MethodHandle computeTierPriceMH;
private static MethodHandle computePriceBoundedMH;
private static MethodHandle computeBatchPricesMH;
public static final VarHandle VH_CTX_BASE_PRICE;
public static final VarHandle VH_CTX_CURR_AMT;
public static final VarHandle VH_CTX_INF_RATE;
public static final VarHandle VH_CTX_TIMESTAMP;
public static final VarHandle VH_CTX_PLAY_TIME;
public static final VarHandle VH_CTX_TIMEZONE_OFFSET;
public static final VarHandle VH_CTX_NEWBIE_MASK;
public static final VarHandle VH_CTX_MARKET_HEAT;
public static final VarHandle VH_CTX_ECO_SAT;
public static final VarHandle VH_CFG_LAMBDA;
public static final VarHandle VH_CFG_VOLATILITY;
public static final VarHandle VH_CFG_S_AMP;
public static final VarHandle VH_CFG_W_MULT;
public static final VarHandle VH_CFG_N_PROT;
public static final VarHandle VH_CFG_W_SEASONAL;
public static final VarHandle VH_CFG_W_WEEKEND;
public static final VarHandle VH_CFG_W_NEWBIE;
public static final VarHandle VH_CFG_W_INFLATION;
public static final VarHandle VH_TCTX_ACTIVITY_SCORE;
public static final VarHandle VH_TCTX_VELOCITY;
public static final VarHandle VH_RCFG_V_THRESHOLD;
private static final VarHandle VH_RES_TAX;
private static final VarHandle VH_RES_BLOCKED;
private static final VarHandle VH_RES_CODE;
static {
try {
GroupLayout ctxLayout = TradeContext.layout();
VH_CTX_BASE_PRICE = ctxLayout.varHandle(MemoryLayout.PathElement.groupElement("base_price"));
VH_CTX_CURR_AMT = ctxLayout.varHandle(MemoryLayout.PathElement.groupElement("current_amount"));
VH_CTX_INF_RATE = ctxLayout.varHandle(MemoryLayout.PathElement.groupElement("inflation_rate"));
VH_CTX_TIMESTAMP = ctxLayout.varHandle(MemoryLayout.PathElement.groupElement("current_timestamp"));
VH_CTX_PLAY_TIME = ctxLayout.varHandle(MemoryLayout.PathElement.groupElement("play_time_seconds"));
VH_CTX_TIMEZONE_OFFSET = ctxLayout.varHandle(MemoryLayout.PathElement.groupElement("timezone_offset"));
VH_CTX_NEWBIE_MASK = ctxLayout.varHandle(MemoryLayout.PathElement.groupElement("newbie_mask"));
VH_CTX_MARKET_HEAT = ctxLayout.varHandle(MemoryLayout.PathElement.groupElement("market_heat"));
VH_CTX_ECO_SAT = ctxLayout.varHandle(MemoryLayout.PathElement.groupElement("eco_saturation"));
GroupLayout cfgLayout = MarketConfig.layout();
VH_CFG_LAMBDA = cfgLayout.varHandle(MemoryLayout.PathElement.groupElement("base_lambda"));
VH_CFG_VOLATILITY = cfgLayout.varHandle(MemoryLayout.PathElement.groupElement("volatility_factor"));
VH_CFG_S_AMP = cfgLayout.varHandle(MemoryLayout.PathElement.groupElement("seasonal_amplitude"));
VH_CFG_W_MULT = cfgLayout.varHandle(MemoryLayout.PathElement.groupElement("weekend_multiplier"));
VH_CFG_N_PROT = cfgLayout.varHandle(MemoryLayout.PathElement.groupElement("newbie_protection_rate"));
VH_CFG_W_SEASONAL = cfgLayout.varHandle(MemoryLayout.PathElement.groupElement("seasonal_weight"));
VH_CFG_W_WEEKEND = cfgLayout.varHandle(MemoryLayout.PathElement.groupElement("weekend_weight"));
VH_CFG_W_NEWBIE = cfgLayout.varHandle(MemoryLayout.PathElement.groupElement("newbie_weight"));
VH_CFG_W_INFLATION = cfgLayout.varHandle(MemoryLayout.PathElement.groupElement("inflation_weight"));
GroupLayout tCtxLayout = TransferContext.layout();
VH_TCTX_ACTIVITY_SCORE = tCtxLayout.varHandle(MemoryLayout.PathElement.groupElement("sender_activity_score"));
VH_TCTX_VELOCITY = tCtxLayout.varHandle(MemoryLayout.PathElement.groupElement("sender_velocity"));
GroupLayout rCfgLayout = RegulatorConfig.layout();
VH_RCFG_V_THRESHOLD = rCfgLayout.varHandle(MemoryLayout.PathElement.groupElement("velocity_threshold"));
GroupLayout resLayout = top.ellan.ecobridge.gen.TransferResult.layout();
VH_RES_TAX = resLayout.varHandle(MemoryLayout.PathElement.groupElement("final_tax"));
VH_RES_BLOCKED = resLayout.varHandle(MemoryLayout.PathElement.groupElement("is_blocked"));
VH_RES_CODE = resLayout.varHandle(MemoryLayout.PathElement.groupElement("warning_code"));
} catch (Exception e) {
throw new RuntimeException("Layout Initialization Failed", e);
}
}
public static void init(EcoBridge plugin) {
if (NativeLoader.isReady()) return;
try {
NativeLoader.load(plugin);
Linker linker = Linker.nativeLinker();
getAbiVersionMH = linker.downcallHandle(
findOrThrow("ecobridge_abi_version"),
FunctionDescriptor.of(JAVA_INT)
);
int nativeVersion = (int) getAbiVersionMH.invokeExact();
if (nativeVersion != EXPECTED_ABI_VERSION) {
throw new IllegalStateException(String.format("ABI Mismatch: Java=0x%08X, Native=0x%08X", EXPECTED_ABI_VERSION, nativeVersion));
}
initDBMH = linker.downcallHandle(findOrThrow("ecobridge_init_db"), FunctionDescriptor.of(JAVA_INT, ADDRESS));
getVersionMH = linker.downcallHandle(findOrThrow("ecobridge_version"), FunctionDescriptor.of(ADDRESS));
getHealthStatsMH = linker.downcallHandle(findOrThrow("ecobridge_get_health_stats"), FunctionDescriptor.ofVoid(ADDRESS, ADDRESS));
shutdownDBMH = linker.downcallHandle(findOrThrow("ecobridge_shutdown_db"), FunctionDescriptor.of(JAVA_INT));
pushToDuckDBMH = linker.downcallHandle(findOrThrow("ecobridge_log_to_duckdb"), FunctionDescriptor.ofVoid(JAVA_LONG, ADDRESS, JAVA_DOUBLE, JAVA_DOUBLE, ADDRESS));
queryNeffVectorizedMH = linker.downcallHandle(findOrThrow("ecobridge_query_neff_vectorized"), FunctionDescriptor.of(JAVA_DOUBLE, JAVA_LONG, JAVA_DOUBLE));
computePriceMH = linker.downcallHandle(findOrThrow("ecobridge_compute_price_humane"), FunctionDescriptor.of(JAVA_DOUBLE, JAVA_DOUBLE, JAVA_DOUBLE, JAVA_DOUBLE, JAVA_DOUBLE, JAVA_DOUBLE));
calculateEpsilonMH = linker.downcallHandle(findOrThrow("ecobridge_calculate_epsilon"), FunctionDescriptor.of(JAVA_DOUBLE, ADDRESS, ADDRESS));
checkTransferMH = linker.downcallHandle(
findOrThrow("ecobridge_compute_transfer_check"),
FunctionDescriptor.ofVoid(ADDRESS, ADDRESS, ADDRESS)
);
computePidMH = linker.downcallHandle(
findOrThrow("ecobridge_compute_pid_adjustment"),
FunctionDescriptor.of(JAVA_DOUBLE, ADDRESS, JAVA_DOUBLE, JAVA_DOUBLE, JAVA_DOUBLE, JAVA_DOUBLE, JAVA_DOUBLE)
);
resetPidMH = linker.downcallHandle(findOrThrow("ecobridge_reset_pid_state"), FunctionDescriptor.ofVoid(ADDRESS));
calcInflationMH = linker.downcallHandle(findOrThrow("ecobridge_calc_inflation"), FunctionDescriptor.of(JAVA_DOUBLE, JAVA_DOUBLE, JAVA_DOUBLE));
calcStabilityMH = linker.downcallHandle(findOrThrow("ecobridge_calc_stability"), FunctionDescriptor.of(JAVA_DOUBLE, JAVA_LONG, JAVA_LONG));
calcDecayMH = linker.downcallHandle(findOrThrow("ecobridge_calc_decay"), FunctionDescriptor.of(JAVA_DOUBLE, JAVA_DOUBLE, JAVA_DOUBLE));
computeTierPriceMH = linker.downcallHandle(findOrThrow("ecobridge_compute_tier_price"), FunctionDescriptor.of(JAVA_DOUBLE, JAVA_DOUBLE, JAVA_DOUBLE, JAVA_BOOLEAN));
computePriceBoundedMH = linker.downcallHandle(findOrThrow("ecobridge_compute_price_bounded"), FunctionDescriptor.of(JAVA_DOUBLE, JAVA_DOUBLE, JAVA_DOUBLE, JAVA_DOUBLE, JAVA_DOUBLE, JAVA_DOUBLE, JAVA_DOUBLE));
computeBatchPricesMH = linker.downcallHandle(
findOrThrow("ecobridge_compute_batch_prices"),
FunctionDescriptor.ofVoid(
JAVA_LONG,
JAVA_DOUBLE,
ADDRESS,
ADDRESS,
ADDRESS,
ADDRESS,
ADDRESS
)
);
try (Arena arena = Arena.ofConfined()) {
String dataPath = plugin.getDataFolder().getAbsolutePath();
int result = (int) initDBMH.invokeExact(arena.allocateFrom(dataPath));
if (result != 0 && result != -3) {
throw new IllegalStateException("Rust DB Init Failed: " + result);
}
}
MemorySegment v = (MemorySegment) getVersionMH.invokeExact();
LogUtil.info("<green>Native engine loaded: " + v.getString(0));
} catch (Throwable e) {
LogUtil.error("Native Fatal Error", e);
shutdown();
}
}
private static MemorySegment findOrThrow(String name) {
return NativeLoader.findSymbol(name)
.orElseThrow(() -> new UnsatisfiedLinkError("Symbol not found: " + name));
}
public static boolean isLoaded() {
return NativeLoader.isReady();
}
public static void shutdown() {
if (NativeLoader.isReady()) {
if (shutdownDBMH != null) {
try { shutdownDBMH.invokeExact(); } catch (Throwable t) {}
}
NativeLoader.unload();
}
}
public static double calcInflation(double heat, double m1) {
if (!isLoaded()) return 0.0;
try { return (double) calcInflationMH.invokeExact(heat, m1); } catch (Throwable t) { return 0.0; }
}
public static double calcStability(long lastTs, long currTs) {
if (!isLoaded()) return 1.0;
try { return (double) calcStabilityMH.invokeExact(lastTs, currTs); } catch (Throwable t) { return 1.0; }
}
public static double calcDecay(double heat, double rate) {
if (!isLoaded()) return 0.0;
try { return (double) calcDecayMH.invokeExact(heat, rate); } catch (Throwable t) { return 0.0; }
}
public static double computeTierPrice(double base, double qty, boolean isSell) {
if (!isLoaded()) return base;
try { return (double) computeTierPriceMH.invokeExact(base, qty, isSell); } catch (Throwable t) { return base; }
}
public static double computePriceBounded(double base, double neff, double amt, double lambda, double eps, double histAvg) {
if (!isLoaded()) return base;
try { return (double) computePriceBoundedMH.invokeExact(base, neff, amt, lambda, eps, histAvg); } catch (Throwable t) { return base; }
}
public static void getHealthStats(MemorySegment outTotal, MemorySegment outDropped) {
if (!isLoaded()) return;
try { getHealthStatsMH.invokeExact(outTotal, outDropped); } catch (Throwable t) {}
}
public static void resetPidState(MemorySegment pidPtr) {
if (!isLoaded()) return;
try { resetPidMH.invokeExact(pidPtr); } catch (Throwable t) { LogUtil.error("PID reset failed", t); }
}
public static double computePrice(double base, double nEff, double amount, double lambda, double epsilon) {
if (!isLoaded()) return base;
try { return (double) computePriceMH.invokeExact(base, nEff, amount, lambda, epsilon); } catch (Throwable t) { return base; }
}
public static double queryNeffVectorized(long now, double tau) {
if (!isLoaded()) return 0.0;
try { return (double) queryNeffVectorizedMH.invokeExact(now, tau); } catch (Throwable t) { return 0.0; }
}
public static void pushToDuckDB(long ts, String uuid, double amount, double bal, String meta) {
if (!isLoaded()) return;
try (Arena arena = Arena.ofConfined()) {
pushToDuckDBMH.invokeExact(ts, arena.allocateFrom(uuid), amount, bal, arena.allocateFrom(meta));
} catch (Throwable t) { LogUtil.error("DuckDB log failed", t); }
}
public static double calculateEpsilon(MemorySegment tradeCtx, MemorySegment marketCfg) {
if (!isLoaded()) return 1.0;
try { return (double) calculateEpsilonMH.invokeExact(tradeCtx, marketCfg); } catch (Throwable t) { return 1.0; }
}
public static TransferResult checkTransfer(MemorySegment ctxSeg, MemorySegment cfgSeg) {
if (!isLoaded()) return new TransferResult(0.0, true, -1);
try (Arena arena = Arena.ofConfined()) {
MemorySegment resultSeg = arena.allocate(Layouts.TRANSFER_RESULT);
checkTransferMH.invokeExact(resultSeg, ctxSeg, cfgSeg);
double tax = (double) VH_RES_TAX.get(resultSeg);
boolean isBlocked = ((int) VH_RES_BLOCKED.get(resultSeg)) != 0;
int warningCode = (int) VH_RES_CODE.get(resultSeg);
return new TransferResult(tax, isBlocked, warningCode);
} catch (Throwable t) {
LogUtil.error("checkTransfer FFI è°ƒç”¨å¼‚å¸¸", t);
return new TransferResult(0.0, true, -2);
}
}
public static double computePidAdjustment(MemorySegment pidPtr, double target, double current, double dt, double inflation, double heat) {
if (!isLoaded()) return 0.0;
try {
return (double) computePidMH.invokeExact(pidPtr, target, current, dt, inflation, heat);
} catch (Throwable t) {
return 0.0;
}
}
public static void computeBatchPrices(
long count,
double neff,
MemorySegment ctxArr,
MemorySegment cfgArr,
MemorySegment histAvgs,
MemorySegment lambdas,
MemorySegment results
) {
if (!isLoaded()) return;
try {
computeBatchPricesMH.invokeExact(count, neff, ctxArr, cfgArr, histAvgs, lambdas, results);
} catch (Throwable t) {
LogUtil.error("SIMD æ‰¹é‡è®¡ç®—å¤±è´¥", t);
}
}
public static class Layouts {
public static final GroupLayout TRADE_CONTEXT = TradeContext.layout();
public static final GroupLayout TRANSFER_CONTEXT = TransferContext.layout();
public static final GroupLayout MARKET_CONFIG = MarketConfig.layout();
public static final GroupLayout REGULATOR_CONFIG = RegulatorConfig.layout();
public static final GroupLayout PID_STATE = PidState.layout();
public static final GroupLayout TRANSFER_RESULT = top.ellan.ecobridge.gen.TransferResult.layout();
}
public record TransferResult(double tax, boolean isBlocked, int warningCode) {}
}

==================================================
FILE: ecobridge-java\src\main\java\top\ellan\ecobridge\bridge\NativeContextBuilder.java
==================================================

package top.ellan.ecobridge.bridge;
import top.ellan.ecobridge.manager.EconomyManager;
import top.ellan.ecobridge.util.HolidayManager;
import java.lang.foreign.MemorySegment;
import java.time.OffsetDateTime;
public class NativeContextBuilder {
public static void fillGlobalContext(MemorySegment ctxSeg, long now) {
NativeBridge.VH_CTX_TIMESTAMP.set(ctxSeg, 0L, now);
double inflation = EconomyManager.getInstance().getInflationRate();
NativeBridge.VH_CTX_INF_RATE.set(ctxSeg, 0L, inflation);
long offset = OffsetDateTime.now().getOffset().getTotalSeconds();
NativeBridge.VH_CTX_TIMEZONE_OFFSET.set(ctxSeg, 0L, offset);
int mask = (HolidayManager.isTodayHoliday() ? 1 : 0) << 1;
NativeBridge.VH_CTX_NEWBIE_MASK.set(ctxSeg, 0L, mask);
NativeBridge.VH_CTX_PLAY_TIME.set(ctxSeg, 0L, 0L);
NativeBridge.VH_CTX_CURR_AMT.set(ctxSeg, 0L, 0.0);
}
public static void updateItemContext(MemorySegment ctxSeg, double basePrice) {
NativeBridge.VH_CTX_BASE_PRICE.set(ctxSeg, 0L, basePrice);
}
}

==================================================
FILE: ecobridge-java\src\main\java\top\ellan\ecobridge\bridge\NativeLoader.java
==================================================

package top.ellan.ecobridge.bridge;
import top.ellan.ecobridge.EcoBridge;
import top.ellan.ecobridge.util.LogUtil;
import java.io.ByteArrayInputStream;
import java.io.IOException;
import java.io.InputStream;
import java.lang.foreign.Arena;
import java.lang.foreign.MemorySegment;
import java.lang.foreign.SymbolLookup;
import java.nio.file.Files;
import java.nio.file.Path;
import java.nio.file.StandardCopyOption;
import java.security.MessageDigest;
import java.util.Optional;
public class NativeLoader {
private static final String LIB_NAME = "ecobridge_rust";
private static Arena globalArena;
private static SymbolLookup symbolLookup;
private static volatile boolean isReady = false;
public static synchronized void load(EcoBridge plugin) {
if (isReady) return;
try {
Path libPath = extractLibrary(plugin);
globalArena = Arena.ofShared();
symbolLookup = SymbolLookup.libraryLookup(libPath, globalArena);
isReady = true;
LogUtil.debug("NativeLoader: å…±äº«å†…å­˜åŸŸå·²åˆå§‹åŒ–ï¼ŒNative ç¬¦å·è¡¨å·²å°±ç»ªã€‚");
} catch (Throwable e) {
throw new RuntimeException("æ— æ³•åŠ è½½ Native åº“: " + e.getMessage(), e);
}
}
public static synchronized void unload() {
if (!isReady) return;
try {
if (globalArena != null && globalArena.scope().isAlive()) {
globalArena.close();
LogUtil.debug("NativeLoader: å…±äº«å†…å­˜åŸŸå·²å®‰å…¨å…³é—­ã€‚");
}
} catch (Throwable e) {
LogUtil.error("NativeLoader: å†…å­˜åŸŸå…³é—­å¤±è´¥", e);
} finally {
globalArena = null;
symbolLookup = null;
isReady = false;
}
}
public static Optional<MemorySegment> findSymbol(String name) {
if (!isReady || symbolLookup == null) return Optional.empty();
try {
return symbolLookup.find(name);
} catch (Throwable t) {
return Optional.empty();
}
}
public static boolean isReady() {
return isReady;
}
private static Path extractLibrary(EcoBridge plugin) throws IOException {
String os = System.getProperty("os.name").toLowerCase();
String suffix = os.contains("win") ? ".dll" : (os.contains("mac") ? ".dylib" : ".so");
String name = (os.contains("win") ? "" : "lib") + LIB_NAME + suffix;
Path target = plugin.getDataFolder().toPath().resolve("natives").resolve(name);
byte[] resourceBytes;
try (InputStream in = plugin.getResource(name)) {
if (in == null) throw new IOException("Native lib not found in jar: " + name);
resourceBytes = in.readAllBytes();
}
String newHash = calculateHash(resourceBytes);
if (Files.exists(target)) {
try {
byte[] existingBytes = Files.readAllBytes(target);
String oldHash = calculateHash(existingBytes);
if (newHash.equals(oldHash)) {
return target;
}
} catch (IOException e) {
LogUtil.warn("æ ¡éªŒç°æœ‰ Native åº“å¤±è´¥ï¼Œå‡†å¤‡è¦†ç›–: " + e.getMessage());
}
}
Files.createDirectories(target.getParent());
try (ByteArrayInputStream bin = new ByteArrayInputStream(resourceBytes)) {
Files.copy(bin, target, StandardCopyOption.REPLACE_EXISTING);
}
LogUtil.info("å·²æå– Native åº“è‡³: " + target + " (Hash: " + newHash.substring(0, 8) + ")");
return target;
}
private static String calculateHash(byte[] data) {
try {
MessageDigest md = MessageDigest.getInstance("SHA-256");
byte[] hash = md.digest(data);
StringBuilder sb = new StringBuilder();
for (byte b : hash) sb.append(String.format("%02x", b));
return sb.toString();
} catch (Exception e) {
throw new RuntimeException("SHA-256 algorithm not found", e);
}
}
}

==================================================
FILE: ecobridge-java\src\main\java\top\ellan\ecobridge\cache\HotDataCache.java
==================================================

package top.ellan.ecobridge.cache;
import com.github.benmanes.caffeine.cache.Cache;
import com.github.benmanes.caffeine.cache.Caffeine;
import com.github.benmanes.caffeine.cache.RemovalCause;
import org.bukkit.Bukkit;
import org.bukkit.entity.Player;
import top.ellan.ecobridge.EcoBridge;
import top.ellan.ecobridge.database.TransactionDao;
import top.ellan.ecobridge.util.LogUtil;
import java.time.Duration;
import java.util.UUID;
import java.util.concurrent.CompletableFuture;
import java.util.concurrent.atomic.AtomicLong;
public class HotDataCache {
private static final Cache<UUID, PlayerData> CACHE = Caffeine.newBuilder()
.maximumSize(2000)
.expireAfterAccess(Duration.ofHours(2))
.removalListener((UUID uuid, PlayerData data, RemovalCause cause) -> {
if (data == null) return;
if (cause != RemovalCause.REPLACED) {
saveAsync(uuid, data, "CACHE_" + cause.name());
}
})
.build();
public static void load(UUID uuid) {
CompletableFuture.runAsync(() -> {
try {
PlayerData data = TransactionDao.loadPlayerData(uuid);
Bukkit.getScheduler().runTask(EcoBridge.getInstance(), () -> {
Player p = Bukkit.getPlayer(uuid);
if (p != null && p.isOnline()) {
CACHE.put(uuid, data);
LogUtil.debug("å·²ä¸ºç©å®¶ " + p.getName() + " å®Œæˆæ•°æ®æŒ‚è½½ (Version: " + data.getVersion() + ")");
} else {
LogUtil.debug("æ‹¦æˆªåˆ°è¿‡æ—¶åŠ è½½å›è°ƒ (" + uuid + ")ï¼Œç©å®¶å·²ç¦»çº¿ã€‚");
}
});
} catch (Exception e) {
LogUtil.error("ç©å®¶ " + uuid + " æ•°æ®çƒ­åŠ è½½å‘ç”Ÿè‡´å‘½é”™è¯¯ï¼", e);
}
}, EcoBridge.getInstance().getVirtualExecutor());
}
public static PlayerData get(UUID uuid) {
return CACHE.getIfPresent(uuid);
}
public static void invalidate(UUID uuid) {
CACHE.invalidate(uuid);
}
private static void saveAsync(UUID uuid, PlayerData data, String reason) {
EcoBridge.getInstance().getVirtualExecutor().execute(() -> {
TransactionDao.updateBalanceBlocking(uuid, data.getBalance());
if (LogUtil.isDebugEnabled()) {
LogUtil.debug("æ•°æ®å†™å›æˆåŠŸ [" + reason + "]: " + uuid + " (Balance: " + data.getBalance() + ")");
}
});
}
public static void saveAllSync() {
LogUtil.info("æ­£åœ¨æ‰§è¡Œå…³æœºå‰çš„å…¨é‡çƒ­æ•°æ®å¼ºåˆ¶åŒæ­¥...");
var snapshotMap = CACHE.asMap();
for (var entry : snapshotMap.entrySet()) {
TransactionDao.updateBalanceBlocking(entry.getKey(), entry.getValue().getBalance());
}
CACHE.invalidateAll();
LogUtil.info("æ‰€æœ‰æ´»è·ƒæ•°æ®å·²å®‰å…¨è½ç›˜ã€‚");
}
public static class PlayerData {
private final UUID uuid;
private final AtomicLong balanceBits;
private volatile long version;
public PlayerData(UUID uuid, double initialBalance, long version) {
this.uuid = uuid;
this.balanceBits = new AtomicLong(Double.doubleToRawLongBits(initialBalance));
this.version = version;
}
public UUID getUuid() { return uuid; }
public double getBalance() {
return Double.longBitsToDouble(balanceBits.get());
}
public long getVersion() {
return version;
}
public void setVersion(long version) {
this.version = version;
}
public void updateFromTruth(double newBalance) {
balanceBits.set(Double.doubleToRawLongBits(newBalance));
}
public void setBalance(double newBalance) {
updateFromTruth(newBalance);
}
}
}

==================================================
FILE: ecobridge-java\src\main\java\top\ellan\ecobridge\collector\ActivityCollector.java
==================================================

package top.ellan.ecobridge.collector;
import net.kyori.adventure.text.Component;
import net.kyori.adventure.text.minimessage.MiniMessage;
import net.kyori.adventure.text.minimessage.tag.resolver.Placeholder;
import org.bukkit.Bukkit;
import org.bukkit.Statistic;
import org.bukkit.entity.Player;
import top.ellan.ecobridge.EcoBridge;
import java.util.concurrent.CompletableFuture;
public class ActivityCollector {
private static final long TICKS_PER_SECOND = 20L;
private static final double SECONDS_PER_HOUR = 3600.0;
public static ActivitySnapshot capture(Player player, double newbieThresholdHours) {
if (!Bukkit.isPrimaryThread()) {
EcoBridge.getInstance().getLogger().warning(
"[çº¿ç¨‹å®‰å…¨æ‹¦æˆª] ActivityCollector.capture æ£€æµ‹åˆ°éæ³•å¼‚æ­¥è°ƒç”¨ï¼" +
"è°ƒç”¨æ–¹å¿…é¡»åœ¨ä¸»çº¿ç¨‹æ‰§è¡Œã€‚ç©å®¶: " + player.getName()
);
return new ActivitySnapshot(360000L, 100.0, 0);
}
long totalTicks = player.getStatistic(Statistic.PLAY_ONE_MINUTE);
long totalSeconds = totalTicks / TICKS_PER_SECOND;
double hours = (double) totalSeconds / SECONDS_PER_HOUR;
int newbieBit = (hours < newbieThresholdHours) ? 1 : 0;
return new ActivitySnapshot(totalSeconds, hours, newbieBit);
}
public static CompletableFuture<ActivitySnapshot> captureAsync(Player player, double newbieThresholdHours) {
if (Bukkit.isPrimaryThread()) {
return CompletableFuture.completedFuture(capture(player, newbieThresholdHours));
}
CompletableFuture<ActivitySnapshot> future = new CompletableFuture<>();
Bukkit.getScheduler().runTask(EcoBridge.getInstance(), () -> {
try {
future.complete(capture(player, newbieThresholdHours));
} catch (Exception e) {
future.completeExceptionally(e);
}
});
return future;
}
public record ActivitySnapshot(long seconds, double hours, int isNewbie) {}
public static Component toComponent(Player player) {
var snapshot = capture(player, 48.0);
String color = snapshot.hours() < 10 ? "<red>" : (snapshot.hours() < 50 ? "<yellow>" : "<green>");
double displayHours = Math.floor(snapshot.hours() * 10) / 10.0;
return MiniMessage.miniMessage().deserialize(
"<gray>æ´»è·ƒç­‰çº§: " + color + "<hours>h <dark_gray>(<sec>s) <gray>æ–°æ‰‹çŠ¶æ€: <newbie>",
Placeholder.unparsed("hours", String.valueOf(displayHours)),
Placeholder.unparsed("sec", String.valueOf(snapshot.seconds())),
Placeholder.unparsed("newbie", (snapshot.isNewbie() & 1) == 1 ? "<yellow>æ˜¯" : "<green>å¦")
);
}
}

==================================================
FILE: ecobridge-java\src\main\java\top\ellan\ecobridge\command\TransferCommand.java
==================================================

package top.ellan.ecobridge.command;
import net.kyori.adventure.text.Component;
import org.bukkit.Bukkit;
import org.bukkit.command.Command;
import org.bukkit.command.CommandSender;
import org.bukkit.command.TabExecutor;
import org.bukkit.entity.Player;
import org.jetbrains.annotations.NotNull;
import org.jetbrains.annotations.Nullable;
import top.ellan.ecobridge.EcoBridge;
import top.ellan.ecobridge.manager.TransferManager;
import java.util.Collections;
import java.util.List;
import java.util.stream.Collectors;
public class TransferCommand implements TabExecutor {
private static final String PERMISSION = "ecobridge.command.transfer";
@Override
public boolean onCommand(@NotNull CommandSender sender, @NotNull Command command, @NotNull String label, @NotNull String[] args) {
if (!(sender instanceof Player player)) {
sender.sendMessage(Component.text("è¯¥æŒ‡ä»¤ä»…é™ç©å®¶åœ¨æ¸¸æˆå†…æ‰§è¡Œã€‚"));
return true;
}
if (!player.hasPermission(PERMISSION)) {
player.sendMessage(EcoBridge.getMiniMessage().deserialize("<red>æƒé™ä¸è¶³ï¼ <gray>æ‚¨éœ€è¦: <yellow>" + PERMISSION));
return true;
}
if (args.length < 2) {
sendUsage(player, label);
return true;
}
Player target = Bukkit.getPlayer(args[0]);
if (target == null || !target.isOnline()) {
player.sendMessage(EcoBridge.getMiniMessage().deserialize("<red>é”™è¯¯: <gray>ç›®æ ‡ç©å®¶ <yellow>" + args[0] + " <gray>ä¸åœ¨çº¿ã€‚"));
return true;
}
if (player.getUniqueId().equals(target.getUniqueId())) {
player.sendMessage(EcoBridge.getMiniMessage().deserialize("<red>ç¦æ­¢æ“ä½œ: <gray>æ‚¨æ— æ³•å‘è‡ªå·±å‘èµ·è½¬è´¦ã€‚"));
return true;
}
double amount;
try {
amount = Double.parseDouble(args[1]);
if (amount < 0.01) {
player.sendMessage(EcoBridge.getMiniMessage().deserialize("<red>é‡‘é¢å¼‚å¸¸: <gray>è½¬è´¦é‡‘é¢å¿…é¡»å¤§äº <yellow>0.01"));
return true;
}
} catch (NumberFormatException e) {
player.sendMessage(EcoBridge.getMiniMessage().deserialize("<red>éæ³•è¾“å…¥: <gray>è¯·è¾“å…¥æ­£ç¡®çš„æ•°å­—é‡‘é¢ã€‚"));
return true;
}
player.sendMessage(EcoBridge.getMiniMessage().deserialize(
"<gray>[<blue>EcoBridge</blue>] <italic>æ­£åœ¨å¯åŠ¨æ™ºèƒ½å®¡è®¡ï¼Œè¯·ç¨å€™...</italic>"
));
TransferManager.getInstance().initiateTransfer(player, target, amount);
return true;
}
@Override
public @Nullable List<String> onTabComplete(@NotNull CommandSender sender, @NotNull Command command, @NotNull String alias, @NotNull String[] args) {
if (args.length == 1) {
String input = args[0].toLowerCase();
return Bukkit.getOnlinePlayers().stream()
.map(Player::getName)
.filter(name -> name.toLowerCase().startsWith(input))
.collect(Collectors.toList());
}
if (args.length == 2) {
return List.of("10", "100", "1000");
}
return Collections.emptyList();
}
private void sendUsage(Player player, String label) {
player.sendMessage(EcoBridge.getMiniMessage().deserialize(
"<gradient:aqua:blue><b>EcoBridge æ™ºèƒ½ç»“ç®—ç³»ç»Ÿ</b></gradient>\n" +
"<gray>ç”¨æ³•: <yellow>/" + label + " <ç©å®¶> <é‡‘é¢>"
));
}
}

==================================================
FILE: ecobridge-java\src\main\java\top\ellan\ecobridge\database\DatabaseManager.java
==================================================

package top.ellan.ecobridge.database;
import com.zaxxer.hikari.HikariConfig;
import com.zaxxer.hikari.HikariDataSource;
import top.ellan.ecobridge.EcoBridge;
import top.ellan.ecobridge.util.LogUtil;
import java.sql.Connection;
import java.sql.SQLException;
import java.sql.Statement;
import java.util.concurrent.ExecutorService;
import java.util.concurrent.Executors;
import java.util.concurrent.TimeUnit;
public class DatabaseManager {
private static HikariDataSource dataSource;
private static ExecutorService dbExecutor;
public static synchronized void init() {
if (dataSource != null || dbExecutor != null) {
close();
}
var plugin = EcoBridge.getInstance();
var config = plugin.getConfig();
dbExecutor = Executors.newVirtualThreadPerTaskExecutor();
HikariConfig hikari = new HikariConfig();
String host = config.getString("database.host", "localhost");
int port = config.getInt("database.port", 3306);
String dbName = config.getString("database.database", "ecobridge");
String user = config.getString("database.username", "root");
String pass = config.getString("database.password", "");
String jdbcUrl = String.format(
"jdbc:mysql:
host, port, dbName
);
hikari.setJdbcUrl(jdbcUrl);
hikari.setUsername(user);
hikari.setPassword(pass);
hikari.setMaximumPoolSize(config.getInt("database.pool-size", 15));
hikari.setConnectionTimeout(5000);
hikari.setIdleTimeout(600000);
hikari.setMaxLifetime(1800000);
try {
dataSource = new HikariDataSource(hikari);
createTables();
LogUtil.info("<green>SQL æ•°æ®æºå·²å°±ç»ª (HikariCP + VirtualThreads)ã€‚");
} catch (Exception e) {
LogUtil.error("æ•°æ®åº“åˆå§‹åŒ–å¤±è´¥ï¼è¯·æ£€æŸ¥é…ç½®ã€‚", e);
}
}
public static Connection getConnection() throws SQLException {
if (dataSource == null) {
throw new SQLException("DataSource is not initialized");
}
return dataSource.getConnection();
}
public static ExecutorService getExecutor() {
return dbExecutor;
}
public static boolean isConnected() {
return dataSource != null && !dataSource.isClosed();
}
public static synchronized void close() {
LogUtil.info("æ­£åœ¨é‡Šæ”¾ SQL èµ„æº...");
if (dbExecutor != null) {
dbExecutor.shutdown();
try {
if (!dbExecutor.awaitTermination(5, TimeUnit.SECONDS)) {
dbExecutor.shutdownNow();
}
} catch (InterruptedException e) {
dbExecutor.shutdownNow();
Thread.currentThread().interrupt();
}
dbExecutor = null;
}
if (dataSource != null) {
if (!dataSource.isClosed()) {
dataSource.close();
}
dataSource = null;
}
}
private static void createTables() {
if (dataSource == null) return;
String sqlSales = """
CREATE TABLE IF NOT EXISTS ecobridge_sales (
id BIGINT AUTO_INCREMENT PRIMARY KEY,
player_uuid CHAR(36) NOT NULL,
product_id VARCHAR(64) NOT NULL,
amount DOUBLE NOT NULL,
timestamp BIGINT NOT NULL,
INDEX idx_history (product_id, timestamp)
) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4;
""";
String sqlPlayers = """
CREATE TABLE IF NOT EXISTS ecobridge_players (
uuid CHAR(36) PRIMARY KEY,
balance DOUBLE NOT NULL DEFAULT 0.0,
version BIGINT NOT NULL DEFAULT 0,
last_updated BIGINT NOT NULL
) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4;
""";
try (Connection conn = getConnection(); Statement stmt = conn.createStatement()) {
stmt.execute(sqlSales);
stmt.execute(sqlPlayers);
} catch (SQLException e) {
LogUtil.error("DDL æ‰§è¡Œå¤±è´¥ï¼Œè¯·æ£€æŸ¥æ•°æ®åº“æƒé™æˆ–è¡¨ç»“æ„ã€‚", e);
}
}
}

==================================================
FILE: ecobridge-java\src\main\java\top\ellan\ecobridge\database\TransactionDao.java
==================================================

package top.ellan.ecobridge.database;
import top.ellan.ecobridge.cache.HotDataCache;
import top.ellan.ecobridge.cache.HotDataCache.PlayerData;
import top.ellan.ecobridge.model.SaleRecord;
import top.ellan.ecobridge.util.LogUtil;
import java.sql.Connection;
import java.sql.PreparedStatement;
import java.sql.ResultSet;
import java.sql.SQLException;
import java.util.ArrayList;
import java.util.List;
import java.util.UUID;
import java.util.concurrent.TimeUnit;
public class TransactionDao {
public static PlayerData loadPlayerData(UUID uuid) {
if (!DatabaseManager.isConnected()) {
return new PlayerData(uuid, 0.0, 0);
}
String sql = "SELECT balance, version FROM ecobridge_players WHERE uuid = ?";
try (Connection conn = DatabaseManager.getConnection();
PreparedStatement pstmt = conn.prepareStatement(sql)) {
pstmt.setString(1, uuid.toString());
try (ResultSet rs = pstmt.executeQuery()) {
if (rs.next()) {
return new PlayerData(uuid, rs.getDouble("balance"), rs.getLong("version"));
}
}
} catch (SQLException e) {
LogUtil.error("è¯»å–ç©å®¶ SQL å¤±è´¥: " + uuid, e);
}
return new PlayerData(uuid, 0.0, 0);
}
public static void updateBalance(UUID uuid, double balance) {
if (DatabaseManager.getExecutor() == null) return;
DatabaseManager.getExecutor().execute(() -> updateBalanceBlocking(uuid, balance));
}
public static void updateBalanceBlocking(UUID uuid, double balance) {
if (!DatabaseManager.isConnected()) return;
String updateSql = "UPDATE ecobridge_players SET balance = ?, version = version + 1, last_updated = ? WHERE uuid = ? AND version = ?";
String insertSql = "INSERT IGNORE INTO ecobridge_players (uuid, balance, version, last_updated) VALUES (?, ?, 0, ?)";
long now = System.currentTimeMillis();
int maxRetries = 3;
SQLException lastEx = null;
for (int attempt = 1; attempt <= maxRetries; attempt++) {
PlayerData cached = HotDataCache.get(uuid);
long currentVersion = (cached != null) ? cached.getVersion() : -1;
try (Connection conn = DatabaseManager.getConnection()) {
if (currentVersion == -1) {
try (PreparedStatement ipstmt = conn.prepareStatement(insertSql)) {
ipstmt.setString(1, uuid.toString());
ipstmt.setDouble(2, balance);
ipstmt.setLong(3, now);
if (ipstmt.executeUpdate() > 0) return;
}
}
try (PreparedStatement upstmt = conn.prepareStatement(updateSql)) {
upstmt.setDouble(1, balance);
upstmt.setLong(2, now);
upstmt.setString(3, uuid.toString());
upstmt.setLong(4, Math.max(0, currentVersion));
int affected = upstmt.executeUpdate();
if (affected > 0) {
if (cached != null) cached.setVersion(currentVersion + 1);
return;
}
}
PlayerData fresh = loadPlayerData(uuid);
if (cached != null) cached.setVersion(fresh.getVersion());
if (attempt < maxRetries) {
Thread.sleep(50L * attempt);
}
} catch (SQLException e) {
lastEx = e;
if (isFatalError(e)) break;
try { Thread.sleep(100L * attempt); } catch (InterruptedException ie) { break; }
} catch (InterruptedException e) {
Thread.currentThread().interrupt();
break;
}
}
LogUtil.error("æŒä¹…åŒ–ç©å®¶ä½™é¢æœ€ç»ˆå¤±è´¥ (ä¹è§‚é”å†²çª/é‡è¯•è€—å°½): " + uuid, lastEx);
}
public static void saveSaleAsync(UUID uuid, String productId, double amount) {
if (DatabaseManager.getExecutor() == null) return;
DatabaseManager.getExecutor().execute(() -> {
String sql = "INSERT INTO ecobridge_sales(player_uuid, product_id, amount, timestamp) VALUES(?,?,?,?)";
try (Connection conn = DatabaseManager.getConnection();
PreparedStatement pstmt = conn.prepareStatement(sql)) {
pstmt.setString(1, uuid != null ? uuid.toString() : "SYSTEM");
pstmt.setString(2, productId);
pstmt.setDouble(3, amount);
pstmt.setLong(4, System.currentTimeMillis());
pstmt.executeUpdate();
} catch (SQLException e) {
LogUtil.error("å†™å…¥ SQL äº¤æ˜“å†å²å¤±è´¥: " + productId, e);
}
});
}
public static double get7DayAverage(String productId) {
if (!DatabaseManager.isConnected()) return 0.0;
String sql = "SELECT AVG(ABS(amount)) FROM ecobridge_sales WHERE product_id = ? AND timestamp > ?";
long cutoff = System.currentTimeMillis() - TimeUnit.DAYS.toMillis(7);
try (Connection conn = DatabaseManager.getConnection();
PreparedStatement pstmt = conn.prepareStatement(sql)) {
pstmt.setString(1, productId);
pstmt.setLong(2, cutoff);
try (ResultSet rs = pstmt.executeQuery()) {
if (rs.next()) {
return rs.getDouble(1);
}
}
} catch (SQLException e) {
LogUtil.error("æ»‘åŠ¨åœ°æ¿æ•°æ®å›æº¯å¼‚å¸¸: " + productId, e);
}
return 0.0;
}
public static List<SaleRecord> getProductHistory(String productId, int daysLimit) {
if (!DatabaseManager.isConnected()) return new ArrayList<>();
List<SaleRecord> history = new ArrayList<>();
long cutoff = System.currentTimeMillis() - TimeUnit.DAYS.toMillis(daysLimit);
String sql = "SELECT timestamp, amount FROM ecobridge_sales WHERE product_id = ? AND timestamp > ? " +
"ORDER BY timestamp DESC LIMIT 5000";
try (Connection conn = DatabaseManager.getConnection();
PreparedStatement pstmt = conn.prepareStatement(sql)) {
pstmt.setString(1, productId);
pstmt.setLong(2, cutoff);
try (ResultSet rs = pstmt.executeQuery()) {
while (rs.next()) {
history.add(new SaleRecord(rs.getLong("timestamp"), rs.getDouble("amount")));
}
}
} catch (SQLException e) {
LogUtil.error("å›æº¯å•†å“ SQL å†·æ•°æ®å¼‚å¸¸: " + productId, e);
}
return history;
}
private static boolean isFatalError(SQLException e) {
String state = e.getSQLState();
if (state == null) return false;
return state.startsWith("42") || state.startsWith("23");
}
}

==================================================
FILE: ecobridge-java\src\main\java\top\ellan\ecobridge\engine\PriceComputeEngine.java
==================================================

package top.ellan.ecobridge.engine;
import org.bukkit.configuration.ConfigurationSection;
import org.bukkit.configuration.file.FileConfiguration;
import top.ellan.ecobridge.EcoBridge;
import top.ellan.ecobridge.bridge.NativeBridge;
import top.ellan.ecobridge.bridge.NativeBridge.Layouts;
import top.ellan.ecobridge.bridge.NativeContextBuilder;
import top.ellan.ecobridge.database.TransactionDao;
import top.ellan.ecobridge.util.LogUtil;
import java.lang.foreign.Arena;
import java.lang.foreign.MemoryLayout;
import java.lang.foreign.MemorySegment;
import java.lang.foreign.SequenceLayout;
import java.lang.invoke.VarHandle;
import java.util.*;
import java.util.concurrent.CompletableFuture;
import java.util.stream.Collectors;
import static java.lang.foreign.ValueLayout.JAVA_DOUBLE;
public class PriceComputeEngine {
private record ItemMeta(
String key,
String shopId,
String productId,
double basePrice,
double lambda,
int index
) {}
public static Map<String, Double> computeSnapshot(EcoBridge plugin, double configTau, double macroLambda) {
Map<String, Double> resultMap = new HashMap<>();
if (!NativeBridge.isLoaded()) {
LogUtil.warn("Native engine not loaded, skipping price computation");
return resultMap;
}
FileConfiguration config = plugin.getConfig();
ConfigurationSection itemSection = config.getConfigurationSection("item-settings");
if (itemSection == null) {
LogUtil.warn("No item-settings found in config");
return resultMap;
}
List<ItemMeta> activeItems = new ArrayList<>();
int idx = 0;
for (String shopId : itemSection.getKeys(false)) {
ConfigurationSection shopSec = itemSection.getConfigurationSection(shopId);
if (shopSec == null) continue;
for (String prodId : shopSec.getKeys(false)) {
double p0 = shopSec.getDouble(prodId + ".base-price", -1.0);
if (p0 <= 0) continue;
double lambda = shopSec.getDouble(prodId + ".lambda", macroLambda);
activeItems.add(new ItemMeta(shopId + ":" + prodId, shopId, prodId, p0, lambda, idx++));
}
}
int count = activeItems.size();
if (count == 0) {
LogUtil.info("No valid items found for price computation");
return resultMap;
}
long now = System.currentTimeMillis();
double neff = NativeBridge.queryNeffVectorized(now, configTau);
Map<String, Double> histAvgMap = loadHistoryAveragesAsync(activeItems).join();
try (Arena arena = Arena.ofConfined()) {
SequenceLayout tradeCtxLayout = MemoryLayout.sequenceLayout(count, Layouts.TRADE_CONTEXT);
SequenceLayout marketCfgLayout = MemoryLayout.sequenceLayout(count, Layouts.MARKET_CONFIG);
SequenceLayout doubleArrLayout = MemoryLayout.sequenceLayout(count, JAVA_DOUBLE);
MemorySegment ctxSeg = arena.allocate(tradeCtxLayout);
MemorySegment cfgSeg = arena.allocate(marketCfgLayout);
MemorySegment histAvgSeg = arena.allocate(doubleArrLayout);
MemorySegment lambdaSeg = arena.allocate(doubleArrLayout);
MemorySegment outputSeg = arena.allocate(doubleArrLayout);
for (ItemMeta meta : activeItems) {
long ctxOffset = (long) meta.index() * Layouts.TRADE_CONTEXT.byteSize();
long cfgOffset = (long) meta.index() * Layouts.MARKET_CONFIG.byteSize();
MemorySegment ctxSlice = ctxSeg.asSlice(ctxOffset, Layouts.TRADE_CONTEXT.byteSize());
NativeContextBuilder.fillGlobalContext(ctxSlice, now);
NativeBridge.VH_CTX_BASE_PRICE.set(ctxSeg, ctxOffset, meta.basePrice());
ConfigurationSection itemConfig = itemSection.getConfigurationSection(meta.shopId() + "." + meta.productId());
fillMarketConfig(cfgSeg, cfgOffset, itemConfig, config, meta.lambda());
double histAvg = histAvgMap.getOrDefault(meta.productId(), meta.basePrice());
histAvgSeg.setAtIndex(JAVA_DOUBLE, meta.index(), histAvg);
lambdaSeg.setAtIndex(JAVA_DOUBLE, meta.index(), meta.lambda());
}
NativeBridge.computeBatchPrices(
count,
neff,
ctxSeg,
cfgSeg,
histAvgSeg,
lambdaSeg,
outputSeg
);
for (ItemMeta meta : activeItems) {
try {
double price = outputSeg.getAtIndex(JAVA_DOUBLE, meta.index());
if (Double.isFinite(price) && price > 0) {
resultMap.put(meta.key(), price);
} else {
LogUtil.errorOnce("INVALID_PRICE|" + meta.key(),
"Invalid price computed for " + meta.key() + ": " + price);
resultMap.put(meta.key(), meta.basePrice());
}
} catch (Exception e) {
LogUtil.error("Result extraction failed for " + meta.key(), e);
resultMap.put(meta.key(), meta.basePrice());
}
}
} catch (Throwable e) {
LogUtil.error("SIMD batch pricing engine crashed", e);
for (ItemMeta meta : activeItems) {
try {
resultMap.put(meta.key(), fallbackSingleCompute(plugin, meta, now, configTau));
} catch (Exception ex) {
resultMap.put(meta.key(), meta.basePrice());
}
}
}
return resultMap;
}
private static CompletableFuture<Map<String, Double>> loadHistoryAveragesAsync(List<ItemMeta> items) {
return CompletableFuture.supplyAsync(() -> {
Map<String, Double> resultMap = new HashMap<>();
try {
Map<String, Double> cache = new HashMap<>();
for (ItemMeta meta : items) {
String productId = meta.productId();
if (!cache.containsKey(productId)) {
cache.put(productId, TransactionDao.get7DayAverage(productId));
}
resultMap.put(productId, cache.get(productId));
}
} catch (Exception e) {
LogUtil.error("History load failed", e);
for (ItemMeta meta : items) {
resultMap.putIfAbsent(meta.productId(), meta.basePrice());
}
}
return resultMap;
});
}
private static void fillMarketConfig(
MemorySegment cfgBase,
long offset,
ConfigurationSection itemConfig,
FileConfiguration globalConfig,
double currentLambda
) {
NativeBridge.VH_CFG_LAMBDA.set(cfgBase, offset, currentLambda);
NativeBridge.VH_CFG_VOLATILITY.set(cfgBase, offset, 1.0);
NativeBridge.VH_CFG_S_AMP.set(cfgBase, offset, globalConfig.getDouble("economy.seasonal-amplitude", 0.15));
NativeBridge.VH_CFG_W_MULT.set(cfgBase, offset, globalConfig.getDouble("economy.weekend-multiplier", 1.2));
NativeBridge.VH_CFG_N_PROT.set(cfgBase, offset, globalConfig.getDouble("economy.newbie-protection-rate", 0.2));
if (itemConfig != null) {
setWeight(cfgBase, offset, itemConfig, "weights.seasonal", 0.25, NativeBridge.VH_CFG_W_SEASONAL);
setWeight(cfgBase, offset, itemConfig, "weights.weekend", 0.25, NativeBridge.VH_CFG_W_WEEKEND);
setWeight(cfgBase, offset, itemConfig, "weights.newbie", 0.25, NativeBridge.VH_CFG_W_NEWBIE);
setWeight(cfgBase, offset, itemConfig, "weights.inflation", 0.25, NativeBridge.VH_CFG_W_INFLATION);
} else {
NativeBridge.VH_CFG_W_SEASONAL.set(cfgBase, offset, 0.25);
NativeBridge.VH_CFG_W_WEEKEND.set(cfgBase, offset, 0.25);
NativeBridge.VH_CFG_W_NEWBIE.set(cfgBase, offset, 0.25);
NativeBridge.VH_CFG_W_INFLATION.set(cfgBase, offset, 0.25);
}
}
private static void setWeight(
MemorySegment cfgBase,
long offset,
ConfigurationSection config,
String path,
double defaultValue,
VarHandle vh
) {
double value = config != null ? config.getDouble(path, defaultValue) : defaultValue;
vh.set(cfgBase, offset, value);
}
private static double fallbackSingleCompute(EcoBridge plugin, ItemMeta meta, long now, double tau) {
try (Arena arena = Arena.ofConfined()) {
MemorySegment ctx = arena.allocate(Layouts.TRADE_CONTEXT);
MemorySegment cfg = arena.allocate(Layouts.MARKET_CONFIG);
NativeContextBuilder.fillGlobalContext(ctx, now);
NativeBridge.VH_CTX_BASE_PRICE.set(ctx, 0L, meta.basePrice());
ConfigurationSection itemSec = plugin.getConfig()
.getConfigurationSection("item-settings." + meta.shopId() + "." + meta.productId());
fillMarketConfig(cfg, 0L, itemSec, plugin.getConfig(), meta.lambda());
double histAvg = TransactionDao.get7DayAverage(meta.productId());
double neff = NativeBridge.queryNeffVectorized(now, tau);
double epsilon = NativeBridge.calculateEpsilon(ctx, cfg);
return NativeBridge.computePriceBounded(
meta.basePrice(),
neff,
0,
meta.lambda(),
epsilon,
histAvg
);
} catch (Exception e) {
LogUtil.error("Fallback computation failed for " + meta.key(), e);
return meta.basePrice();
}
}
}

==================================================
FILE: ecobridge-java\src\main\java\top\ellan\ecobridge\hook\EcoPlaceholderExpansion.java
==================================================

package top.ellan.ecobridge.hook;
import cn.superiormc.ultimateshop.managers.ConfigManager;
import cn.superiormc.ultimateshop.objects.ObjectShop;
import cn.superiormc.ultimateshop.objects.buttons.ObjectItem;
import me.clip.placeholderapi.expansion.PlaceholderExpansion;
import org.bukkit.OfflinePlayer;
import org.bukkit.entity.Player;
import org.jetbrains.annotations.NotNull;
import org.jetbrains.annotations.Nullable;
import top.ellan.ecobridge.EcoBridge;
import top.ellan.ecobridge.collector.ActivityCollector;
import top.ellan.ecobridge.manager.EconomicStateManager;
import top.ellan.ecobridge.manager.EconomyManager;
import top.ellan.ecobridge.util.HolidayManager;
import top.ellan.ecobridge.util.InternalPlaceholder;
import top.ellan.ecobridge.util.InternalPlaceholder.QuotaData;
public class EcoPlaceholderExpansion extends PlaceholderExpansion {
private final EcoBridge plugin;
public EcoPlaceholderExpansion(EcoBridge plugin) {
this.plugin = plugin;
}
@Override
public @NotNull String getIdentifier() {
return "ecobridge";
}
@Override
public @NotNull String getAuthor() {
return "Ellan";
}
@Override
public @NotNull String getVersion() {
return plugin.getPluginMeta().getVersion();
}
@Override
public boolean persist() {
return true;
}
@Override
public @Nullable String onRequest(OfflinePlayer offlinePlayer, @NotNull String params) {
if (params.equals("inflation")) {
return String.format("%.2f%%", EconomyManager.getInstance().getInflationRate() * 100);
}
if (params.equals("stability")) return String.format("%.2f", EconomyManager.getInstance().getStabilityFactor());
if (params.equals("is_holiday")) return HolidayManager.isTodayHoliday() ? "æ˜¯" : "å¦";
if (params.equals("holiday_mult")) return String.format("%.1fx", HolidayManager.getHolidayEpsilonFactor());
if (params.startsWith("native_")) {
return "Check Console";
}
if (offlinePlayer != null && offlinePlayer.isOnline()) {
Player player = offlinePlayer.getPlayer();
if (params.equals("player_hours")) {
return String.format("%.1f", ActivityCollector.capture(player, 48.0).hours());
}
if (params.equals("player_is_newbie")) {
return (ActivityCollector.capture(player, 48.0).isNewbie() & 1) == 1 ? "æ–°æ‰‹" : "èµ„æ·±";
}
if (params.startsWith("quota_")) {
return handleQuotaRequest(player, params);
}
}
if (params.startsWith("state_color_")) {
String pid = params.substring(12);
var phase = EconomicStateManager.getInstance().analyzeMarketAndNotify(pid, 0.0);
return switch (phase) {
case STABLE -> "&a";
case SATURATED -> "&e";
case EMERGENCY -> "&c";
case HEALING -> "&b";
};
}
if (params.startsWith("state_")) {
String pid = params.substring(6);
return EconomicStateManager.getInstance().analyzeMarketAndNotify(pid, 0.0).name();
}
return null;
}
private String handleQuotaRequest(Player player, String params) {
String type;
String productId;
if (params.startsWith("quota_optimal_")) {
type = "optimal";
productId = params.substring("quota_optimal_".length());
} else if (params.startsWith("quota_limit_")) {
type = "limit";
productId = params.substring("quota_limit_".length());
} else if (params.startsWith("quota_remaining_")) {
type = "remaining";
productId = params.substring("quota_remaining_".length());
} else if (params.startsWith("quota_used_")) {
type = "used";
productId = params.substring("quota_used_".length());
} else if (params.startsWith("quota_percent_")) {
type = "percent";
productId = params.substring("quota_percent_".length());
} else {
return null;
}
ObjectItem targetItem = findObjectItem(productId);
if (targetItem == null) {
return "Unknown";
}
QuotaData data = InternalPlaceholder.calculateQuota(player, targetItem);
return switch (type) {
case "optimal" -> String.valueOf(data.optimalLimit());
case "limit" -> String.valueOf(data.hardLimit());
case "remaining" -> String.valueOf(data.remaining());
case "used" -> String.valueOf(data.used());
case "percent" -> String.format("%.1f%%", data.percent());
default -> "Error";
};
}
private ObjectItem findObjectItem(String productId) {
ConfigManager cm = ConfigManager.configManager;
if (cm == null) return null;
for (ObjectShop shop : cm.getShops()) {
ObjectItem item = shop.getProduct(productId);
if (item != null) {
return item;
}
}
return null;
}
}

==================================================
FILE: ecobridge-java\src\main\java\top\ellan\ecobridge\listener\CacheListener.java
==================================================

package top.ellan.ecobridge.listener;
import org.bukkit.event.EventHandler;
import org.bukkit.event.EventPriority;
import org.bukkit.event.Listener;
import org.bukkit.event.player.PlayerJoinEvent;
import org.bukkit.event.player.PlayerQuitEvent;
import top.ellan.ecobridge.cache.HotDataCache;
import top.ellan.ecobridge.util.LogUtil;
import java.util.UUID;
public class CacheListener implements Listener {
@EventHandler(priority = EventPriority.LOW)
public void onJoin(PlayerJoinEvent event) {
UUID uuid = event.getPlayer().getUniqueId();
HotDataCache.load(uuid);
LogUtil.debug("å·²ä¸ºç©å®¶ " + event.getPlayer().getName() + " å¼€å¯æ•°æ®çƒ­è·¯å¾„ç¼“å­˜ã€‚");
}
@EventHandler(priority = EventPriority.MONITOR)
public void onQuit(PlayerQuitEvent event) {
UUID uuid = event.getPlayer().getUniqueId();
HotDataCache.invalidate(uuid);
LogUtil.debug("ç©å®¶ " + event.getPlayer().getName() + " å·²ä¸‹çº¿ï¼Œæ­£åœ¨æ‰§è¡Œçƒ­æ•°æ®å¸è½½ã€‚");
}
}

==================================================
FILE: ecobridge-java\src\main\java\top\ellan\ecobridge\listener\CoinsEngineListener.java
==================================================

package top.ellan.ecobridge.listener;
import org.bukkit.event.EventHandler;
import org.bukkit.event.EventPriority;
import org.bukkit.event.Listener;
import su.nightexpress.coinsengine.api.currency.Currency;
import su.nightexpress.coinsengine.api.event.ChangeBalanceEvent;
import su.nightexpress.coinsengine.data.impl.CoinsUser;
import top.ellan.ecobridge.EcoBridge;
import top.ellan.ecobridge.cache.HotDataCache;
import top.ellan.ecobridge.database.TransactionDao;
import top.ellan.ecobridge.manager.EconomyManager;
import top.ellan.ecobridge.storage.AsyncLogger;
import java.util.UUID;
public class CoinsEngineListener implements Listener {
private final String targetCurrencyId;
private static final double EPSILON = 1e-6;
public CoinsEngineListener(EcoBridge plugin) {
this.targetCurrencyId = plugin.getConfig().getString("economy.currency-id", "coins");
}
@EventHandler(priority = EventPriority.MONITOR, ignoreCancelled = true)
public void onBalanceChange(ChangeBalanceEvent event) {
Currency currency = event.getCurrency();
if (!targetCurrencyId.equals(currency.getId())) {
return;
}
double oldAmount = event.getOldAmount();
double newAmount = event.getNewAmount();
double delta = newAmount - oldAmount;
if (Math.abs(delta) < EPSILON) {
return;
}
EconomyManager.getInstance().onTransaction(delta, true);
CoinsUser user = event.getUser();
UUID userUuid = user.getId();
var cachedData = HotDataCache.get(userUuid);
if (cachedData != null) {
cachedData.updateFromTruth(newAmount);
}
TransactionDao.updateBalance(userUuid, newAmount);
long timestamp = System.currentTimeMillis();
AsyncLogger.log(
userUuid,
delta,
newAmount,
timestamp
);
}
}

==================================================
FILE: ecobridge-java\src\main\java\top\ellan\ecobridge\listener\CommandInterceptor.java
==================================================

package top.ellan.ecobridge.listener;
import org.bukkit.Bukkit;
import org.bukkit.entity.Player;
import org.bukkit.event.EventHandler;
import org.bukkit.event.EventPriority;
import org.bukkit.event.Listener;
import org.bukkit.event.player.PlayerCommandPreprocessEvent;
import su.nightexpress.coinsengine.api.CoinsEngineAPI;
import su.nightexpress.coinsengine.api.currency.Currency;
import top.ellan.ecobridge.EcoBridge;
import top.ellan.ecobridge.manager.TransferManager;
import top.ellan.ecobridge.util.LogUtil;
import java.util.*;
public class CommandInterceptor implements Listener {
private final Map<String, Currency> interceptMap = new HashMap<>();
public CommandInterceptor(EcoBridge plugin) {
reloadCache();
}
public void reloadCache() {
interceptMap.clear();
if (CoinsEngineAPI.getCurrencyRegistry() == null) {
LogUtil.warn("CoinsEngine æ³¨å†Œè¡¨å°šæœªå°±ç»ªï¼ŒæŒ‡ä»¤æ‹¦æˆªå™¨æš‚ç¼“åŠ è½½ã€‚");
return;
}
CoinsEngineAPI.getCurrencyRegistry().getCurrencies().forEach(currency -> {
Arrays.stream(currency.getCommandAliases())
.map(String::toLowerCase)
.forEach(alias -> interceptMap.put(alias, currency));
});
List<String> commonCmds = Arrays.asList("pay", "transfer", "epay", "balance", "money");
commonCmds.forEach(cmd -> interceptMap.put(cmd, null));
LogUtil.info("æŒ‡ä»¤æ‹¦æˆªå™¨å·²å°±ç»ªï¼Œç›‘æ§æŒ‡ä»¤æ•°: " + interceptMap.size());
}
@EventHandler(priority = EventPriority.HIGHEST, ignoreCancelled = true)
public void onCommandPreprocess(PlayerCommandPreprocessEvent event) {
Player sender = event.getPlayer();
if (sender.hasPermission("ecobridge.admin.bypass")) {
return;
}
String rawMessage = event.getMessage().substring(1);
String[] parts = rawMessage.split("\\s+");
if (parts.length < 1) return;
String fullLabel = parts[0].toLowerCase();
String label = fullLabel.contains(":") ? fullLabel.split(":")[1] : fullLabel;
if (!interceptMap.containsKey(label)) {
return;
}
Currency currency = interceptMap.get(label);
boolean isTransfer = false;
int targetIdx = -1;
int amountIdx = -1;
if (currency == null) {
if (label.equals("pay") || label.equals("transfer") || label.equals("epay")) {
isTransfer = true;
targetIdx = 1;
amountIdx = 2;
currency = CoinsEngineAPI.getCurrencyRegistry().getCurrencies().stream()
.filter(Currency::isPrimary)
.findFirst()
.orElse(null);
}
}
else {
if (parts.length > 1) {
String subCmd = parts[1].toLowerCase();
if (subCmd.equals("pay") || subCmd.equals("send")) {
isTransfer = true;
targetIdx = 2;
amountIdx = 3;
}
}
}
if (!isTransfer) return;
event.setCancelled(true);
if (parts.length <= amountIdx) {
sender.sendMessage(EcoBridge.getMiniMessage().deserialize(
"<yellow>EcoBridge ç”¨æ³•: /" + label + (interceptMap.get(label) == null ? "" : " pay") + " <ç©å®¶> <é‡‘é¢>"
));
return;
}
if (currency == null) {
sender.sendMessage(EcoBridge.getMiniMessage().deserialize("<red>é”™è¯¯: ç³»ç»Ÿæœªé…ç½®ä¸»è´§å¸ (isPrimary=true)ã€‚"));
return;
}
handleTransfer(sender, currency, parts[targetIdx], parts[amountIdx]);
}
private void handleTransfer(Player sender, Currency currency, String targetName, String amountStr) {
if (sender.getName().equalsIgnoreCase(targetName)) {
sender.sendMessage(EcoBridge.getMiniMessage().deserialize("<red>é”™è¯¯: æ— æ³•å¯¹è‡ªå·±è½¬è´¦ã€‚"));
return;
}
Player receiver = Bukkit.getPlayer(targetName);
if (receiver == null) {
sender.sendMessage(EcoBridge.getMiniMessage().deserialize("<red>é”™è¯¯: ç›®æ ‡ç©å®¶ä¸åœ¨çº¿ã€‚"));
return;
}
try {
double amount = Double.parseDouble(amountStr);
if (Double.isNaN(amount) || Double.isInfinite(amount) || amount <= 0) {
sender.sendMessage(EcoBridge.getMiniMessage().deserialize("<red>é”™è¯¯: æ— æ•ˆçš„é‡‘é¢ã€‚"));
return;
}
double minAmount = currency.getMinTransferAmount();
if (minAmount > 0 && amount < minAmount) {
sender.sendMessage(EcoBridge.getMiniMessage().deserialize("<red>é”™è¯¯: è½¬è´¦é‡‘é¢ä½äºæœ€å°é™åˆ¶ (" + minAmount + ")"));
return;
}
TransferManager.getInstance().initiateTransfer(sender, receiver, amount);
} catch (NumberFormatException e) {
sender.sendMessage(EcoBridge.getMiniMessage().deserialize("<red>é”™è¯¯: é‡‘é¢å¿…é¡»ä¸ºçº¯æ•°å­—ã€‚"));
}
}
}

==================================================
FILE: ecobridge-java\src\main\java\top\ellan\ecobridge\listener\TradeListener.java
==================================================

package top.ellan.ecobridge.listener;
import cn.superiormc.ultimateshop.api.ItemFinishTransactionEvent;
import cn.superiormc.ultimateshop.objects.buttons.ObjectItem;
import net.kyori.adventure.text.minimessage.tag.resolver.Placeholder;
import org.bukkit.Bukkit;
import org.bukkit.entity.Player;
import org.bukkit.event.EventHandler;
import org.bukkit.event.EventPriority;
import org.bukkit.event.Listener;
import org.bukkit.event.player.PlayerQuitEvent;
import top.ellan.ecobridge.EcoBridge;
import top.ellan.ecobridge.manager.EconomyManager;
import top.ellan.ecobridge.manager.PricingManager;
import top.ellan.ecobridge.util.LogUtil;
import top.ellan.ecobridge.util.TimeMonitor;
import java.util.Map;
import java.util.UUID;
import java.util.concurrent.ConcurrentHashMap;
public class TradeListener implements Listener {
private final EcoBridge plugin;
private final Map<UUID, Long> tradeThrottle = new ConcurrentHashMap<>();
private final long throttleThresholdMs;
public TradeListener(EcoBridge plugin) {
this.plugin = plugin;
this.throttleThresholdMs = plugin.getConfig().getLong("system.trade-throttle-ms", 150L);
}
@EventHandler(priority = EventPriority.MONITOR, ignoreCancelled = true)
public void onShopTrade(ItemFinishTransactionEvent event) {
final Player player = event.getPlayer();
final ObjectItem item = event.getItem();
if (item == null || item.empty) return;
final double rawAmount = (double) event.getAmount();
final boolean isBuy = event.isBuyOrSell();
final long now = System.currentTimeMillis();
if (isThrottled(player.getUniqueId(), now)) return;
TimeMonitor.checkAndResetQuota(player, item);
final String playerName = player.getName();
final UUID playerUuid = player.getUniqueId();
plugin.getVirtualExecutor().execute(() -> {
try {
double effectiveAmount = isBuy ? -rawAmount : rawAmount;
EconomyManager.getInstance().onTransaction(effectiveAmount, true);
PricingManager.getInstance().onTradeComplete(item, effectiveAmount);
if (!isBuy && rawAmount > 500) {
Bukkit.getScheduler().runTask(plugin, () -> {
Player onlinePlayer = Bukkit.getPlayer(playerUuid);
if (onlinePlayer != null && onlinePlayer.isOnline()) {
sendBehavioralGuidance(onlinePlayer, rawAmount);
}
});
}
logTrade(playerName, item, isBuy, rawAmount, effectiveAmount);
} catch (Throwable e) {
LogUtil.error("äº¤æ˜“æ¼”ç®—æµæ°´çº¿å¼‚å¸¸ [" + item.getProduct() + "]", e);
}
});
}
private void sendBehavioralGuidance(Player player, double amount) {
player.sendMessage(EcoBridge.getMiniMessage().deserialize(
"<blue>âš–</blue> <gray>å¤§å®—äº¤æ˜“æé†’ï¼šæœ¬æ¬¡å‡ºå”®é‡ä¸º <white><amt></white>ã€‚",
Placeholder.unparsed("amt", String.format("%.0f", amount))
));
if (amount > 2000) {
player.sendMessage(EcoBridge.getMiniMessage().deserialize(
"<red>âš </red> <yellow>å¸‚åœºé¥±å’Œè­¦å‘Šï¼šå•æ¬¡æŠ›å”®è¶… 2000 ä»¶å·²è§¦å‘æ·±åº¦æŠ˜ä»·ã€‚å»ºè®®åˆ†æ®µå‡ºå”®ä»¥ä¿æŠ¤åˆ©æ¶¦ã€‚"
));
} else {
player.sendMessage(EcoBridge.getMiniMessage().deserialize(
"<aqua>â„¹</aqua> <gray>æç¤ºï¼šå•æ¬¡äº¤æ˜“è¿‡å¤§ä¼šäº§ç”Ÿè¾¹é™…æ•ˆç”¨é€’å‡ï¼Œå°é¢å¤šæ¬¡äº¤æ˜“æ”¶ç›Šæ›´é«˜ã€‚"
));
}
}
private boolean isThrottled(UUID uuid, long now) {
Long lastTime = tradeThrottle.get(uuid);
if (lastTime != null && (now - lastTime) < throttleThresholdMs) {
return true;
}
tradeThrottle.put(uuid, now);
return false;
}
private void logTrade(String playerName, ObjectItem item, boolean isBuy, double raw, double eff) {
if (!plugin.getConfig().getBoolean("system.log-transactions", true)) return;
LogUtil.logTransactionSampled(
"<gray>[EcoBridge] <action> <white><id> <gray>x<amt> <dark_gray>(æƒé‡: <eff>) <gray>ç©å®¶: <p>",
Placeholder.unparsed("action", isBuy ? "<gold>ä¹°å…¥" : "<aqua>å–å‡º"),
Placeholder.unparsed("id", item.getProduct()),
Placeholder.unparsed("amt", String.format("%.1f", raw)),
Placeholder.unparsed("eff", String.format("%.1f", eff)),
Placeholder.unparsed("p", playerName)
);
}
@EventHandler
public void onQuit(PlayerQuitEvent e) {
tradeThrottle.remove(e.getPlayer().getUniqueId());
}
}

==================================================
FILE: ecobridge-java\src\main\java\top\ellan\ecobridge\manager\EconomicStateManager.java
==================================================

package top.ellan.ecobridge.manager;
import com.github.benmanes.caffeine.cache.Cache;
import com.github.benmanes.caffeine.cache.Caffeine;
import org.bukkit.Bukkit;
import org.bukkit.entity.Player;
import top.ellan.ecobridge.EcoBridge;
import top.ellan.ecobridge.database.TransactionDao;
import top.ellan.ecobridge.util.LogUtil;
import java.util.Map;
import java.util.concurrent.ConcurrentHashMap;
import java.util.concurrent.TimeUnit;
public class EconomicStateManager {
private static EconomicStateManager instance;
private final Map<String, MarketPhase> lastKnownPhases = new ConcurrentHashMap<>();
private final Cache<String, Double> anchorCache = Caffeine.newBuilder()
.expireAfterWrite(5, TimeUnit.MINUTES)
.maximumSize(1000)
.build();
public enum MarketPhase {
STABLE,
SATURATED,
EMERGENCY,
HEALING
}
private EconomicStateManager() {}
public static void init(EcoBridge plugin) {
instance = new EconomicStateManager();
}
public static EconomicStateManager getInstance() {
return instance;
}
public void recordPurchase(Player player, String productId, int amount) {
LogUtil.debug("è®°å½•è´­ä¹°: " + player.getName() + " -> " + productId + " x" + amount);
if (PricingManager.getInstance() != null) {
}
}
public void recordSale(Player player, String productId, int amount) {
LogUtil.debug("è®°å½•å‡ºå”®: " + player.getName() + " -> " + productId + " x" + amount);
if (PricingManager.getInstance() != null) {
PricingManager.getInstance().onTradeComplete(productId, amount);
}
Bukkit.getScheduler().runTaskAsynchronously(EcoBridge.getInstance(), () -> {
double currentNeff = amount;
analyzeMarketAndNotify(productId, currentNeff);
});
}
public MarketPhase analyzeMarketAndNotify(String productId, double currentNeff) {
Double anchorValue = anchorCache.get(productId, k -> TransactionDao.get7DayAverage(k));
if (anchorValue == null || anchorValue <= 0) return MarketPhase.STABLE;
double impactIndex = currentNeff / anchorValue;
MarketPhase currentPhase;
MarketPhase oldPhase = lastKnownPhases.getOrDefault(productId, MarketPhase.STABLE);
if (impactIndex > 3.5) {
currentPhase = MarketPhase.EMERGENCY;
} else if (impactIndex > 1.8) {
currentPhase = MarketPhase.SATURATED;
} else if (oldPhase == MarketPhase.EMERGENCY && impactIndex < 1.5) {
currentPhase = MarketPhase.HEALING;
} else if (impactIndex < 1.2) {
currentPhase = MarketPhase.STABLE;
} else {
currentPhase = oldPhase;
}
checkAndBroadcast(productId, currentPhase);
return currentPhase;
}
private void checkAndBroadcast(String productId, MarketPhase newPhase) {
MarketPhase oldPhase = lastKnownPhases.get(productId);
if (oldPhase != newPhase) {
lastKnownPhases.put(productId, newPhase);
executeBroadcast(productId, newPhase);
}
}
private void executeBroadcast(String productId, MarketPhase phase) {
String msg = switch (phase) {
case EMERGENCY -> "<red>âš– [å•†ä¼šç´§æ€¥å¹²é¢„] <white><id> <red>é­é‡æŠ›å”®ç‹‚æ½®ï¼å¼€å¯â€œä»·æ ¼ä¿æŠ¤â€æ¨¡å¼ã€‚";
case SATURATED -> "<yellow>âš  [å¸‚åœºè­¦å‘Š] <white><id> <yellow>åº“å­˜ç§¯å‹ï¼Œæ”¶è´­ä»·å°†ä¸‹è°ƒã€‚";
case HEALING -> "<aqua>âˆ [ç§©åºæ¢å¤] <white><id> <aqua>å¸‚åœºæ­£åœ¨å›æš–ã€‚";
case STABLE -> "<green>âœ” [è´¸æ˜“æ­£å¸¸åŒ–] <white><id> <green>æ¢å¤è‡ªç”±è´¸æ˜“å®šä»·ã€‚";
};
Bukkit.getScheduler().runTask(EcoBridge.getInstance(), () -> {
Bukkit.broadcast(EcoBridge.getMiniMessage().deserialize(
msg.replace("<id>", productId)
));
});
}
public double getBehavioralLambdaModifier(MarketPhase phase) {
return switch (phase) {
case EMERGENCY -> 0.35;
case SATURATED -> 0.60;
case HEALING -> 0.85;
default -> 1.0;
};
}
}

==================================================
FILE: ecobridge-java\src\main\java\top\ellan\ecobridge\manager\EconomyManager.java
==================================================

package top.ellan.ecobridge.manager;
import top.ellan.ecobridge.EcoBridge;
import top.ellan.ecobridge.bridge.NativeBridge;
import top.ellan.ecobridge.util.LogUtil;
import java.util.concurrent.Executors;
import java.util.concurrent.ScheduledExecutorService;
import java.util.concurrent.TimeUnit;
import java.util.concurrent.atomic.AtomicLong;
import java.util.concurrent.atomic.DoubleAdder;
import java.util.concurrent.locks.ReentrantLock;
public class EconomyManager {
private static EconomyManager instance;
private final EcoBridge plugin;
private final DoubleAdder circulationHeat = new DoubleAdder();
private final AtomicLong lastVolatileTimestamp = new AtomicLong(0);
private double m1MoneySupply;
private double volatilityThreshold;
private double decayRate;
private final ScheduledExecutorService economicScheduler;
private final ReentrantLock configLock = new ReentrantLock();
private EconomyManager(EcoBridge plugin) {
this.plugin = plugin;
this.economicScheduler = Executors.newSingleThreadScheduledExecutor(
Thread.ofVirtual().name("EcoBridge-Economy-Worker").factory()
);
loadState();
startEconomicTasks();
}
public static void init(EcoBridge plugin) {
instance = new EconomyManager(plugin);
}
public static EconomyManager getInstance() {
return instance;
}
public void loadState() {
var config = plugin.getConfig();
this.m1MoneySupply = config.getDouble("economy.m1-supply", 10_000_000.0);
this.volatilityThreshold = config.getDouble("economy.volatility-threshold", 50_000.0);
this.decayRate = config.getDouble("economy.daily-decay-rate", 0.05);
double savedHeat = config.getDouble("internal.economy-heat", 0.0);
circulationHeat.reset();
circulationHeat.add(savedHeat);
LogUtil.info("ç»æµè„‘åˆå§‹åŒ–å®Œæˆ: M1=" + m1MoneySupply + ", åˆå§‹çƒ­åº¦=" + savedHeat);
}
public void saveState() {
double currentHeat = circulationHeat.sum();
plugin.getVirtualExecutor().execute(() -> {
configLock.lock();
try {
plugin.getConfig().set("internal.economy-heat", currentHeat);
plugin.saveConfig();
} catch (Exception e) {
LogUtil.error("ä¿å­˜ç»æµçŠ¶æ€å¤±è´¥", e);
} finally {
configLock.unlock();
}
});
}
public void onTransaction(double delta, boolean isMarketActivity) {
if (!isMarketActivity) {
this.m1MoneySupply += delta;
return;
}
circulationHeat.add(delta);
if (Math.abs(delta) >= volatilityThreshold) {
markMarketVolatile();
}
}
private void markMarketVolatile() {
lastVolatileTimestamp.set(System.currentTimeMillis());
}
public double getInflationRate() {
if (!NativeBridge.isLoaded()) return 0.0;
double currentHeat = circulationHeat.sum();
return NativeBridge.calcInflation(currentHeat, m1MoneySupply);
}
public double getStabilityFactor() {
if (!NativeBridge.isLoaded()) return 1.0;
long lastVolatile = lastVolatileTimestamp.get();
long now = System.currentTimeMillis();
return NativeBridge.calcStability(lastVolatile, now);
}
private void startEconomicTasks() {
economicScheduler.scheduleAtFixedRate(
this::runEconomicDecay,
30, 30, TimeUnit.MINUTES
);
}
private void runEconomicDecay() {
if (!NativeBridge.isLoaded()) return;
double current = circulationHeat.sum();
double reduction = NativeBridge.calcDecay(current, decayRate);
if (Math.abs(reduction) > 0.0) {
circulationHeat.add(-reduction);
}
if (Math.abs(reduction) > 100.0) {
saveState();
}
}
public void shutdown() {
economicScheduler.shutdown();
configLock.lock();
try {
plugin.getConfig().set("internal.economy-heat", circulationHeat.sum());
plugin.saveConfig();
} finally {
configLock.unlock();
}
}
}

==================================================
FILE: ecobridge-java\src\main\java\top\ellan\ecobridge\manager\PricingManager.java
==================================================

package top.ellan.ecobridge.manager;
import cn.superiormc.ultimateshop.managers.ConfigManager;
import cn.superiormc.ultimateshop.objects.ObjectShop;
import cn.superiormc.ultimateshop.objects.buttons.ObjectItem;
import com.github.benmanes.caffeine.cache.Cache;
import com.github.benmanes.caffeine.cache.Caffeine;
import org.bukkit.Bukkit;
import org.bukkit.entity.Player;
import top.ellan.ecobridge.EcoBridge;
import top.ellan.ecobridge.api.event.PriceCalculatedEvent;
import top.ellan.ecobridge.bridge.NativeBridge;
import top.ellan.ecobridge.database.TransactionDao;
import top.ellan.ecobridge.engine.PriceComputeEngine;
import top.ellan.ecobridge.model.SaleRecord;
import top.ellan.ecobridge.network.RedisManager;
import top.ellan.ecobridge.storage.AsyncLogger;
import top.ellan.ecobridge.util.LogUtil;
import top.ellan.ecobridge.util.PriceOracle;
import java.lang.foreign.Arena;
import java.lang.foreign.MemorySegment;
import java.time.Duration;
import java.util.*;
import java.util.concurrent.CompletableFuture;
import java.util.concurrent.TimeUnit;
import java.util.concurrent.atomic.AtomicLong;
import java.util.concurrent.atomic.AtomicReference;
import java.util.concurrent.locks.ReentrantReadWriteLock;
public class PricingManager {
private static PricingManager instance;
private final EcoBridge plugin;
private final Arena managerArena = Arena.ofShared();
private final MemorySegment globalPidState;
private final AtomicReference<Map<String, Double>> priceSnapshot =
new AtomicReference<>(Collections.emptyMap());
private final AtomicLong globalTradeCounter = new AtomicLong(0);
private long lastComputeTime = System.currentTimeMillis();
private final Cache<String, ThreadSafeHistory> historyCache;
private volatile boolean isRunning = true;
private double defaultLambda;
private double configTau;
private double sellRatio;
private int historyDaysLimit;
private int maxHistorySize;
private double targetTradesPerUser;
private PricingManager(EcoBridge plugin) {
this.plugin = plugin;
this.historyCache = Caffeine.newBuilder()
.maximumSize(2000)
.expireAfterAccess(Duration.ofMinutes(30))
.build();
this.globalPidState = managerArena.allocate(NativeBridge.Layouts.PID_STATE);
NativeBridge.resetPidState(globalPidState);
loadConfig();
startSnapshotEngine();
}
public static void init(EcoBridge plugin) {
instance = new PricingManager(plugin);
}
public static PricingManager getInstance() {
return instance;
}
public void loadConfig() {
var config = plugin.getConfig();
this.defaultLambda = config.getDouble("economy.default-lambda", 0.002);
this.configTau = config.getDouble("economy.tau", 7.0);
this.sellRatio = config.getDouble("economy.sell-ratio", 0.5);
this.historyDaysLimit = config.getInt("economy.history-days-limit", 7);
this.maxHistorySize = config.getInt("economy.max-history-records", 3000);
this.targetTradesPerUser = config.getDouble("economy.macro.target-velocity", 0.05);
}
public void shutdown() {
this.isRunning = false;
this.historyCache.invalidateAll();
managerArena.close();
}
private void startSnapshotEngine() {
Thread.ofVirtual().name("EcoBridge-Macro-Engine").start(() -> {
LogUtil.info("å®è§‚å®šä»·è°ƒåº¦å™¨å·²å¯åŠ¨ (Mode: Adaptive PID + Heat Control)");
while (isRunning && plugin.isEnabled()) {
try {
long now = System.currentTimeMillis();
double dt = (now - lastComputeTime) / 1000.0;
lastComputeTime = now;
int onlineCount = Bukkit.getOnlinePlayers().size();
long currentTrades = globalTradeCounter.getAndSet(0);
double currentHeat = currentTrades / Math.max(dt, 0.1);
double targetHeat = Math.max(0.1, onlineCount * targetTradesPerUser);
double inflation = EconomyManager.getInstance().getInflationRate();
double macroAdjustment = NativeBridge.computePidAdjustment(
globalPidState, targetHeat, currentHeat, dt, inflation, currentHeat
);
Map<String, Double> nextPrices = PriceComputeEngine.computeSnapshot(
plugin, configTau, defaultLambda * macroAdjustment
);
if (!nextPrices.isEmpty()) {
priceSnapshot.set(Map.copyOf(nextPrices));
}
Thread.sleep(2000);
} catch (InterruptedException e) {
Thread.currentThread().interrupt();
break;
} catch (Throwable e) {
LogUtil.warn("å®è§‚è°ƒæ§å¾ªç¯å¼‚å¸¸: " + e.getMessage());
}
}
});
}
public double calculateBuyPrice(String productId) {
ObjectItem item = findObjectItem(productId);
if (item == null) return 100.0;
double dynamicPrice = getSnapshotPrice(item.getShop(), productId);
if (dynamicPrice <= 0) {
dynamicPrice = PriceOracle.getOriginalBasePrice(item, true);
}
return dynamicPrice;
}
public double calculateSellPrice(String productId) {
return calculateBuyPrice(productId) * this.sellRatio;
}
public double calculateDynamicPrice(Player player, ObjectItem item, double amount) {
String shopId = item.getShop();
String productId = item.getProduct();
double basePrice = getSnapshotPrice(shopId, productId);
if (basePrice <= 0) {
basePrice = PriceOracle.getOriginalBasePrice(item, amount < 0);
}
double calculatedPrice = NativeBridge.computeTierPrice(basePrice, Math.abs(amount), amount > 0);
PriceCalculatedEvent event = new PriceCalculatedEvent(player, shopId, productId, calculatedPrice);
if (Bukkit.isPrimaryThread()) {
Bukkit.getPluginManager().callEvent(event);
return event.getFinalPrice();
}
try {
return CompletableFuture.runAsync(
() -> Bukkit.getPluginManager().callEvent(event),
runnable -> Bukkit.getScheduler().runTask(plugin, runnable)
).thenApply(v -> event.getFinalPrice())
.orTimeout(500, TimeUnit.MILLISECONDS)
.join();
} catch (Exception e) {
LogUtil.errorOnce("PRICING_EVENT_TIMEOUT",
"ä»·æ ¼äº‹ä»¶åŒæ­¥è¶…æ—¶æˆ–å¤±è´¥ [" + productId + "]ï¼Œä½¿ç”¨å†…æ ¸åŸä»·ã€‚");
return event.getFinalPrice();
}
}
public void onTradeComplete(ObjectItem item, double effectiveAmount) {
onTradeComplete(item.getProduct(), effectiveAmount);
}
public void onTradeComplete(String productId, double effectiveAmount) {
globalTradeCounter.incrementAndGet();
long now = System.currentTimeMillis();
processTradeInternal(productId, effectiveAmount, now, true);
if (RedisManager.getInstance() != null) {
RedisManager.getInstance().publishTrade(productId, effectiveAmount);
}
}
public void onRemoteTradeReceived(String productId, double amount, long timestamp) {
processTradeInternal(productId, amount, timestamp, false);
}
private void processTradeInternal(String productId, double amount, long timestamp, boolean writeToSql) {
SaleRecord record = new SaleRecord(timestamp, amount);
getHistoryContainer(productId).add(record, maxHistorySize);
java.util.UUID productLoggerUuid = java.util.UUID.nameUUIDFromBytes(("PRODUCT_" + productId).getBytes());
if (writeToSql) {
plugin.getVirtualExecutor().execute(() -> {
AsyncLogger.log(productLoggerUuid, amount, 0.0, timestamp, "LOCAL_TRADE");
TransactionDao.saveSaleAsync(null, productId, amount);
});
} else {
java.util.UUID remoteUuid = java.util.UUID.nameUUIDFromBytes(("REMOTE_" + productId).getBytes());
AsyncLogger.log(remoteUuid, amount, 0.0, timestamp, "REMOTE_SYNC");
}
}
public List<SaleRecord> getGlobalHistory(String productId) {
return getHistoryContainer(productId).getSnapshot();
}
private ObjectItem findObjectItem(String productId) {
if (ConfigManager.configManager == null) return null;
for (ObjectShop shop : ConfigManager.configManager.getShops()) {
ObjectItem item = shop.getProduct(productId);
if (item != null) return item;
}
return null;
}
public double getSnapshotPrice(String shopId, String productId) {
if (shopId == null) {
return priceSnapshot.get().entrySet().stream()
.filter(e -> e.getKey().endsWith(":" + productId))
.map(Map.Entry::getValue)
.findFirst()
.orElse(-1.0);
}
return priceSnapshot.get().getOrDefault(shopId + ":" + productId, -1.0);
}
private ThreadSafeHistory getHistoryContainer(String productId) {
return historyCache.get(productId, k -> {
List<SaleRecord> dbData = TransactionDao.getProductHistory(k, historyDaysLimit);
return new ThreadSafeHistory(dbData);
});
}
public void clearCache() {
historyCache.invalidateAll();
}
private static class ThreadSafeHistory {
private final ArrayDeque<SaleRecord> deque;
private final ReentrantReadWriteLock lock = new ReentrantReadWriteLock();
public ThreadSafeHistory(List<SaleRecord> initialData) {
this.deque = new ArrayDeque<>(initialData);
}
public void add(SaleRecord record, int maxSize) {
lock.writeLock().lock();
try {
deque.addFirst(record);
if (deque.size() > maxSize) {
deque.removeLast();
}
} finally {
lock.writeLock().unlock();
}
}
public List<SaleRecord> getSnapshot() {
lock.readLock().lock();
try {
return new ArrayList<>(deque);
} finally {
lock.readLock().unlock();
}
}
}
}

==================================================
FILE: ecobridge-java\src\main\java\top\ellan\ecobridge\manager\TransferManager.java
==================================================

package top.ellan.ecobridge.manager;
import net.kyori.adventure.text.Component;
import net.kyori.adventure.text.minimessage.tag.resolver.Placeholder;
import org.bukkit.Bukkit;
import org.bukkit.entity.Player;
import su.nightexpress.coinsengine.api.CoinsEngineAPI;
import su.nightexpress.coinsengine.api.currency.Currency;
import top.ellan.ecobridge.EcoBridge;
import top.ellan.ecobridge.bridge.NativeBridge;
import top.ellan.ecobridge.bridge.NativeBridge.TransferResult;
import top.ellan.ecobridge.network.RedisManager;
import top.ellan.ecobridge.storage.ActivityCollector;
import top.ellan.ecobridge.storage.AsyncLogger;
import top.ellan.ecobridge.util.LogUtil;
import java.lang.foreign.Arena;
import java.lang.foreign.MemoryLayout;
import java.lang.foreign.MemorySegment;
import java.lang.invoke.VarHandle;
import java.util.concurrent.ExecutorService;
import java.util.concurrent.Executors;
import java.util.concurrent.TimeUnit;
import static java.lang.foreign.ValueLayout.*;
public class TransferManager {
private static TransferManager instance;
private final EcoBridge plugin;
private final ExecutorService vExecutor;
private final String mainCurrencyId;
private static final String BYPASS_TAX_PERMISSION = "ecobridge.bypass.tax";
private static final String BYPASS_BLOCK_PERMISSION = "ecobridge.bypass.block";
private static final VarHandle VH_TR_AMOUNT;
private static final VarHandle VH_TR_S_BAL;
private static final VarHandle VH_TR_R_BAL;
private static final VarHandle VH_TR_INF;
private static final VarHandle VH_TR_LIMIT;
private static final VarHandle VH_TR_S_TIME;
private static final VarHandle VH_TR_R_TIME;
private static final VarHandle VH_TCTX_SCORE;
private static final VarHandle VH_TCTX_VELOCITY;
private static final VarHandle VH_RCFG_V_THRESHOLD;
static {
var layout = NativeBridge.Layouts.TRANSFER_CONTEXT;
VH_TR_AMOUNT = layout.varHandle(MemoryLayout.PathElement.groupElement("amount"));
VH_TR_S_BAL = layout.varHandle(MemoryLayout.PathElement.groupElement("sender_balance"));
VH_TR_R_BAL = layout.varHandle(MemoryLayout.PathElement.groupElement("receiver_balance"));
VH_TR_INF = layout.varHandle(MemoryLayout.PathElement.groupElement("inflation_rate"));
VH_TR_LIMIT = layout.varHandle(MemoryLayout.PathElement.groupElement("newbie_limit"));
VH_TR_S_TIME = layout.varHandle(MemoryLayout.PathElement.groupElement("sender_play_time"));
VH_TR_R_TIME = layout.varHandle(MemoryLayout.PathElement.groupElement("receiver_play_time"));
VH_TCTX_SCORE = layout.varHandle(MemoryLayout.PathElement.groupElement("sender_activity_score"));
VH_TCTX_VELOCITY = layout.varHandle(MemoryLayout.PathElement.groupElement("sender_velocity"));
var regLayout = NativeBridge.Layouts.REGULATOR_CONFIG;
VH_RCFG_V_THRESHOLD = regLayout.varHandle(MemoryLayout.PathElement.groupElement("velocity_threshold"));
}
private TransferManager(EcoBridge plugin) {
this.plugin = plugin;
this.vExecutor = Executors.newVirtualThreadPerTaskExecutor();
this.mainCurrencyId = plugin.getConfig().getString("economy.currency-id", "coins");
}
public static void init(EcoBridge plugin) { instance = new TransferManager(plugin); }
public static TransferManager getInstance() { return instance; }
public void initiateTransfer(Player sender, Player receiver, double amount) {
Currency currency = CoinsEngineAPI.getCurrency(mainCurrencyId);
if (currency == null) {
sender.sendMessage(Component.text("ç³»ç»Ÿæ•…éšœï¼šæ‰¾ä¸åˆ°æ ¸å¿ƒè´§å¸é…ç½®ã€‚"));
return;
}
double senderBal = CoinsEngineAPI.getBalance(sender, currency);
if (senderBal < amount) {
sender.sendMessage(EcoBridge.getMiniMessage().deserialize("<red>ä½™é¢ä¸è¶³ï¼Œè½¬è´¦ä¸­æ­¢ã€‚"));
return;
}
captureAndAudit(sender, receiver, currency, amount, senderBal);
}
private void captureAndAudit(Player sender, Player receiver, Currency currency, double amount, double senderBal) {
var sSnapshot = ActivityCollector.getSafeSnapshot(sender.getUniqueId());
var rSnapshot = ActivityCollector.getSafeSnapshot(receiver.getUniqueId());
long sPlayTime = sSnapshot.playTimeSeconds();
long rPlayTime = rSnapshot.playTimeSeconds();
double sActivityScore = sSnapshot.activityScore();
int sVelocity = 1;
double receiverBal = CoinsEngineAPI.getBalance(receiver, currency);
if (!sender.hasPermission(BYPASS_BLOCK_PERMISSION)) {
sender.sendMessage(EcoBridge.getMiniMessage().deserialize("<gray><italic>EcoKernel æ­£åœ¨è¿›è¡Œæ·±åº¦è¡Œä¸ºå®¡è®¡ä¸é£æ§å»ºæ¨¡..."));
}
vExecutor.submit(() -> {
try (Arena arena = Arena.ofConfined()) {
double inflation = EconomyManager.getInstance().getInflationRate();
MemorySegment ctx = arena.allocate(NativeBridge.Layouts.TRANSFER_CONTEXT);
VH_TR_AMOUNT.set(ctx, 0L, amount);
VH_TR_S_BAL.set(ctx, 0L, senderBal);
VH_TR_R_BAL.set(ctx, 0L, receiverBal);
VH_TR_INF.set(ctx, 0L, inflation);
VH_TR_LIMIT.set(ctx, 0L, plugin.getConfig().getDouble("economy.audit-settings.newbie-limit", 50000.0));
VH_TR_S_TIME.set(ctx, 0L, sPlayTime);
VH_TR_R_TIME.set(ctx, 0L, rPlayTime);
VH_TCTX_SCORE.set(ctx, 0L, sActivityScore);
VH_TCTX_VELOCITY.set(ctx, 0L, sVelocity);
MemorySegment cfg = arena.allocate(NativeBridge.Layouts.REGULATOR_CONFIG);
populateRegulatorConfig(cfg);
TransferResult result = NativeBridge.checkTransfer(ctx, cfg);
Bukkit.getScheduler().runTask(plugin, () ->
executeSettlement(sender, receiver, currency, amount, result));
} catch (Throwable e) {
LogUtil.error("å®¡è®¡å†…æ ¸å´©æºƒ (Memory Access Violation)", e);
Bukkit.getScheduler().runTask(plugin, () ->
sender.sendMessage(Component.text("å†…æ ¸å¼‚å¸¸ï¼Œè½¬è´¦å·²æ‹¦æˆªã€‚")));
}
});
}
private void executeSettlement(Player sender, Player receiver, Currency currency, double amount, TransferResult audit) {
boolean canBypassBlock = sender.isOp() || sender.hasPermission(BYPASS_BLOCK_PERMISSION);
if (audit.isBlocked() && !canBypassBlock) {
handleBlocked(sender, audit.warningCode());
return;
}
double currentSenderBal = CoinsEngineAPI.getBalance(sender, currency);
if (currentSenderBal < amount) {
sender.sendMessage(EcoBridge.getMiniMessage().deserialize("<red>è½¬è´¦å¤±è´¥ï¼šè´¦æˆ·èµ„é‡‘åœ¨å®¡è®¡æœŸé—´å·²å˜åŠ¨ã€‚"));
return;
}
boolean canBypassTax = sender.isOp() || sender.hasPermission(BYPASS_TAX_PERMISSION);
double tax = canBypassTax ? 0.0 : audit.tax();
double netAmount = amount - tax;
try {
if (!CoinsEngineAPI.removeBalance(sender.getUniqueId(), currency, amount)) {
throw new IllegalStateException("åº•å±‚ç»æµæ¥å£æ‹’ç»æ“ä½œ");
}
CoinsEngineAPI.addBalance(receiver, currency, netAmount);
long ts = System.currentTimeMillis();
String meta = canBypassTax ? "BYPASS_TAX" : "NORMAL";
AsyncLogger.log(sender.getUniqueId(), -amount, currentSenderBal - amount, ts, meta);
if (RedisManager.getInstance() != null) {
RedisManager.getInstance().publishTrade("SYSTEM_TRANSFER", amount);
}
notifySuccess(sender, receiver, currency, amount, netAmount, tax, canBypassTax);
} catch (Exception e) {
LogUtil.severe("ç»“ç®—é“¾è·¯è‡´å‘½å¼‚å¸¸ï¼è§¦å‘ç´§æ€¥å›æ»š: " + sender.getName());
CoinsEngineAPI.addBalance(sender, currency, amount);
sender.sendMessage(Component.text("ç³»ç»Ÿç»“ç®—è¶…æ—¶ï¼Œèµ„é‡‘å·²å®‰å…¨å›æ»šã€‚"));
}
}
private void populateRegulatorConfig(MemorySegment cfg) {
var section = plugin.getConfig().getConfigurationSection("economy.audit-settings");
if (section == null) return;
cfg.set(JAVA_DOUBLE, 0, section.getDouble("base-tax-rate", 0.05));
cfg.set(JAVA_DOUBLE, 8, section.getDouble("luxury-threshold", 100000.0));
cfg.set(JAVA_DOUBLE, 16, section.getDouble("luxury-tax-rate", 0.1));
cfg.set(JAVA_DOUBLE, 24, section.getDouble("wealth-gap-tax-rate", 0.2));
cfg.set(JAVA_DOUBLE, 32, section.getDouble("poor-threshold", 10000.0));
cfg.set(JAVA_DOUBLE, 40, section.getDouble("rich-threshold", 1000000.0));
cfg.set(JAVA_DOUBLE, 48, section.getDouble("newbie-receive-limit", 50000.0));
cfg.set(JAVA_DOUBLE, 56, section.getDouble("warning-ratio", 0.9));
cfg.set(JAVA_DOUBLE, 64, section.getDouble("warning-min-amount", 50000.0));
cfg.set(JAVA_DOUBLE, 72, section.getDouble("newbie-hours", 10.0));
cfg.set(JAVA_DOUBLE, 80, section.getDouble("veteran-hours", 100.0));
VH_RCFG_V_THRESHOLD.set(cfg, 0L, section.getDouble("velocity-threshold", 20.0));
}
private void handleBlocked(Player sender, int code) {
String reason = switch (code) {
case 1 -> "æ¶‰å«Œéæ­£å¸¸èµ„é‡‘å½’é›† (é£é™©è¯„çº§è¿‡é«˜)";
case 2 -> "æ‹¦æˆªé€†å‘æµè½¬ (æ–°æ‰‹å‘è€æ‰‹å¼‚å¸¸è¾“é€)";
case 3 -> "æ‹¦æˆªéæ­£å¸¸æ³¨èµ„ (è€æ‰‹å‘æ–°æ‰‹è¿è§„æ³¨èµ„)";
case 4 -> "è´¦æˆ·ä½™é¢ä¸è¶³ (ç»“ç®—å†²çª)";
case 5 -> "æ“ä½œé¢‘ç‡è¿‡å¿« (è´¦æˆ·æ‹†åˆ†/æ´—é’±é£æ§)";
default -> "è¿åæœåŠ¡å™¨é‡‘èåˆè§„åè®® (Code: " + code + ")";
};
sender.sendMessage(EcoBridge.getMiniMessage().deserialize("<red>âš  å®¡è®¡æ‹’ç»: <yellow>" + reason));
}
private void notifySuccess(Player s, Player r, Currency cur, double total, double net, double tax, boolean isTaxFree) {
String suffix = isTaxFree ? " <dark_gray>[å…ç¨ç‰¹æƒ]</dark_gray>" : "";
s.sendMessage(EcoBridge.getMiniMessage().deserialize("<green>âœ” æˆåŠŸè½¬å‡º <gold><amt><gray> (ç¨è´¹: <tax>)" + suffix,
Placeholder.unparsed("amt", cur.format(total)),
Placeholder.unparsed("tax", cur.format(tax))));
r.sendMessage(EcoBridge.getMiniMessage().deserialize("<green>â• æ”¶åˆ° <gold><amt><gray> æ¥è‡ª <p>",
Placeholder.unparsed("amt", cur.format(net)),
Placeholder.unparsed("p", s.getName())));
}
public void shutdown() {
vExecutor.shutdown();
try { if (!vExecutor.awaitTermination(5, TimeUnit.SECONDS)) vExecutor.shutdownNow(); }
catch (InterruptedException e) { vExecutor.shutdownNow(); }
}
}

==================================================
FILE: ecobridge-java\src\main\java\top\ellan\ecobridge\manager\UShopLimitInjector.java
==================================================

package top.ellan.ecobridge.manager;
import cn.superiormc.ultimateshop.managers.ConfigManager;
import cn.superiormc.ultimateshop.objects.ObjectShop;
import cn.superiormc.ultimateshop.objects.buttons.ObjectItem;
import cn.superiormc.ultimateshop.objects.items.ObjectLimit;
import org.bukkit.entity.Player;
import top.ellan.ecobridge.EcoBridge;
import top.ellan.ecobridge.util.InternalPlaceholder;
import top.ellan.ecobridge.util.LogUtil;
import java.lang.reflect.Field;
import java.util.Map;
import java.util.concurrent.ConcurrentHashMap;
public class UShopLimitInjector {
private static final Map<ObjectItem, ObjectLimit[]> originalLimits = new ConcurrentHashMap<>();
private static Field buyLimitField;
private static Field sellLimitField;
private static boolean reflectionReady = false;
static {
try {
buyLimitField = ObjectItem.class.getDeclaredField("buyLimit");
sellLimitField = ObjectItem.class.getDeclaredField("sellLimit");
buyLimitField.setAccessible(true);
sellLimitField.setAccessible(true);
reflectionReady = true;
} catch (Exception e) {
LogUtil.error("EcoBridge ä¸¥é‡é”™è¯¯: æ— æ³•åˆå§‹åŒ– UltimateShop é™é¢åå°„å­—æ®µï¼Œé™é¢æ¥ç®¡å°†å¤±æ•ˆã€‚", e);
}
}
public static void execute(EcoBridge plugin) {
if (!plugin.getConfig().getBoolean("integrations.ultimateshop.enabled", true)) {
return;
}
if (!reflectionReady) {
LogUtil.warn("åå°„ç¯å¢ƒæœªå°±ç»ªï¼Œè·³è¿‡é™é¢æ³¨å…¥ã€‚");
return;
}
ConfigManager cm = ConfigManager.configManager;
if (cm == null) return;
int count = 0;
try {
for (ObjectShop shop : cm.getShops()) {
if (shop.getConfig() == null) continue;
for (String itemId : shop.getConfig().getConfigurationSection("items").getKeys(false)) {
ObjectItem item = shop.getProduct(itemId);
if (item == null) continue;
synchronized (item) {
if (!originalLimits.containsKey(item)) {
ObjectLimit oldBuy = (ObjectLimit) buyLimitField.get(item);
ObjectLimit oldSell = (ObjectLimit) sellLimitField.get(item);
originalLimits.put(item, new ObjectLimit[]{oldBuy, oldSell});
}
ObjectLimit currentBuy = (ObjectLimit) buyLimitField.get(item);
ObjectLimit currentSell = (ObjectLimit) sellLimitField.get(item);
if (!(currentBuy instanceof EcoBridgeDynamicLimit)) {
buyLimitField.set(item, new EcoBridgeDynamicLimit(plugin, currentBuy));
}
if (!(currentSell instanceof EcoBridgeDynamicLimit)) {
sellLimitField.set(item, new EcoBridgeDynamicLimit(plugin, currentSell));
}
}
count++;
}
}
LogUtil.info("UltimateShop åŠ¨æ€é™é¢å†…æ ¸å·²æ³¨å…¥ (" + count + " ä¸ªå•†å“)ã€‚");
} catch (Exception e) {
LogUtil.error("é™é¢æ³¨å…¥è¿‡ç¨‹ä¸­å‘ç”Ÿå¼‚å¸¸", e);
}
}
public static void revert() {
if (originalLimits.isEmpty() || !reflectionReady) return;
try {
int count = 0;
for (Map.Entry<ObjectItem, ObjectLimit[]> entry : originalLimits.entrySet()) {
ObjectItem item = entry.getKey();
ObjectLimit[] originals = entry.getValue();
if (item != null) {
synchronized (item) {
buyLimitField.set(item, originals[0]);
sellLimitField.set(item, originals[1]);
}
count++;
}
}
originalLimits.clear();
LogUtil.info("å·²è¿˜åŸ " + count + " ä¸ªå•†å“çš„åŸå§‹é™é¢é€»è¾‘ã€‚");
} catch (Exception e) {
LogUtil.error("è¿˜åŸé™é¢é€»è¾‘æ—¶å‘ç”Ÿé”™è¯¯", e);
}
}
public static class EcoBridgeDynamicLimit extends ObjectLimit {
private final EcoBridge plugin;
private final ObjectLimit original;
public EcoBridgeDynamicLimit(EcoBridge plugin, ObjectLimit original) {
super();
this.plugin = plugin;
this.original = original;
}
@Override
public int getPlayerLimits(Player player) {
if (plugin.getConfig().getBoolean("integrations.ultimateshop.limit-takeover", true)) {
return InternalPlaceholder.PHYSICAL_HARD_CAP;
}
if (original != null) {
return original.getPlayerLimits(player);
}
return -1;
}
@Override
public int getServerLimits(Player player) {
if (original != null) {
return original.getServerLimits(player);
}
return -1;
}
}
}

==================================================
FILE: ecobridge-java\src\main\java\top\ellan\ecobridge\manager\UShopPriceInjector.java
==================================================

package top.ellan.ecobridge.manager;
import cn.superiormc.ultimateshop.managers.ConfigManager;
import cn.superiormc.ultimateshop.objects.ObjectShop;
import cn.superiormc.ultimateshop.objects.buttons.ObjectItem;
import cn.superiormc.ultimateshop.objects.items.GiveResult;
import cn.superiormc.ultimateshop.objects.items.TakeResult;
import cn.superiormc.ultimateshop.objects.items.prices.ObjectPrices;
import cn.superiormc.ultimateshop.objects.items.prices.PriceMode;
import org.bukkit.configuration.file.YamlConfiguration;
import org.bukkit.entity.Player;
import org.bukkit.inventory.Inventory;
import su.nightexpress.coinsengine.api.CoinsEngineAPI;
import su.nightexpress.coinsengine.api.currency.Currency;
import top.ellan.ecobridge.EcoBridge;
import top.ellan.ecobridge.util.LogUtil;
import java.lang.reflect.Constructor;
import java.lang.reflect.Field;
import java.util.HashMap;
import java.util.Map;
import java.util.concurrent.ConcurrentHashMap;
public class UShopPriceInjector {
private static final Map<ObjectItem, ObjectPrices[]> originalPrices = new ConcurrentHashMap<>();
public static void execute(EcoBridge plugin) {
if (!plugin.getConfig().getBoolean("integrations.ultimateshop.price-takeover", true)) {
return;
}
ConfigManager cm = ConfigManager.configManager;
if (cm == null) return;
int count = 0;
try {
Field buyPriceField = ObjectItem.class.getDeclaredField("buyPrice");
Field sellPriceField = ObjectItem.class.getDeclaredField("sellPrice");
buyPriceField.setAccessible(true);
sellPriceField.setAccessible(true);
for (ObjectShop shop : cm.getShops()) {
if (shop.getConfig() == null) continue;
for (String itemId : shop.getConfig().getConfigurationSection("items").getKeys(false)) {
ObjectItem item = shop.getProduct(itemId);
if (item == null) continue;
synchronized (item) {
if (!originalPrices.containsKey(item)) {
ObjectPrices oldBuy = (ObjectPrices) buyPriceField.get(item);
ObjectPrices oldSell = (ObjectPrices) sellPriceField.get(item);
if (oldBuy != null && oldSell != null) {
originalPrices.put(item, new ObjectPrices[]{oldBuy, oldSell});
}
}
buyPriceField.set(item, new EcoBridgeDynamicPrice(plugin, item, itemId, true));
sellPriceField.set(item, new EcoBridgeDynamicPrice(plugin, item, itemId, false));
}
count++;
}
}
LogUtil.info("UltimateShop åŠ¨æ€å®šä»·å†…æ ¸å·²æ³¨å…¥ (" + count + " ä¸ªå•†å“)ã€‚");
} catch (Exception e) {
LogUtil.error("ä»·æ ¼æ³¨å…¥å¤±è´¥", e);
}
}
public static void revert() {
if (originalPrices.isEmpty()) return;
try {
Field buyPriceField = ObjectItem.class.getDeclaredField("buyPrice");
Field sellPriceField = ObjectItem.class.getDeclaredField("sellPrice");
buyPriceField.setAccessible(true);
sellPriceField.setAccessible(true);
for (Map.Entry<ObjectItem, ObjectPrices[]> entry : originalPrices.entrySet()) {
ObjectItem item = entry.getKey();
ObjectPrices[] originals = entry.getValue();
if (item != null) {
synchronized (item) {
buyPriceField.set(item, originals[0]);
sellPriceField.set(item, originals[1]);
}
}
}
originalPrices.clear();
} catch (Exception e) {
LogUtil.error("è¿˜åŸä»·æ ¼é€»è¾‘æ—¶å‘ç”Ÿé”™è¯¯", e);
}
}
public static class EcoBridgeDynamicPrice extends ObjectPrices {
@SuppressWarnings("unused")
private final EcoBridge plugin;
private final String productId;
@SuppressWarnings("unused")
private final boolean isBuy;
private final String currencyId;
private static Constructor<TakeResult> takeResultCtor;
private static Constructor<GiveResult> giveResultCtor;
private static Field takeResultMapField;
private static Field giveResultMapField;
private static boolean reflectionReady = false;
static {
try {
try {
takeResultCtor = TakeResult.class.getDeclaredConstructor();
} catch (NoSuchMethodException e) {
takeResultCtor = TakeResult.class.getDeclaredConstructor(boolean.class);
}
takeResultCtor.setAccessible(true);
takeResultMapField = findField(TakeResult.class, "resultMap", "results", "map", "data");
if (takeResultMapField != null) takeResultMapField.setAccessible(true);
try {
giveResultCtor = GiveResult.class.getDeclaredConstructor();
} catch (NoSuchMethodException e) {
giveResultCtor = GiveResult.class.getDeclaredConstructor(boolean.class);
}
giveResultCtor.setAccessible(true);
giveResultMapField = findField(GiveResult.class, "resultMap", "results", "map", "data");
if (giveResultMapField != null) giveResultMapField.setAccessible(true);
reflectionReady = true;
} catch (Exception e) {
LogUtil.error("EcoBridge æ— æ³•åˆå§‹åŒ– UltimateShop åå°„é’©å­", e);
}
}
private static Field findField(Class<?> clazz, String... potentialNames) {
for (String name : potentialNames) {
try {
return clazz.getDeclaredField(name);
} catch (NoSuchFieldException ignored) {}
}
return null;
}
public EcoBridgeDynamicPrice(EcoBridge plugin, ObjectItem item, String productId, boolean isBuy) {
super(new YamlConfiguration(), "EcoBridge", item, isBuy ? PriceMode.BUY : PriceMode.SELL);
this.plugin = plugin;
this.productId = productId;
this.isBuy = isBuy;
this.currencyId = plugin.getConfig().getString("economy.currency-id", "coins");
}
@Override
public TakeResult take(Inventory inventory, Player player, int times, int amount, boolean simulation) {
if (PricingManager.getInstance() == null) {
return createTakeResult(false, new HashMap<>());
}
double unitPrice = PricingManager.getInstance().calculateBuyPrice(productId);
double totalPrice = unitPrice * amount;
Map<String, Object> resultMap = new HashMap<>();
resultMap.put("money", totalPrice);
Currency currency = CoinsEngineAPI.getCurrency(currencyId);
if (currency == null) {
LogUtil.warnOnce("EcoBridge_Currency_404", "CoinsEngine ä¸­æœªæ‰¾åˆ°è´§å¸ ID: " + currencyId);
return createTakeResult(false, resultMap);
}
double balance = CoinsEngineAPI.getBalance(player, currency);
if (balance < totalPrice) {
return createTakeResult(false, resultMap);
}
if (!simulation) {
CoinsEngineAPI.removeBalance(player, currency, totalPrice);
if (EconomicStateManager.getInstance() != null) {
EconomicStateManager.getInstance().recordPurchase(player, productId, amount);
}
}
return createTakeResult(true, resultMap);
}
@Override
public GiveResult give(Player player, int times, int amount) {
if (isSimulationContext()) {
double unitPrice = (PricingManager.getInstance() != null) ?
PricingManager.getInstance().calculateSellPrice(productId) : 0.0;
Map<String, Object> resultMap = new HashMap<>();
resultMap.put("money", unitPrice * amount);
return createGiveResult(true, resultMap);
}
if (PricingManager.getInstance() == null) {
return createGiveResult(false, new HashMap<>());
}
double unitPrice = PricingManager.getInstance().calculateSellPrice(productId);
double totalPrice = unitPrice * amount;
Map<String, Object> resultMap = new HashMap<>();
resultMap.put("money", totalPrice);
Currency currency = CoinsEngineAPI.getCurrency(currencyId);
if (currency == null) {
LogUtil.warnOnce("EcoBridge_Currency_404", "CoinsEngine ä¸­æœªæ‰¾åˆ°è´§å¸ ID: " + currencyId);
return createGiveResult(false, resultMap);
}
CoinsEngineAPI.addBalance(player, currency, totalPrice);
if (EconomicStateManager.getInstance() != null) {
EconomicStateManager.getInstance().recordSale(player, productId, amount);
}
return createGiveResult(true, resultMap);
}
private TakeResult createTakeResult(boolean success, Map<String, Object> map) {
if (!reflectionReady || takeResultCtor == null) {
return null;
}
try {
TakeResult result;
if (takeResultCtor.getParameterCount() == 0) {
result = takeResultCtor.newInstance();
} else {
result = takeResultCtor.newInstance(success);
}
if (takeResultMapField != null) {
takeResultMapField.set(result, map);
}
return result;
} catch (Exception e) {
LogUtil.errorOnce("EcoBridge_Reflect_Error", "åˆ›å»º TakeResult å¤±è´¥: " + e.getMessage());
return null;
}
}
private GiveResult createGiveResult(boolean success, Map<String, Object> map) {
if (!reflectionReady || giveResultCtor == null) {
return null;
}
try {
GiveResult result;
if (giveResultCtor.getParameterCount() == 0) {
result = giveResultCtor.newInstance();
} else {
result = giveResultCtor.newInstance(success);
}
if (giveResultMapField != null) {
giveResultMapField.set(result, map);
}
return result;
} catch (Exception e) {
LogUtil.errorOnce("EcoBridge_Reflect_Error", "åˆ›å»º GiveResult å¤±è´¥: " + e.getMessage());
return null;
}
}
private boolean isSimulationContext() {
try {
return StackWalker.getInstance().walk(stream ->
stream.anyMatch(frame -> {
String cls = frame.getClassName();
String mtd = frame.getMethodName();
return cls.contains("ModifyDisplayItem") || mtd.equals("modifyItem");
})
);
} catch (Throwable t) {
for (StackTraceElement element : Thread.currentThread().getStackTrace()) {
if (element.getClassName().contains("ModifyDisplayItem")) return true;
}
return false;
}
}
}
}

==================================================
FILE: ecobridge-java\src\main\java\top\ellan\ecobridge\model\SaleRecord.java
==================================================

package top.ellan.ecobridge.model;
import net.kyori.adventure.text.Component;
import net.kyori.adventure.text.minimessage.MiniMessage;
import net.kyori.adventure.text.minimessage.tag.resolver.Placeholder;
import java.lang.foreign.GroupLayout;
import java.lang.foreign.MemoryLayout;
import java.lang.foreign.MemorySegment;
import java.lang.invoke.VarHandle;
import java.time.Instant;
import java.time.ZoneId;
import java.time.format.DateTimeFormatter;
import static java.lang.foreign.ValueLayout.JAVA_DOUBLE;
import static java.lang.foreign.ValueLayout.JAVA_LONG;
public record SaleRecord(
long timestamp,
double amount
) {
public static final GroupLayout LAYOUT = MemoryLayout.structLayout(
JAVA_LONG.withName("timestamp"),
JAVA_DOUBLE.withName("amount")
).withByteAlignment(8);
public static final long LAYOUT_SIZE = LAYOUT.byteSize();
private static final VarHandle VH_TIMESTAMP = LAYOUT.varHandle(MemoryLayout.PathElement.groupElement("timestamp"));
private static final VarHandle VH_AMOUNT = LAYOUT.varHandle(MemoryLayout.PathElement.groupElement("amount"));
public long getTimestamp() {
return timestamp;
}
public double getAmount() {
return amount;
}
public void writeToMemory(MemorySegment segment, long baseOffset) {
VH_TIMESTAMP.set(segment, baseOffset, this.timestamp);
VH_AMOUNT.set(segment, baseOffset, this.amount);
}
public static SaleRecord fromMemory(MemorySegment segment, long baseOffset) {
return new SaleRecord(
(long) VH_TIMESTAMP.get(segment, baseOffset),
(double) VH_AMOUNT.get(segment, baseOffset)
);
}
private static final DateTimeFormatter DATE_FORMAT = DateTimeFormatter.ofPattern("MM-dd HH:mm")
.withZone(ZoneId.systemDefault());
public SaleRecord {
if (Double.isNaN(amount) || Double.isInfinite(amount) || Math.abs(amount) > 10_000_000) {
throw new IllegalArgumentException("äº¤æ˜“æ•°æ®æº¢å‡ºé£é™©: " + amount);
}
}
public Component toComponent() {
String color = amount >= 0 ? "<aqua>" : "<gold>";
String prefix = amount >= 0 ? "+" : "";
String timeStr = DATE_FORMAT.format(Instant.ofEpochMilli(timestamp));
String amtStr = String.format("%.1f", amount);
return MiniMessage.miniMessage().deserialize(
"<gray>[<time>] " + color + "<prefix><amt>",
Placeholder.unparsed("time", timeStr),
Placeholder.unparsed("prefix", prefix),
Placeholder.unparsed("amt", amtStr)
);
}
}

==================================================
FILE: ecobridge-java\src\main\java\top\ellan\ecobridge\network\RedisManager.java
==================================================

package top.ellan.ecobridge.network;
import tools.jackson.core.JacksonException;
import tools.jackson.databind.ObjectMapper;
import tools.jackson.databind.json.JsonMapper;
import tools.jackson.databind.DeserializationFeature;
import redis.clients.jedis.Connection;
import redis.clients.jedis.ConnectionPoolConfig;
import redis.clients.jedis.DefaultJedisClientConfig;
import redis.clients.jedis.HostAndPort;
import redis.clients.jedis.Jedis;
import redis.clients.jedis.JedisPubSub;
import redis.clients.jedis.providers.PooledConnectionProvider;
import top.ellan.ecobridge.EcoBridge;
import top.ellan.ecobridge.manager.PricingManager;
import top.ellan.ecobridge.util.LogUtil;
import java.util.concurrent.LinkedBlockingDeque;
import java.util.concurrent.atomic.AtomicBoolean;
public class RedisManager {
private static RedisManager instance;
private final EcoBridge plugin;
private final ObjectMapper mapper;
private PooledConnectionProvider provider;
private volatile JedisPubSub subscriber;
private final boolean enabled;
private final String serverId;
private final String tradeChannel;
private final AtomicBoolean active = new AtomicBoolean(false);
private final LinkedBlockingDeque<TradePacket> offlineQueue = new LinkedBlockingDeque<>(5000);
private final AtomicBoolean isFlushing = new AtomicBoolean(false);
private RedisManager(EcoBridge plugin) {
this.plugin = plugin;
var config = plugin.getConfig();
this.enabled = config.getBoolean("redis.enabled", false);
this.serverId = config.getString("redis.server-id", "unknown_server");
this.tradeChannel = config.getString("redis.channels.trade", "ecobridge:global_trade");
this.mapper = JsonMapper.builder()
.disable(DeserializationFeature.FAIL_ON_TRAILING_TOKENS)
.build();
if (enabled) {
try {
connect();
} catch (Exception e) {
LogUtil.error("Redis åˆå§‹åŒ–å¤±è´¥ï¼Œè·¨æœåŒæ­¥åŠŸèƒ½å·²ç¦ç”¨ã€‚", e);
}
}
}
public static void init(EcoBridge plugin) {
instance = new RedisManager(plugin);
}
public static RedisManager getInstance() {
return instance;
}
private void connect() {
var config = plugin.getConfig();
String host = config.getString("redis.host", "127.0.0.1");
int port = config.getInt("redis.port", 6379);
HostAndPort address = new HostAndPort(host, port);
DefaultJedisClientConfig.Builder clientConfigBuilder = DefaultJedisClientConfig.builder();
String user = config.getString("redis.user", "");
String password = config.getString("redis.password", "");
if (user != null && !user.isBlank()) clientConfigBuilder.user(user);
if (password != null && !password.isBlank()) clientConfigBuilder.password(password);
clientConfigBuilder.ssl(config.getBoolean("redis.ssl", false));
clientConfigBuilder.timeoutMillis(5000);
clientConfigBuilder.socketTimeoutMillis(5000);
ConnectionPoolConfig poolConfig = new ConnectionPoolConfig();
poolConfig.setMaxTotal(32);
poolConfig.setMaxIdle(8);
poolConfig.setMinIdle(4);
poolConfig.setTestOnBorrow(true);
poolConfig.setJmxEnabled(false);
this.provider = new PooledConnectionProvider(address, clientConfigBuilder.build(), poolConfig);
this.active.set(true);
LogUtil.info("<green>Redis é€šé“å·²æ‰“å¼€ (Jackson 3.x é©±åŠ¨)ã€‚ID: " + serverId);
startSubscriberLoop();
}
private void startSubscriberLoop() {
Thread.ofVirtual().name("EcoBridge-Redis-Sub").start(() -> {
int retryCount = 0;
while (active.get() && plugin.isEnabled()) {
try (Connection connection = provider.getConnection();
Jedis jedis = new Jedis(connection)) {
retryCount = 0;
flushOfflineQueueAsync();
this.subscriber = new JedisPubSub() {
@Override
public void onMessage(String channel, String message) {
if (channel.equals(tradeChannel)) handleTradePacket(message);
}
};
LogUtil.debug("å·²å¯åŠ¨ Redis å…¨çƒè´¸æ˜“ç›‘å¬...");
jedis.subscribe(subscriber, tradeChannel);
} catch (Exception e) {
if (active.get() && plugin.isEnabled()) {
retryCount++;
long sleepTime = Math.min(retryCount * 2000L, 20000L);
LogUtil.warn("Redis é€šä¿¡é“¾è·¯ä¸­æ–­ï¼Œå°†åœ¨ " + (sleepTime/1000) + "s åå°è¯•é‡è¿...");
try { Thread.sleep(sleepTime); }
catch (InterruptedException ie) { Thread.currentThread().interrupt(); break; }
}
}
}
});
}
public void publishTrade(String productId, double amount) {
if (!enabled || !active.get()) return;
TradePacket packet = new TradePacket(serverId, productId, amount, System.currentTimeMillis());
offerToQueue(packet);
flushOfflineQueueAsync();
}
private void offerToQueue(TradePacket packet) {
if (!offlineQueue.offer(packet)) {
offlineQueue.poll();
offlineQueue.offer(packet);
if (LogUtil.isDebugEnabled()) LogUtil.debug("Redis å‘é€ç¼“å†²åŒºæº¢å‡ºï¼Œå·²æ»‘åŠ¨è¦†ç›–ã€‚");
}
}
private void flushOfflineQueueAsync() {
if (isFlushing.compareAndSet(false, true)) {
plugin.getVirtualExecutor().execute(this::flushLoop);
}
}
private void flushLoop() {
final int BATCH_SIZE = 100;
final long MAX_FLUSH_TIME_MS = 5000;
try {
long startTime = System.currentTimeMillis();
try (Connection connection = provider.getConnection();
Jedis jedis = new Jedis(connection)) {
int processed = 0;
while (!offlineQueue.isEmpty() && active.get()) {
TradePacket packet = offlineQueue.peek();
if (packet == null) break;
try {
String json = mapper.writeValueAsString(packet);
jedis.publish(tradeChannel, json);
offlineQueue.poll();
} catch (JacksonException e) {
LogUtil.error("Redis åºåˆ—åŒ–ååŒ…ï¼Œå·²ä¸¢å¼ƒ: " + e.getMessage(), e);
offlineQueue.poll();
}
processed++;
if (processed >= BATCH_SIZE ||
(System.currentTimeMillis() - startTime) > MAX_FLUSH_TIME_MS) {
break;
}
}
}
} catch (Exception e) {
LogUtil.warn("Redis æ‰¹é‡å†²åˆ·ä¸­æ­¢: " + e.getMessage());
} finally {
isFlushing.set(false);
if (!offlineQueue.isEmpty() && active.get()) {
flushOfflineQueueAsync();
}
}
}
private void handleTradePacket(String json) {
try {
if (json == null || json.isBlank()) return;
TradePacket packet = mapper.readValue(json, TradePacket.class);
if (packet == null || serverId.equals(packet.sourceServer)) return;
if (PricingManager.getInstance() != null) {
PricingManager.getInstance().onRemoteTradeReceived(
packet.productId, packet.amount, packet.timestamp
);
}
} catch (JacksonException e) {
LogUtil.warn("æ”¶åˆ°æ ¼å¼é”™è¯¯çš„è´¸æ˜“åŒ…: " + e.getMessage());
} catch (Exception e) {
LogUtil.warn("å¤„ç†è·¨æœè´¸æ˜“åŒ…å¤±è´¥: " + e.getMessage());
}
}
public void shutdown() {
active.set(false);
if (!offlineQueue.isEmpty() && provider != null) {
try (Connection connection = provider.getConnection();
Jedis jedis = new Jedis(connection)) {
LogUtil.info("æ­£åœ¨æ‰§è¡Œ Redis ä¸´ç»ˆåŒæ­¥ï¼Œå‰©ä½™åŒ…: " + offlineQueue.size());
while (!offlineQueue.isEmpty()) {
TradePacket p = offlineQueue.poll();
if (p != null) {
try {
jedis.publish(tradeChannel, mapper.writeValueAsString(p));
} catch (JacksonException ignored) {}
}
}
} catch (Exception ignored) {}
}
if (subscriber != null) try { subscriber.unsubscribe(); } catch (Exception ignored) {}
if (provider != null) provider.close();
}
private record TradePacket(
String sourceServer,
String productId,
double amount,
long timestamp
) {}
}

==================================================
FILE: ecobridge-java\src\main\java\top\ellan\ecobridge\storage\ActivityCollector.java
==================================================

package top.ellan.ecobridge.storage;
import org.bukkit.Bukkit;
import org.bukkit.Statistic;
import org.bukkit.entity.Player;
import org.jetbrains.annotations.NotNull;
import top.ellan.ecobridge.EcoBridge;
import java.util.Map;
import java.util.UUID;
import java.util.concurrent.ConcurrentHashMap;
public final class ActivityCollector {
private static final Map<UUID, ActivitySnapshot> SNAPSHOT_CACHE = new ConcurrentHashMap<>();
public record ActivitySnapshot(long playTimeSeconds, double activityScore, int status) {}
public static void updateSnapshot(@NotNull Player player) {
if (!Bukkit.isPrimaryThread()) {
return;
}
long totalTicks = player.getStatistic(Statistic.PLAY_ONE_MINUTE);
long seconds = totalTicks / 20;
double score = Math.min(1.0, (double) seconds / 72000.0);
SNAPSHOT_CACHE.put(player.getUniqueId(), new ActivitySnapshot(seconds, score, 0));
}
@NotNull
public static ActivitySnapshot getSafeSnapshot(@NotNull UUID uuid) {
return SNAPSHOT_CACHE.getOrDefault(uuid, new ActivitySnapshot(0, 0.0, 1));
}
public static void removePlayer(@NotNull UUID uuid) {
SNAPSHOT_CACHE.remove(uuid);
}
public static void startHeartbeat(@NotNull EcoBridge plugin) {
Bukkit.getScheduler().runTaskTimer(plugin, () -> {
for (Player player : Bukkit.getOnlinePlayers()) {
updateSnapshot(player);
}
}, 100L, 6000L);
}
}

==================================================
FILE: ecobridge-java\src\main\java\top\ellan\ecobridge\storage\AsyncLogger.java
==================================================

package top.ellan.ecobridge.storage;
import top.ellan.ecobridge.EcoBridge;
import top.ellan.ecobridge.bridge.NativeBridge;
import top.ellan.ecobridge.util.LogUtil;
import java.util.ArrayList;
import java.util.List;
import java.util.UUID;
import java.util.concurrent.BlockingQueue;
import java.util.concurrent.LinkedBlockingQueue;
import java.util.concurrent.TimeUnit;
public final class AsyncLogger {
private static AsyncLogger instance;
private final BlockingQueue<LogEntry> queue = new LinkedBlockingQueue<>(50000);
private volatile boolean running = true;
private record LogEntry(UUID uuid, double delta, double balance, long timestamp, String meta) {}
private AsyncLogger(EcoBridge plugin) {
startNativeWorker();
}
public static void init(EcoBridge plugin) {
if (instance == null) {
instance = new AsyncLogger(plugin);
}
}
public static AsyncLogger getInstance() {
return instance;
}
public static void log(UUID uuid, double delta, double balance, long timestamp, String meta) {
if (instance == null || !instance.running) return;
LogEntry entry = new LogEntry(uuid, delta, balance, timestamp, meta);
if (!instance.queue.offer(entry)) {
LogUtil.warn("AsyncLogger æº¢å‡ºï¼Rust å¼•æ“äº§ç”ŸèƒŒå‹ï¼Œæ­£åœ¨ä¸¢å¼ƒéƒ¨åˆ†éæ ¸å¿ƒæµæ°´ã€‚");
}
}
public static void log(UUID uuid, double delta, double balance, long timestamp) {
log(uuid, delta, balance, timestamp, "NORMAL");
}
private void startNativeWorker() {
Thread.ofVirtual().name("ecobridge-duckdb-worker").start(() -> {
List<LogEntry> batch = new ArrayList<>(1000);
LogUtil.info("AsyncLogger è™šæ‹Ÿçº¿ç¨‹å·²å°±ç»ªï¼Œæ­£åœ¨ç›‘å¬ Native å†™å…¥ç®¡çº¿...");
while (running || !queue.isEmpty()) {
try {
LogEntry first = queue.poll(2, TimeUnit.SECONDS);
if (first != null) {
batch.add(first);
queue.drainTo(batch, 999);
pushBatchToNative(batch);
batch.clear();
}
} catch (InterruptedException e) {
Thread.currentThread().interrupt();
break;
} catch (Exception e) {
LogUtil.error("AsyncLogger è¿è¡Œæ—¶å‘ç”Ÿå¼‚å¸¸", e);
}
}
LogUtil.info("AsyncLogger å·²æˆåŠŸç¦»çº¿ï¼ŒNative æ•°æ®ç®¡çº¿å·²å®‰å…¨åˆ‡æ–­ã€‚");
});
}
private void pushBatchToNative(List<LogEntry> entries) {
if (!NativeBridge.isLoaded()) return;
for (LogEntry entry : entries) {
NativeBridge.pushToDuckDB(
entry.timestamp(),
entry.uuid().toString(),
entry.delta(),
entry.balance(),
entry.meta()
);
}
}
public void shutdown() {
LogUtil.info("æ­£åœ¨å…³é—­å¼‚æ­¥è®°å½•å™¨ï¼Œæ­£åœ¨å°†æ®‹ç•™æµæ°´å­˜å…¥ DuckDB...");
this.running = false;
}
}

==================================================
FILE: ecobridge-java\src\main\java\top\ellan\ecobridge\util\HolidayManager.java
==================================================

package top.ellan.ecobridge.util;
import com.google.gson.JsonParser;
import net.kyori.adventure.text.minimessage.MiniMessage;
import net.kyori.adventure.text.minimessage.tag.resolver.Placeholder;
import org.bukkit.Bukkit;
import top.ellan.ecobridge.EcoBridge;
import java.io.IOException;
import java.net.URI;
import java.net.http.HttpClient;
import java.net.http.HttpRequest;
import java.net.http.HttpResponse;
import java.nio.file.Files;
import java.nio.file.Path;
import java.time.*;
import java.time.format.DateTimeFormatter;
import java.util.Collections;
import java.util.HashSet;
import java.util.Set;
import java.util.concurrent.Executors;
import java.util.concurrent.ScheduledExecutorService;
import java.util.concurrent.TimeUnit;
import java.util.concurrent.atomic.AtomicReference;
public class HolidayManager {
private static final MiniMessage MM = MiniMessage.miniMessage();
private static final DateTimeFormatter DATE_KEY_FORMAT = DateTimeFormatter.ofPattern("MM-dd");
private static final AtomicReference<Set<String>> holidayCache =
new AtomicReference<>(Collections.emptySet());
private static double holidayMultiplier = 1.2;
private static ScheduledExecutorService scheduler;
private static Path cacheFile;
private static final HttpClient HTTP_CLIENT = HttpClient.newBuilder()
.followRedirects(HttpClient.Redirect.NORMAL)
.connectTimeout(Duration.ofSeconds(10))
.build();
public static void init() {
var config = EcoBridge.getInstance().getConfig();
holidayMultiplier = config.getDouble("economy.holiday-multiplier", 1.2);
cacheFile = EcoBridge.getInstance().getDataFolder().toPath().resolve("cache/holidays.json");
loadFromLocalCache();
startAutoRefreshTask();
}
private static void startAutoRefreshTask() {
if (scheduler != null && !scheduler.isShutdown()) return;
scheduler = Executors.newSingleThreadScheduledExecutor(r ->
Thread.ofVirtual().name("EcoBridge-Holiday-Worker").unstarted(r));
fetchHolidayData();
LocalDateTime now = LocalDateTime.now();
LocalDateTime nextMidnight = now.toLocalDate().plusDays(1).atStartOfDay().plusMinutes(5);
long initialDelaySeconds = Duration.between(now, nextMidnight).getSeconds();
sendConsole("<gray>[ç¯å¢ƒ] æ—¥å†åŒæ­¥å·²å¯¹é½ï¼Œä¸‹æ¬¡å®Œæ•´å¯¹æ—¶å°†åœ¨ <white><delay></white> ç§’åã€‚",
Placeholder.unparsed("delay", String.valueOf(initialDelaySeconds)));
scheduler.scheduleAtFixedRate(HolidayManager::fetchHolidayData, initialDelaySeconds,
TimeUnit.DAYS.toSeconds(1), TimeUnit.SECONDS);
}
public static double getHolidayEpsilonFactor() {
return isTodayHoliday() ? holidayMultiplier : 1.0;
}
public static boolean isTodayHoliday() {
return isHoliday(System.currentTimeMillis());
}
public static boolean isHoliday(long timestamp) {
Set<String> currentCache = holidayCache.get();
if (currentCache.isEmpty()) return false;
String dateKey = LocalDate.ofInstant(Instant.ofEpochMilli(timestamp), ZoneId.systemDefault())
.format(DATE_KEY_FORMAT);
return currentCache.contains(dateKey);
}
private static void fetchHolidayData() {
int year = LocalDate.now().getYear();
String url = EcoBridge.getInstance().getConfig().getString(
"holiday-api.url-template",
"https:
).replace("{year}", String.valueOf(year));
HttpRequest request = HttpRequest.newBuilder()
.uri(URI.create(url))
.header("User-Agent", "EcoBridge-Core/0.6.7")
.GET()
.build();
HTTP_CLIENT.sendAsync(request, HttpResponse.BodyHandlers.ofString())
.thenAccept(res -> {
if (res.statusCode() == 200) {
parseAndCache(res.body());
saveToLocalCache(res.body());
}
})
.exceptionally(ex -> {
sendConsole("<red>[ç¯å¢ƒ] èŠ‚å‡æ—¥ç½‘ç»œåŒæ­¥å¼‚å¸¸ï¼Œå·²å›é€€è‡³æœ¬åœ°å¿«ç…§ã€‚");
return null;
});
}
private static void parseAndCache(String json) {
try {
var root = JsonParser.parseString(json).getAsJsonObject();
if (!root.has("holiday")) return;
var holidays = root.getAsJsonObject("holiday");
Set<String> newSet = new HashSet<>();
holidays.keySet().forEach(date -> {
var info = holidays.getAsJsonObject(date);
if (info.has("holiday") && info.get("holiday").getAsBoolean()) {
if (date.length() >= 10) newSet.add(date.substring(5, 10));
}
});
holidayCache.set(Collections.unmodifiableSet(newSet));
sendConsole("<green>[ç¯å¢ƒ] èŠ‚å‡æ—¥æ•°æ®åº“å·²å¯¹é½æœ€æ–°è‡ªç„¶æ—¥ã€‚");
} catch (Exception e) {
sendConsole("<red>[ç¯å¢ƒ] æ•°æ®æ ¼å¼å¼‚å¸¸: <white><error>", Placeholder.unparsed("error", e.getMessage()));
}
}
private static void saveToLocalCache(String json) {
try {
Files.createDirectories(cacheFile.getParent());
Files.writeString(cacheFile, json);
} catch (IOException ignored) {}
}
private static void loadFromLocalCache() {
if (!Files.exists(cacheFile)) return;
try {
parseAndCache(Files.readString(cacheFile));
} catch (IOException ignored) {}
}
public static void shutdown() {
if (scheduler != null) scheduler.shutdownNow();
}
private static void sendConsole(String msg, net.kyori.adventure.text.minimessage.tag.resolver.TagResolver... resolvers) {
Bukkit.getConsoleSender().sendMessage(MM.deserialize(msg, resolvers));
}
}

==================================================
FILE: ecobridge-java\src\main\java\top\ellan\ecobridge\util\InternalPlaceholder.java
==================================================

package top.ellan.ecobridge.util;
import cn.superiormc.ultimateshop.api.ShopHelper;
import cn.superiormc.ultimateshop.objects.buttons.ObjectItem;
import cn.superiormc.ultimateshop.objects.caches.ObjectUseTimesCache;
import net.kyori.adventure.text.minimessage.tag.resolver.Placeholder;
import net.kyori.adventure.text.minimessage.tag.resolver.TagResolver;
import org.bukkit.entity.Player;
import org.jetbrains.annotations.NotNull;
import org.jetbrains.annotations.Nullable;
import top.ellan.ecobridge.bridge.NativeBridge;
import top.ellan.ecobridge.collector.ActivityCollector;
import top.ellan.ecobridge.manager.EconomicStateManager;
import top.ellan.ecobridge.manager.EconomyManager;
import java.lang.foreign.Arena;
import java.lang.foreign.MemorySegment;
import java.lang.foreign.ValueLayout;
public final class InternalPlaceholder {
public static final int PHYSICAL_HARD_CAP = 2000;
public static final int PHYSICAL_OPTIMAL_CAP = 500;
private InternalPlaceholder() {}
@NotNull
public static TagResolver getGlobalResolver() {
return TagResolver.resolver(
Placeholder.unparsed("inflation",
String.format("%.2f%%", EconomyManager.getInstance().getInflationRate() * 100)),
Placeholder.unparsed("stability",
String.format("%.2f", EconomyManager.getInstance().getStabilityFactor())),
Placeholder.unparsed("holiday_status",
HolidayManager.isTodayHoliday() ? "æ˜¯" : "å¦"),
Placeholder.unparsed("holiday_mult",
String.format("%.1fx", HolidayManager.getHolidayEpsilonFactor()))
);
}
@NotNull
public static TagResolver getSystemResolver() {
String status = NativeBridge.isLoaded() ? "å·²å°±ç»ª" : "æœªåŠ è½½";
long totalLogs = 0;
long droppedLogs = 0;
if (NativeBridge.isLoaded()) {
try (Arena arena = Arena.ofConfined()) {
MemorySegment totalPtr = arena.allocate(ValueLayout.JAVA_LONG);
MemorySegment droppedPtr = arena.allocate(ValueLayout.JAVA_LONG);
NativeBridge.getHealthStats(totalPtr, droppedPtr);
totalLogs = totalPtr.get(ValueLayout.JAVA_LONG, 0L);
droppedLogs = droppedPtr.get(ValueLayout.JAVA_LONG, 0L);
} catch (Throwable ignored) {}
}
return TagResolver.resolver(
Placeholder.unparsed("native_status", status),
Placeholder.unparsed("native_logs", String.valueOf(totalLogs)),
Placeholder.unparsed("native_dropped", String.valueOf(droppedLogs))
);
}
@NotNull
public static TagResolver getPlayerResolver(@Nullable Player player) {
if (player == null) return TagResolver.empty();
var snapshot = ActivityCollector.capture(player, 48.0);
return TagResolver.resolver(
getGlobalResolver(),
Placeholder.unparsed("player_hours", String.format("%.1f", snapshot.hours())),
Placeholder.unparsed("newbie_tag", (snapshot.isNewbie() & 1) == 1 ? "æ–°æ‰‹" : "èµ„æ·±")
);
}
@NotNull
public static TagResolver getMarketResolver(@NotNull String productId) {
var phase = EconomicStateManager.getInstance().analyzeMarketAndNotify(productId, 0.0);
String color = switch (phase) {
case STABLE -> "<green>";
case SATURATED -> "<yellow>";
case EMERGENCY -> "<red>";
case HEALING -> "<aqua>";
};
return TagResolver.resolver(
Placeholder.unparsed("market_phase", phase.name()),
Placeholder.parsed("market_color", color)
);
}
@NotNull
public static TagResolver getQuotaResolver(@NotNull Player player, @NotNull ObjectItem item) {
QuotaData data = calculateQuota(player, item);
return TagResolver.resolver(
Placeholder.unparsed("quota_used", String.valueOf(data.used)),
Placeholder.unparsed("quota_limit", String.valueOf(data.hardLimit)),
Placeholder.unparsed("quota_optimal", String.valueOf(data.optimalLimit)),
Placeholder.unparsed("quota_remaining", String.valueOf(data.remaining)),
Placeholder.unparsed("quota_percent", String.format("%.1f%%", data.percent))
);
}
public record QuotaData(int used, int hardLimit, int optimalLimit, int remaining, double percent) {}
public static QuotaData calculateQuota(@NotNull Player player, @NotNull ObjectItem item) {
ObjectUseTimesCache cache = ShopHelper.getPlayerUseTimesCache(item, player);
int used = (cache != null) ? cache.getSellUseTimes() : 0;
int hardLimit = PHYSICAL_HARD_CAP;
int optimalLimit = PHYSICAL_OPTIMAL_CAP;
int remaining = Math.max(0, hardLimit - used);
double percent = ((double) used / hardLimit) * 100.0;
if (percent > 100.0) percent = 100.0;
return new QuotaData(used, hardLimit, optimalLimit, remaining, percent);
}
}

==================================================
FILE: ecobridge-java\src\main\java\top\ellan\ecobridge\util\LogUtil.java
==================================================

package top.ellan.ecobridge.util;
import net.kyori.adventure.text.minimessage.MiniMessage;
import net.kyori.adventure.text.minimessage.tag.resolver.Placeholder;
import net.kyori.adventure.text.minimessage.tag.resolver.TagResolver;
import org.bukkit.Bukkit;
import top.ellan.ecobridge.EcoBridge;
import java.util.Map;
import java.util.concurrent.ConcurrentHashMap;
import java.util.concurrent.atomic.AtomicLong;
public final class LogUtil {
private static final MiniMessage MM = MiniMessage.miniMessage();
private static final AtomicLong TRANSACTION_COUNTER = new AtomicLong(0);
private static final Map<String, Long> RATE_LIMIT_CACHE = new ConcurrentHashMap<>();
private static final long LOG_COOLDOWN_MS = 5 * 60 * 1000;
private static volatile boolean debugEnabled = false;
private static volatile int sampleRate = 100;
private LogUtil() {}
public static void init() {
var config = EcoBridge.getInstance().getConfig();
debugEnabled = config.getBoolean("system.debug", false);
sampleRate = Math.max(1, config.getInt("system.log-sample-rate", 100));
RATE_LIMIT_CACHE.clear();
if (debugEnabled) {
info("<gradient:aqua:blue>ç³»ç»Ÿè°ƒè¯•æ¨¡å¼å·²æ¿€æ´»</gradient> <dark_gray>| <gray>é‡‡æ ·ç‡: <white>1/<rate>",
Placeholder.unparsed("rate", String.valueOf(sampleRate)));
}
}
public static boolean isDebugEnabled() {
return debugEnabled;
}
public static void info(String message, TagResolver... resolvers) {
sendConsole("<blue>â„¹</blue> <gray>" + message, resolvers);
}
public static void debug(String message) {
if (debugEnabled) {
sendConsole("<dark_gray>[DEBUG]</dark_gray> <gray>" + message);
}
}
public static void warn(String message) {
sendConsole("<yellow>âš </yellow> <white>" + message);
}
public static void warnOnce(String key, String message) {
if (shouldLog(key)) {
sendConsole("<yellow>âš </yellow> <white>" + message + " <dark_gray>(å·²æŠ˜å åŒç±»è­¦å‘Š)</dark_gray>");
}
}
public static void errorOnce(String key, String message) {
if (shouldLog(key)) {
sendConsole("<red>âœ˜</red> <white>" + message + " <dark_gray>(å·²æŠ˜å åŒç±»é”™è¯¯)</dark_gray>");
}
}
private static boolean shouldLog(String key) {
long now = System.currentTimeMillis();
Long last = RATE_LIMIT_CACHE.get(key);
if (last == null || (now - last) > LOG_COOLDOWN_MS) {
RATE_LIMIT_CACHE.put(key, now);
return true;
}
return false;
}
public static void severe(String message) {
sendConsole("<red>âœ˜</red> <bold><red>è‡´å‘½æ•…éšœ: </red></bold><white>" + message);
}
public static void logTransactionSampled(String message, TagResolver... resolvers) {
if (!debugEnabled) return;
long count = TRANSACTION_COUNTER.incrementAndGet();
if (count % sampleRate == 0) {
EcoBridge.getInstance().getVirtualExecutor().execute(() -> {
TagResolver combined = TagResolver.resolver(
TagResolver.resolver(resolvers),
Placeholder.unparsed("count", String.valueOf(count))
);
sendConsole("<blue>âš–</blue> <gray>" + message + " <dark_gray>(#<count>)", combined);
});
}
}
public static void error(String message, Throwable e) {
EcoBridge.getInstance().getVirtualExecutor().execute(() -> {
sendConsole("<red>â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â• EcoBridge å¼‚å¸¸æŠ¥å‘Š â•â•â•â•â•â•â•â•â•â•â•â•â•â•");
sendConsole("<red>â•‘ <white>æè¿°: <msg>", Placeholder.unparsed("msg", message));
if (e != null) {
sendConsole("<red>â•‘ <white>ç±»å‹: <yellow><type>", Placeholder.unparsed("type", e.getClass().getSimpleName()));
sendConsole("<red>â•‘ <white>åŸå› : <gray><reason>", Placeholder.unparsed("reason", String.valueOf(e.getMessage())));
sendConsole("<red>â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•");
EcoBridge.getInstance().getLogger().severe("--- è¯¦ç»†å †æ ˆè¿½è¸ª ---");
e.printStackTrace();
} else {
sendConsole("<red>â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•");
}
});
}
private static void sendConsole(String msg, TagResolver... resolvers) {
Bukkit.getConsoleSender().sendMessage(MM.deserialize(msg, resolvers));
}
}

==================================================
FILE: ecobridge-java\src\main\java\top\ellan\ecobridge\util\PriceOracle.java
==================================================

package top.ellan.ecobridge.util;
import cn.superiormc.ultimateshop.objects.buttons.ObjectItem;
import cn.superiormc.ultimateshop.objects.items.ThingType;
import cn.superiormc.ultimateshop.objects.items.prices.ObjectPrices;
import cn.superiormc.ultimateshop.objects.items.prices.ObjectSinglePrice;
import net.kyori.adventure.text.minimessage.tag.resolver.Placeholder;
import top.ellan.ecobridge.bridge.NativeBridge;
import org.bukkit.configuration.ConfigurationSection;
import org.jetbrains.annotations.NotNull;
import java.math.BigDecimal;
import java.util.Collection;
import java.util.Map;
import java.util.Optional;
public final class PriceOracle {
private static final double MIN_SAFE_P0 = 0.01;
private PriceOracle() {}
public static boolean isValidEconomyItem(ObjectItem item) {
if (item == null || item.empty) return false;
ObjectPrices buyPrice = item.getBuyPrice();
if (buyPrice == null || buyPrice.empty) return false;
Collection<ObjectSinglePrice> prices = buyPrice.singlePrices;
return prices != null && prices.stream()
.anyMatch(sp -> sp.type == ThingType.HOOK_ECONOMY && isVaultHook(sp));
}
private static boolean isVaultHook(ObjectSinglePrice sp) {
ConfigurationSection section = sp.singleSection;
if (section == null) return false;
String economyPlugin = section.getString("economy-plugin");
return "Vault".equalsIgnoreCase(economyPlugin);
}
public static double getOriginalBasePrice(@NotNull ObjectItem item, boolean isBuy) {
String primaryPath = isBuy ? "buy-prices" : "sell-prices";
String secondaryPath = "prices";
ConfigurationSection config = item.getItemConfig();
if (config != null) {
Optional<Double> yamlPrice = tryExtractFromPaths(config, primaryPath, secondaryPath);
if (yamlPrice.isPresent()) {
return Math.max(MIN_SAFE_P0, yamlPrice.get());
}
}
return fetchStaticPriceFromApi(item, isBuy);
}
public static double calculateTierPrice(double basePrice, double quantity, boolean isSell) {
if (!NativeBridge.isLoaded()) {
return basePrice;
}
return NativeBridge.computeTierPrice(basePrice, quantity, isSell);
}
private static Optional<Double> tryExtractFromPaths(ConfigurationSection root, String... paths) {
for (String path : paths) {
Object section = root.get(path);
if (section != null) {
var result = deepSearchAmount(section);
if (result.isPresent()) return result;
}
}
return Optional.empty();
}
private static Optional<Double> deepSearchAmount(Object obj) {
return switch (obj) {
case ConfigurationSection sec when sec.contains("amount") ->
Optional.of(sec.getDouble("amount"));
case ConfigurationSection sec -> sec.getKeys(false).stream()
.map(sec::get)
.map(PriceOracle::deepSearchAmount)
.flatMap(Optional::stream)
.findFirst();
case Map<?, ?> map when map.get("amount") instanceof Number n ->
Optional.of(n.doubleValue());
case Map<?, ?> map -> map.values().stream()
.map(PriceOracle::deepSearchAmount)
.flatMap(Optional::stream)
.findFirst();
case Number n -> Optional.of(n.doubleValue());
case null, default -> Optional.empty();
};
}
private static double fetchStaticPriceFromApi(ObjectItem item, boolean isBuy) {
try {
ObjectPrices prices = isBuy ? item.getBuyPrice() : item.getSellPrice();
if (prices == null || prices.empty) return MIN_SAFE_P0;
Map<?, BigDecimal> resultMap = prices.getAmount(null, 0, 1);
if (resultMap == null || resultMap.isEmpty()) return MIN_SAFE_P0;
boolean isAnyMode = prices.getMode().name().contains("ANY");
BigDecimal calculatedPrice = isAnyMode ?
resultMap.values().stream()
.filter(val -> val.compareTo(BigDecimal.ZERO) > 0)
.findFirst()
.orElse(BigDecimal.ZERO)
:
resultMap.values().stream()
.filter(val -> val.compareTo(BigDecimal.ZERO) > 0)
.reduce(BigDecimal.ZERO, BigDecimal::add);
return Math.max(MIN_SAFE_P0, calculatedPrice.doubleValue());
} catch (Exception e) {
logOracleWarning(item, "API æå–å¼‚å¸¸ (å¯èƒ½å­˜åœ¨å˜é‡ä¾èµ–): " + e.getMessage());
return MIN_SAFE_P0;
}
}
private static void logOracleWarning(ObjectItem item, String reason) {
LogUtil.logTransactionSampled(
"<yellow>[é¢„è¨€æœº]</yellow> <gray>ç‰©å“ <white><id></white> åŸºå‡†ä»·æå–é™çº§ã€‚åŸå› : <white><reason></white>",
Placeholder.unparsed("id", item.getProduct()),
Placeholder.unparsed("reason", reason)
);
}
}

==================================================
FILE: ecobridge-java\src\main\java\top\ellan\ecobridge\util\TimeMonitor.java
==================================================

package top.ellan.ecobridge.util;
import cn.superiormc.ultimateshop.api.ShopHelper;
import cn.superiormc.ultimateshop.objects.caches.ObjectUseTimesCache;
import cn.superiormc.ultimateshop.objects.buttons.ObjectItem;
import net.kyori.adventure.text.minimessage.tag.resolver.Placeholder;
import org.bukkit.Bukkit;
import org.bukkit.entity.Player;
import org.jetbrains.annotations.NotNull;
import top.ellan.ecobridge.EcoBridge;
public final class TimeMonitor {
private TimeMonitor() {}
public static void checkAndResetQuota(@NotNull Player player, @NotNull ObjectItem item) {
Bukkit.getScheduler().runTask(EcoBridge.getInstance(), () -> {
ObjectUseTimesCache cache = ShopHelper.getPlayerUseTimesCache(item, player);
if (cache == null) return;
cache.refreshSellTimes();
if (LogUtil.isDebugEnabled()) {
LogUtil.logTransactionSampled(
"<gray>[é™é¢] è§¦å‘ç©å®¶ <white><p></white> çš„é…é¢çŠ¶æ€åŒæ­¥è‡ªæ£€ã€‚",
Placeholder.unparsed("p", player.getName())
);
}
});
}
public static void forceReset(@NotNull Player player, @NotNull ObjectItem item) {
Bukkit.getScheduler().runTask(EcoBridge.getInstance(), () -> {
ObjectUseTimesCache cache = ShopHelper.getPlayerUseTimesCache(item, player);
if (cache == null) return;
cache.setSellUseTimes(0, false, true);
player.sendMessage(EcoBridge.getMiniMessage().deserialize(
"<green>âš–</green> <gray>æ‚¨çš„å•†å“ <white><id></white> äº¤æ˜“é…é¢å·²è¢«é‡ç½®ï¼",
Placeholder.unparsed("id", item.getProduct())
));
LogUtil.info("ç®¡ç†å‘˜/ç³»ç»Ÿ å·²å¼ºåˆ¶é‡ç½®ç©å®¶ <p> çš„å•†å“ <id> é…é¢",
Placeholder.unparsed("p", player.getName()),
Placeholder.unparsed("id", item.getProduct()));
});
}
}

==================================================
FILE: ecobridge-rust\build.rs
==================================================

use std::env;
use std::path::PathBuf;
fn main() {
let crate_dir = env::var("CARGO_MANIFEST_DIR").unwrap();
let output_file = PathBuf::from(&crate_dir).join("ecobridge_rust.h");
let mut config = cbindgen::Config::default();
config.language = cbindgen::Language::C;
config.style = cbindgen::Style::Type;
config.header = Some(String::from(
"\n\
\n\
"
));
config.include_guard = Some(String::from("ECOBRIDGE_RUST_H"));
config.sys_includes = vec![
String::from("stdint.h"),
String::from("stdbool.h"),
];
config.no_includes = true;
config.parse.parse_deps = false;
config.parse.clean = true;
config.export.prefix = None;
config.structure.rename_fields = cbindgen::RenameRule::None;
config.enumeration.rename_variants = cbindgen::RenameRule::ScreamingSnakeCase;
config.documentation = true;
config.documentation_style = cbindgen::DocumentationStyle::C;
cbindgen::Builder::new()
.with_crate(&crate_dir)
.with_config(config)
.generate()
.expect("Critical Error: Unable to generate C bindings via cbindgen")
.write_to_file(&output_file);
println!("cargo:rerun-if-changed=src/");
println!("cargo:rerun-if-changed=Cargo.toml");
println!("cargo:rerun-if-changed=build.rs");
configure_platform_linker();
}
fn configure_platform_linker() {
let target_os = env::var("CARGO_CFG_TARGET_OS").unwrap_or_default();
match target_os.as_str() {
"windows" => {
println!("cargo:rustc-link-lib=Rstrtmgr");
}
"macos" => {
println!("cargo:rustc-link-arg=-Wl,-install_name,@rpath/libecobridge_rust.dylib");
}
"linux" => {
println!("cargo:rustc-link-arg=-Wl,-rpath,$ORIGIN");
}
_ => {}
}
}

==================================================
FILE: ecobridge-rust\Cargo.toml
==================================================

[package]
name = "ecobridge_rust"
version = "0.8.3"
edition = "2021"
authors = ["Ellan"]
description = "EcoBridge Economy Core - Hardened DuckDB Analytics Engine"
[lib]
crate-type = ["cdylib"]
[dependencies]
libc = "0.2.180"
duckdb = { version = "1.4.3", features = ["bundled", "chrono"] }
crossbeam-channel = "0.5.15"
rayon = { version = "1.11.0", optional = true }
chrono = { version = "0.4.43", features = ["std"] }
lazy_static = "1.5"
[build-dependencies]
cbindgen = "0.29.2"
[features]
default = []
parallel = ["dep:rayon"]
[profile.release]
opt-level = 3
lto = "fat"
codegen-units = 1
strip = "symbols"

==================================================
FILE: ecobridge-rust\cbindgen.toml
==================================================

language = "C"
header = "/* Generated by cbindgen. Do not edit manually. */"
style = "type"
[export]
include = [
"PidState",
"TradeContext",
"MarketConfig",
"TransferResult",
"TransferContext",
"RegulatorConfig"
]
[parse]
parse_deps = true
clean = true

==================================================
FILE: ecobridge-rust\src\lib.rs
==================================================

use libc::{c_char, c_double, c_int, c_longlong, c_ulonglong};
use std::ffi::CStr;
use std::panic::{self, AssertUnwindSafe};
use std::sync::atomic::{AtomicU64, Ordering};
use std::ptr;
pub mod models;
pub mod economy {
pub mod pricing;
pub mod summation;
pub mod environment;
pub mod control;
pub mod macro_eco;
}
pub mod security;
pub mod storage;
use crate::models::*;
static PANIC_COUNTER: AtomicU64 = AtomicU64::new(0);
macro_rules! ffi_guard {
($fallback:expr, $body:block) => {
match panic::catch_unwind(AssertUnwindSafe(|| $body)) {
Ok(result) => result,
Err(e) => {
let count = PANIC_COUNTER.fetch_add(1, Ordering::Relaxed);
let msg = if let Some(s) = e.downcast_ref::<&str>() {
*s
} else if let Some(s) = e.downcast_ref::<String>() {
s.as_str()
} else {
"Unknown panic origin"
};
eprintln!("[EcoBridge-Native] CRITICAL PANIC detected: {}", msg);
if count > 100 {
eprintln!("CRITICAL: Native panic count exceeded threshold (100). System instability imminent.");
}
$fallback
}
}
};
}
#[no_mangle]
pub extern "C" fn ecobridge_abi_version() -> u32 {
0x0009_0000
}
#[no_mangle]
pub extern "C" fn ecobridge_version() -> *const c_char {
ffi_guard!(std::ptr::null(), {
static VERSION: &[u8] = b"EcoBridge Native Core v0.9.1-Macro (Adaptive PID Enabled)\0";
VERSION.as_ptr() as *const c_char
})
}
#[no_mangle]
pub extern "C" fn ecobridge_init_db(path_ptr: *const c_char) -> c_int {
ffi_guard!(-99, {
if path_ptr.is_null() {
-1
} else {
let path_result = unsafe { CStr::from_ptr(path_ptr).to_str() };
match path_result {
Ok(path_str) => {
let res = storage::init_economy_db(path_str);
if res == 0 {
economy::summation::hydrate_hot_store();
}
res
},
Err(_) => -2,
}
}
})
}
#[no_mangle]
pub unsafe extern "C" fn ecobridge_log_to_duckdb(
ts: c_longlong,
uuid_ptr: *const c_char,
trade_amount: c_double,
balance: c_double,
meta_ptr: *const c_char,
) {
ffi_guard!((), {
if !uuid_ptr.is_null() && !meta_ptr.is_null() {
let uuid = CStr::from_ptr(uuid_ptr).to_string_lossy().into_owned();
let meta = CStr::from_ptr(meta_ptr).to_string_lossy().into_owned();
economy::summation::append_trade_to_memory(ts, trade_amount.abs());
storage::log_economy_event(ts, uuid, trade_amount, balance, meta);
}
})
}
#[no_mangle]
pub unsafe extern "C" fn ecobridge_get_health_stats(
out_total: *mut c_ulonglong,
out_dropped: *mut c_ulonglong,
) {
ffi_guard!((), {
if let Some(total) = out_total.as_mut() {
*total = storage::get_total_logs();
}
if let Some(dropped) = out_dropped.as_mut() {
*dropped = storage::get_dropped_logs();
}
})
}
#[no_mangle]
pub unsafe extern "C" fn ecobridge_query_neff_vectorized(
current_ts: c_longlong,
tau: c_double,
) -> c_double {
ffi_guard!(0.0, {
economy::summation::query_neff_internal(current_ts, tau)
})
}
#[no_mangle]
pub extern "C" fn ecobridge_compute_price_final(
base: c_double,
n_eff: c_double,
lambda: c_double,
epsilon: c_double,
) -> c_double {
ffi_guard!(base, {
economy::pricing::compute_price_final_internal(base, n_eff, lambda, epsilon)
})
}
#[no_mangle]
pub extern "C" fn ecobridge_compute_price_humane(
base: c_double,
n_eff: c_double,
trade_amount: c_double,
lambda: c_double,
epsilon: c_double,
) -> c_double {
ffi_guard!(base, {
economy::pricing::compute_price_humane_internal(base, n_eff, trade_amount, lambda, epsilon)
})
}
#[no_mangle]
pub extern "C" fn ecobridge_compute_price_bounded(
base: c_double, n_eff: c_double, amt: c_double, lambda: c_double, eps: c_double,
hist_avg: c_double
) -> c_double {
ffi_guard!(base, {
economy::pricing::compute_price_with_floor(base, n_eff, amt, lambda, eps, hist_avg)
})
}
#[no_mangle]
pub extern "C" fn ecobridge_compute_tier_price(base: c_double, qty: c_double, is_sell: bool) -> c_double {
ffi_guard!(base, {
economy::pricing::compute_tier_price_internal(base, qty, is_sell)
})
}
#[no_mangle]
pub unsafe extern "C" fn ecobridge_calculate_epsilon(
ctx_ptr: *const TradeContext,
cfg_ptr: *const MarketConfig,
) -> c_double {
ffi_guard!(1.0, {
match (ctx_ptr.as_ref(), cfg_ptr.as_ref()) {
(Some(ctx), Some(cfg)) => {
economy::environment::calculate_epsilon_internal(ctx, cfg)
},
_ => 1.0
}
})
}
#[no_mangle]
pub unsafe extern "C" fn ecobridge_compute_pid_adjustment(
pid_ptr: *mut PidState,
target: c_double,
current: c_double,
dt: c_double,
inflation: c_double,
market_heat: c_double,
) -> c_double {
ffi_guard!(0.0, {
match pid_ptr.as_mut() {
Some(pid) => {
economy::control::compute_pid_adjustment_internal(pid, target, current, dt, inflation, market_heat)
}
None => 0.0,
}
})
}
#[no_mangle]
pub unsafe extern "C" fn ecobridge_reset_pid_state(pid_ptr: *mut PidState) {
ffi_guard!((), {
if let Some(pid) = pid_ptr.as_mut() {
*pid = PidState::default();
}
})
}
#[no_mangle]
pub extern "C" fn ecobridge_calc_inflation(current_heat: c_double, m1: c_double) -> c_double {
ffi_guard!(0.0, {
economy::macro_eco::calculate_inflation_rate(current_heat, m1)
})
}
#[no_mangle]
pub extern "C" fn ecobridge_calc_stability(last_ts: c_longlong, curr_ts: c_longlong) -> c_double {
ffi_guard!(1.0, {
economy::macro_eco::calculate_stability(last_ts, curr_ts, 900000.0)
})
}
#[no_mangle]
pub extern "C" fn ecobridge_calc_decay(heat: c_double, rate: c_double) -> c_double {
ffi_guard!(0.0, {
economy::macro_eco::calculate_decay(heat, rate, 48.0)
})
}
#[no_mangle]
pub unsafe extern "C" fn ecobridge_compute_transfer_check(
out_result: *mut TransferResult,
ctx_ptr: *const TransferContext,
cfg_ptr: *const RegulatorConfig,
) {
if out_result.is_null() {
eprintln!("[EcoBridge-Native] CRITICAL ERROR: out_result pointer is null in ecobridge_compute_transfer_check");
return;
}
let default_result = TransferResult::error(-999);
let result = ffi_guard!(default_result, {
match (ctx_ptr.as_ref(), cfg_ptr.as_ref()) {
(Some(ctx), Some(cfg)) => {
security::regulator::compute_transfer_check_internal(ctx, cfg)
},
(None, _) => {
eprintln!("[EcoBridge-Native] ERROR: ctx_ptr is null in transfer check");
TransferResult::error(671)
},
(_, None) => {
eprintln!("[EcoBridge-Native] ERROR: cfg_ptr is null in transfer check");
TransferResult::error(672)
},
}
});
ffi_guard!((), {
ptr::write(out_result, result);
})
}
#[no_mangle]
pub extern "C" fn ecobridge_shutdown_db() -> c_int {
storage::shutdown_db_internal()
}

==================================================
FILE: ecobridge-rust\src\models.rs
==================================================

use libc::{c_double, c_int, c_longlong};
#[repr(C)]
#[derive(Debug, Clone, Copy)]
pub struct PidState {
pub kp: c_double,
pub ki: c_double,
pub kd: c_double,
pub lambda: c_double,
pub integral: c_double,
pub prev_pv: c_double,
pub filtered_d: c_double,
pub integration_limit: c_double,
pub is_saturated: c_int,
pub _padding: c_int,
}
impl Default for PidState {
fn default() -> Self {
Self {
kp: 0.5, ki: 0.1, kd: 0.05, lambda: 0.01,
integral: 0.0, prev_pv: 0.0, filtered_d: 0.0,
integration_limit: 30.0, is_saturated: 0,
_padding: 0,
}
}
}
#[repr(C)]
#[derive(Debug, Clone, Copy, Default)]
pub struct HistoryRecord {
pub timestamp: c_longlong,
pub amount: c_double,
}
#[repr(C)]
#[derive(Debug, Clone, Copy, Default)]
pub struct TradeContext {
pub base_price: c_double,
pub current_amount: c_double,
pub inflation_rate: c_double,
pub current_timestamp: c_longlong,
pub play_time_seconds: c_longlong,
pub timezone_offset: c_int,
pub newbie_mask: c_int,
pub market_heat: c_double,
pub eco_saturation: c_double,
}
#[repr(C)]
#[derive(Debug, Clone, Copy, Default)]
pub struct TransferContext {
pub amount: c_double,
pub sender_balance: c_double,
pub receiver_balance: c_double,
pub inflation_rate: c_double,
pub newbie_limit: c_double,
pub sender_play_time: c_longlong,
pub receiver_play_time: c_longlong,
pub sender_activity_score: c_double,
pub sender_velocity: c_int,
pub _padding: c_int,
}
#[repr(C)]
#[derive(Debug, Clone, Copy)]
pub struct MarketConfig {
pub base_lambda: c_double,
pub volatility_factor: c_double,
pub seasonal_amplitude: c_double,
pub weekend_multiplier: c_double,
pub newbie_protection_rate: c_double,
pub seasonal_weight: c_double,
pub weekend_weight: c_double,
pub newbie_weight: c_double,
pub inflation_weight: c_double,
}
impl Default for MarketConfig {
fn default() -> Self {
Self {
base_lambda: 0.1, volatility_factor: 1.0,
seasonal_amplitude: 0.15, weekend_multiplier: 1.2,
newbie_protection_rate: 0.2,
seasonal_weight: 0.25, weekend_weight: 0.25,
newbie_weight: 0.25, inflation_weight: 0.25,
}
}
}
#[repr(C)]
#[derive(Debug, Clone, Copy)]
pub struct RegulatorConfig {
pub base_tax_rate: c_double,
pub luxury_threshold: c_double,
pub luxury_tax_rate: c_double,
pub wealth_gap_tax_rate: c_double,
pub poor_threshold: c_double,
pub rich_threshold: c_double,
pub newbie_receive_limit: c_double,
pub warning_ratio: c_double,
pub warning_min_amount: c_double,
pub newbie_hours: c_double,
pub veteran_hours: c_double,
pub velocity_threshold: c_double,
}
impl Default for RegulatorConfig {
fn default() -> Self {
Self {
base_tax_rate: 0.05, luxury_threshold: 100_000.0,
luxury_tax_rate: 0.10, wealth_gap_tax_rate: 0.20,
poor_threshold: 10_000.0, rich_threshold: 1_000_000.0,
newbie_receive_limit: 50_000.0, warning_ratio: 0.9,
warning_min_amount: 50_000.0, newbie_hours: 10.0, veteran_hours: 100.0,
velocity_threshold: 20.0,
}
}
}
#[repr(C)]
#[derive(Debug, Clone, Copy, Default)]
pub struct TransferResult {
pub final_tax: c_double,
pub is_blocked: c_int,
pub warning_code: c_int,
}
impl TransferResult {
pub fn error(code: i32) -> Self {
Self { final_tax: 0.0, is_blocked: 1, warning_code: code }
}
}
#[cfg(test)]
mod tests {
use super::*;
use std::mem;
#[test]
fn verify_ssot_alignment() {
assert_eq!(mem::size_of::<PidState>(), 72);
assert_eq!(mem::size_of::<TradeContext>(), 64);
assert_eq!(mem::size_of::<TransferContext>(), 72);
assert_eq!(mem::size_of::<MarketConfig>(), 72);
assert_eq!(mem::size_of::<RegulatorConfig>(), 96);
assert_eq!(mem::size_of::<TransferResult>(), 16);
assert_eq!(mem::offset_of!(TradeContext, market_heat), 48);
assert_eq!(mem::offset_of!(TradeContext, eco_saturation), 56);
assert_eq!(mem::offset_of!(TransferContext, sender_activity_score), 56);
assert_eq!(mem::offset_of!(RegulatorConfig, velocity_threshold), 88);
}
}

==================================================
FILE: ecobridge-rust\src\economy\control.rs
==================================================

use crate::models::PidState;
pub const DEFAULT_INTEGRATION_LIMIT: f64 = 30.0;
pub const MAX_SAFE_DT: f64 = 1.0;
pub const MIN_TIME_STEP: f64 = 1e-6;
pub const OUTPUT_MIN_CLAMP: f64 = 0.5;
pub const OUTPUT_MAX_CLAMP: f64 = 5.0;
pub const OUTPUT_BASELINE: f64 = 1.0;
pub const INTEGRAL_DECAY: f64 = 0.99999;
pub const BACK_CALC_GAIN: f64 = 0.2;
pub const DERIVATIVE_FILTER_ALPHA: f64 = 0.3;
pub const PANIC_THRESHOLD: f64 = 50.0;
pub const PANIC_DAMPING: f64 = 1.8;
pub const HEAT_SENSITIVITY: f64 = 0.5;
#[inline]
fn sigmoid(x: f64) -> f64 {
1.0 / (1.0 + (-x).exp())
}
pub fn compute_adaptive_gain(cfg: &PidState, heat: f64) -> (f64, f64) {
let sensitivity = (heat * HEAT_SENSITIVITY).tanh();
let adaptive_kp = cfg.kp * (1.0 + sensitivity);
let adaptive_ki = cfg.ki * (1.0 - sensitivity * 0.5);
(adaptive_kp, adaptive_ki)
}
pub fn compute_pid_adjustment_internal(
pid: &mut PidState,
target_vel: f64,
current_vel: f64,
dt: f64,
inflation: f64,
market_heat: f64,
) -> f64 {
if !target_vel.is_finite() || !current_vel.is_finite()
|| !dt.is_finite() || dt < 0.0
|| !inflation.is_finite() || !market_heat.is_finite() {
return OUTPUT_BASELINE;
}
let error = target_vel - current_vel;
let dt_safe = dt.clamp(0.0, MAX_SAFE_DT);
let (base_kp, base_ki) = compute_adaptive_gain(pid, market_heat);
let schedule_gamma = 1.0 + sigmoid((inflation - 0.05) * 20.0);
let active_kp = base_kp * schedule_gamma;
let active_ki = base_ki * schedule_gamma;
let combined_leakage = (1.0 - pid.lambda.clamp(0.0, 1.0)) * INTEGRAL_DECAY;
if pid.is_saturated != 0 {
let back_calc = error * BACK_CALC_GAIN;
pid.integral = pid.integral.mul_add(combined_leakage, back_calc * dt_safe);
} else {
pid.integral = pid.integral.mul_add(combined_leakage, error * dt_safe);
}
let limit = if pid.integration_limit > 0.0 { pid.integration_limit } else { DEFAULT_INTEGRATION_LIMIT };
pid.integral = pid.integral.clamp(-limit, limit);
let delta_pv = current_vel - pid.prev_pv;
let raw_derivative = if dt_safe > MIN_TIME_STEP { delta_pv / dt_safe } else { 0.0 };
pid.filtered_d = DERIVATIVE_FILTER_ALPHA.mul_add(
raw_derivative,
(1.0 - DERIVATIVE_FILTER_ALPHA) * pid.filtered_d
);
pid.prev_pv = current_vel;
let d_multiplier = if pid.filtered_d.abs() > PANIC_THRESHOLD {
PANIC_DAMPING
} else {
1.0
};
let p_term = active_kp * error;
let i_term = active_ki * pid.integral;
let d_term = pid.kd * pid.filtered_d * d_multiplier;
let raw_output = OUTPUT_BASELINE + p_term + i_term - d_term;
let final_output = raw_output.clamp(OUTPUT_MIN_CLAMP, OUTPUT_MAX_CLAMP);
pid.is_saturated = if (raw_output - final_output).abs() > 1e-6 { 1 } else { 0 };
if final_output.is_finite() { final_output } else { OUTPUT_BASELINE }
}
pub fn validate_pid_params(pid: &PidState) -> bool {
pid.kp.is_finite() && pid.kp >= 0.0
&& pid.ki.is_finite() && pid.ki >= 0.0
&& pid.kd.is_finite() && pid.kd >= 0.0
&& pid.lambda.is_finite() && (0.0..=1.0).contains(&pid.lambda)
}
#[cfg(test)]
mod tests {
use super::*;
#[test]
fn test_macro_adaptive_gains() {
let pid = PidState::default();
let (kp_low, _) = compute_adaptive_gain(&pid, 0.1);
let (kp_high, _) = compute_adaptive_gain(&pid, 10.0);
assert!(kp_high > kp_low, "é«˜æµé€Ÿä¸‹å¸‚åœºå¼¹æ€§åº”è‡ªåŠ¨å¢å¼º");
}
#[test]
fn test_anti_windup_clamping() {
let mut pid = PidState::default();
pid.ki = 10.0;
for _ in 0..100 {
compute_pid_adjustment_internal(&mut pid, 100.0, 50.0, 0.1, 0.0, 1.0);
}
assert_eq!(pid.is_saturated, 1, "ç³»ç»Ÿåº”æ­£ç¡®è¯†åˆ«é¥±å’ŒçŠ¶æ€");
}
#[test]
fn test_panic_damping_logic() {
let mut pid = PidState::default();
pid.kd = 1.0;
compute_pid_adjustment_internal(&mut pid, 10.0, 0.0, 0.1, 0.0, 1.0);
let out = compute_pid_adjustment_internal(&mut pid, 10.0, 80.0, 0.1, 0.0, 1.0);
assert!(out < OUTPUT_BASELINE, "ææ…ŒçŠ¶æ€ä¸‹ Dé¡¹åº”äº§ç”Ÿå¼ºåŠ›åå‘å‹åˆ¶");
}
}

==================================================
FILE: ecobridge-rust\src\economy\environment.rs
==================================================

use crate::models::{TradeContext, MarketConfig};
const SECONDS_PER_DAY: f64 = 86400.0;
const SECONDS_PER_WEEK: f64 = 604800.0;
const SECONDS_PER_MONTH: f64 = 2592000.0;
#[inline]
fn sigmoid(x: f64) -> f64 {
1.0 / (1.0 + (-x * 10.0).exp())
}
pub fn calculate_epsilon_internal(
ctx: &TradeContext,
cfg: &MarketConfig,
) -> f64 {
let ts_sec_utc = (ctx.current_timestamp as f64) / 1000.0;
let offset_sec = ctx.timezone_offset as f64;
let ts_sec_local = ts_sec_utc + offset_sec;
let safe_ln = |factor: f64| factor.max(0.01).ln();
let day_wave = (ts_sec_local * 2.0 * std::f64::consts::PI / SECONDS_PER_DAY).sin();
let week_wave = (ts_sec_local * 2.0 * std::f64::consts::PI / SECONDS_PER_WEEK).sin();
let month_wave = (ts_sec_local * 2.0 * std::f64::consts::PI / SECONDS_PER_MONTH).sin();
let seasonal_factor = 0.6 * day_wave + 0.3 * week_wave + 0.1 * month_wave;
let mut f_sea = 1.0 + cfg.seasonal_amplitude * seasonal_factor;
if (ctx.newbie_mask >> 1) & 1 == 1 {
f_sea *= 1.15;
}
let day_index = (ts_sec_local / SECONDS_PER_DAY).floor() as i64;
let day_of_week = (day_index + 4).rem_euclid(7);
let f_wk = if day_of_week >= 5 { cfg.weekend_multiplier } else { 1.0 };
let f_nb = if (ctx.newbie_mask & 1) == 1 {
1.0 - cfg.newbie_protection_rate
} else {
1.0
};
let sigmoid_trigger = sigmoid(ctx.inflation_rate - 0.05);
let f_inf = 1.0 + (ctx.inflation_rate * 0.2 * sigmoid_trigger);
let log_eps =
cfg.seasonal_weight   * safe_ln(f_sea)
+ cfg.weekend_weight    * safe_ln(f_wk)
+ cfg.newbie_weight     * safe_ln(f_nb)
+ cfg.inflation_weight  * safe_ln(f_inf);
log_eps.exp().clamp(0.1, 10.0)
}
#[cfg(test)]
mod tests {
use super::*;
use crate::models::{TradeContext, MarketConfig};
#[test]
fn test_weekend_logic_utc() {
let mut cfg = MarketConfig::default();
cfg.weekend_multiplier = 2.0;
cfg.weekend_weight = 1.0;
cfg.seasonal_weight = 0.0;
cfg.newbie_weight = 0.0;
cfg.inflation_weight = 0.0;
let sat_ts = 2 * 86400 * 1000;
let ctx = TradeContext {
current_timestamp: sat_ts,
timezone_offset: 0,
..Default::default()
};
let eps = calculate_epsilon_internal(&ctx, &cfg);
assert!((eps - 2.0).abs() < 1e-4);
}
#[test]
fn test_weekend_logic_timezone_shift() {
let mut cfg = MarketConfig::default();
cfg.weekend_multiplier = 2.0;
cfg.weekend_weight = 1.0;
cfg.seasonal_weight = 0.0;
cfg.newbie_weight = 0.0;
cfg.inflation_weight = 0.0;
let thu_night_utc = 82_800 * 1000;
let ctx_london = TradeContext {
current_timestamp: thu_night_utc,
timezone_offset: 0,
..Default::default()
};
let eps_london = calculate_epsilon_internal(&ctx_london, &cfg);
assert!((eps_london - 1.0).abs() < 1e-4, "London should be Thursday (1.0)");
let ctx_sg = TradeContext {
current_timestamp: thu_night_utc,
timezone_offset: 8 * 3600,
..Default::default()
};
let eps_sg = calculate_epsilon_internal(&ctx_sg, &cfg);
assert!((eps_sg - 2.0).abs() < 1e-4, "Singapore should be Friday (2.0)");
}
}

==================================================
FILE: ecobridge-rust\src\economy\macro_eco.rs
==================================================

#[inline(always)]
pub fn calculate_inflation_rate(current_heat: f64, m1_supply: f64) -> f64 {
if m1_supply <= 1.0 {
return 0.0;
}
let raw_rate = current_heat / m1_supply;
raw_rate.clamp(-0.15, 0.45)
}
#[inline(always)]
pub fn calculate_stability(
last_volatile_ts: i64,
current_ts: i64,
recovery_window_ms: f64
) -> f64 {
if last_volatile_ts <= 0 {
return 1.0;
}
let diff = (current_ts - last_volatile_ts) as f64;
if diff < 0.0 {
return 1.0;
}
(diff / recovery_window_ms).clamp(0.0, 1.0)
}
#[inline(always)]
pub fn calculate_decay(current_heat: f64, daily_decay_rate: f64, cycles_per_day: f64) -> f64 {
if current_heat.abs() < 1.0 {
return current_heat;
}
let per_cycle_rate = daily_decay_rate / cycles_per_day;
current_heat * per_cycle_rate
}
#[cfg(test)]
mod tests {
use super::*;
#[test]
fn test_inflation_clamp() {
assert_eq!(calculate_inflation_rate(100.0, 1000.0), 0.10);
assert_eq!(calculate_inflation_rate(5000.0, 1000.0), 0.45);
assert_eq!(calculate_inflation_rate(-200.0, 1000.0), -0.15);
}
#[test]
fn test_stability_recovery() {
let window = 1000.0;
assert_eq!(calculate_stability(0, 100, window), 1.0);
assert_eq!(calculate_stability(1000, 1500, window), 0.5);
assert_eq!(calculate_stability(1000, 2500, window), 1.0);
}
#[test]
fn test_decay_logic() {
let reduction = calculate_decay(1000.0, 0.48, 48.0);
assert_eq!(reduction, 10.0);
let reset_val = calculate_decay(0.5, 0.1, 48.0);
assert_eq!(reset_val, 0.5);
}
}

==================================================
FILE: ecobridge-rust\src\economy\mod.rs
==================================================

pub mod control;
pub mod environment;
pub mod pricing;
pub mod summation;
pub use crate::models::{PidState, MarketConfig, TradeContext, HistoryRecord};
pub use control::{
compute_pid_adjustment_internal,
validate_pid_params
};
pub use environment::{
calculate_epsilon_internal
};
pub use pricing::{
compute_price_final_internal,
predict_price_advanced
};
pub use summation::{
query_neff_internal
};
pub const DEFAULT_LAMBDA: f64 = 0.01;
pub const DEFAULT_TAU: f64 = 7.0;
pub const MIN_PHYSICAL_PRICE: f64 = 0.01;
#[inline]
pub fn get_default_params() -> (f64, f64) {
(DEFAULT_LAMBDA, DEFAULT_TAU)
}
#[inline]
pub fn validate_params(lambda: f64, tau: f64) -> bool {
lambda.is_finite() && lambda > 0.0 &&
tau.is_finite() && tau > 0.0
}
#[cfg(test)]
mod tests {
use super::*;
#[test]
fn test_params_safety_check() {
assert!(validate_params(0.01, 7.0));
assert!(!validate_params(0.0, 7.0));
assert!(!validate_params(f64::NAN, 7.0));
}
#[test]
fn test_economic_pipeline_integration() {
let mut pid = PidState::default();
assert!(validate_pid_params(&pid));
let config = MarketConfig::default();
let ctx = TradeContext {
base_price: 100.0,
current_timestamp: 1736851200000,
newbie_mask: 1,
inflation_rate: 0.02,
..Default::default()
};
let eps = calculate_epsilon_internal(&ctx, &config);
assert!(eps > 0.1 && eps < 10.0);
let vol = 36.5;
let adjustment = compute_pid_adjustment_internal(&mut pid, 100.0, 95.0, 1.0, ctx.inflation_rate);
assert!(adjustment.is_finite());
let final_price = compute_price_final_internal(100.0, vol, 0.01, eps);
assert!(final_price > MIN_PHYSICAL_PRICE);
}
#[test]
fn test_extreme_clamping_logic() {
let base_price = 100.0;
let infinite_vol = 1e18;
let lambda = 0.5;
let eps = 1.0;
let price = compute_price_final_internal(base_price, infinite_vol, lambda, eps);
assert!(price >= MIN_PHYSICAL_PRICE);
}
}

==================================================
FILE: ecobridge-rust\src\economy\pricing.rs
==================================================

fn compute_price_behavioral_core(
base_price: f64,
n_eff: f64,
trade_amount: f64,
lambda: f64,
epsilon: f64,
) -> f64 {
if !base_price.is_finite() || !n_eff.is_finite() ||
!lambda.is_finite() || !epsilon.is_finite() {
return 0.01;
}
let adj_lambda = if trade_amount > 0.0 {
lambda * 0.6
} else {
lambda
};
let total_n = n_eff + trade_amount;
let raw_exponent = (-adj_lambda * total_n).clamp(-100.0, 100.0);
let clamped_exponent = 10.0 * (raw_exponent / 10.0).tanh();
let final_price = base_price * epsilon * clamped_exponent.exp();
final_price.max(0.01)
}
pub fn compute_tier_price_internal(
base_price: f64,
quantity: f64,
is_sell: bool
) -> f64 {
if !is_sell || quantity <= 500.0 || quantity <= 0.0 {
return base_price;
}
let mut total_value = 0.0;
let mut remaining = quantity;
let t1 = remaining.min(500.0);
total_value += t1 * base_price;
remaining -= t1;
if remaining > 0.0 {
let t2 = remaining.min(1500.0);
total_value += t2 * (base_price * 0.85);
remaining -= t2;
}
if remaining > 0.0 {
total_value += remaining * (base_price * 0.60);
}
total_value / quantity
}
pub fn compute_price_with_floor(
base: f64, n_eff: f64, trade_amt: f64, lambda: f64, epsilon: f64,
hist_avg: f64
) -> f64 {
let raw_price = compute_price_humane_internal(base, n_eff, trade_amt, lambda, epsilon);
let floor = (hist_avg * 0.2).max(0.01);
if raw_price < floor {
floor
} else {
raw_price
}
}
#[no_mangle]
pub fn compute_price_final_internal(
base_price: f64,
n_eff: f64,
lambda: f64,
epsilon: f64,
) -> f64 {
compute_price_behavioral_core(base_price, n_eff, 0.0, lambda, epsilon)
}
#[no_mangle]
pub fn predict_price_advanced(
base_price: f64,
n_eff_current: f64,
trade_amount_amount: f64,
lambda: f64,
eps_future: f64,
) -> f64 {
compute_price_behavioral_core(base_price, n_eff_current, trade_amount_amount, lambda, eps_future)
}
#[no_mangle]
pub fn compute_price_humane_internal(
base_price: f64,
n_eff: f64,
trade_amount: f64,
base_lambda: f64,
epsilon: f64,
) -> f64 {
compute_price_behavioral_core(base_price, n_eff, trade_amount, base_lambda, epsilon)
}
#[cfg(test)]
mod tests {
use super::*;
#[test]
fn test_behavioral_consistency() {
let base = 100.0;
let lambda = 0.01;
let p_sell = compute_price_behavioral_core(base, 0.0, 10.0, lambda, 1.0);
let p_buy = compute_price_behavioral_core(base, 0.0, -10.0, lambda, 1.0);
let drop = base - p_sell;
let rise = p_buy - base;
assert!(drop < rise, "ä¸‹è·Œåº”æ¯”ä¸Šæ¶¨æ›´å¹³ç¼“ (æŸå¤±åŒæ¶ä¿æŠ¤)");
}
#[test]
fn test_tier_pricing() {
let base = 10.0;
assert_eq!(compute_tier_price_internal(base, 100.0, true), 10.0);
let p2 = compute_tier_price_internal(base, 1000.0, true);
assert!((p2 - 9.25).abs() < 1e-6);
assert_eq!(compute_tier_price_internal(base, 1000.0, false), 10.0);
}
#[test]
fn test_floor_protection() {
let hist_avg = 50.0;
let p1 = compute_price_with_floor(12.0, 0.0, 0.0, 0.0, 1.0, hist_avg);
assert_eq!(p1, 12.0);
let p2 = compute_price_with_floor(5.0, 0.0, 0.0, 0.0, 1.0, hist_avg);
assert_eq!(p2, 10.0);
}
}

==================================================
FILE: ecobridge-rust\src\economy\summation.rs
==================================================

use crate::models::HistoryRecord;
use crate::storage;
use std::sync::RwLock;
use lazy_static::lazy_static;
#[cfg(target_arch = "x86_64")]
use std::arch::x86_64::*;
#[cfg(feature = "parallel")]
use rayon::prelude::*;
const PARALLEL_THRESHOLD: usize = 750;
const MS_PER_DAY: f64 = 86_400_000.0;
const MAX_FUTURE_TOLERANCE: i64 = 60_000;
lazy_static! {
static ref HOT_HISTORY: RwLock<Vec<HistoryRecord>> = RwLock::new(Vec::with_capacity(100_000));
}
pub fn hydrate_hot_store() {
let records = storage::load_recent_history(30);
let len = records.len();
let mut lock = HOT_HISTORY.write().unwrap();
*lock = records;
println!("[EcoBridge-Native] SIMD å¼•æ“çƒ­æ•°æ®è£…å¡«å®Œæˆ: {} æ¡è®°å½•", len);
}
pub fn append_trade_to_memory(ts: i64, amount: f64) {
let mut lock = HOT_HISTORY.write().unwrap();
lock.push(HistoryRecord {
timestamp: ts,
amount,
});
}
pub fn query_neff_internal(
current_ts: i64,
tau: f64,
) -> f64 {
let lock = HOT_HISTORY.read().unwrap();
calculate_volume_in_memory(&lock, current_ts, tau)
}
pub fn calculate_volume_in_memory(
history: &[HistoryRecord],
current_time: i64,
tau: f64,
) -> f64 {
if history.is_empty() || tau <= 0.0 {
return 0.0;
}
let lambda = 1.0 / (tau * MS_PER_DAY);
let valid_future_limit = current_time + MAX_FUTURE_TOLERANCE;
let valid_past_limit = current_time - (tau * MS_PER_DAY * 10.0) as i64;
let is_valid_record = |r: &&HistoryRecord| -> bool {
r.timestamp <= valid_future_limit && r.timestamp >= valid_past_limit
};
let t_min = history.iter()
.filter(is_valid_record)
.map(|r| r.timestamp)
.min()
.unwrap_or(current_time);
let base_multiplier = (-(current_time - t_min) as f64 * lambda).exp();
#[cfg(target_arch = "x86_64")]
if is_x86_feature_detected!("avx2") {
let sum_partial = unsafe {
compute_partial_simd(history, t_min, lambda, valid_future_limit, valid_past_limit)
};
let result = sum_partial * base_multiplier;
return if result.is_finite() { result } else { 0.0 };
}
let compute_partial = |rec: &HistoryRecord| -> f64 {
if rec.timestamp > valid_future_limit || rec.timestamp < valid_past_limit {
return 0.0;
}
let dt_rel = rec.timestamp.saturating_sub(t_min) as f64;
rec.amount * (dt_rel * lambda).exp()
};
let sum_partial: f64 = if history.len() >= PARALLEL_THRESHOLD {
#[cfg(feature = "parallel")]
{
history.par_iter().map(compute_partial).sum()
}
#[cfg(not(feature = "parallel"))]
{
history.iter().map(compute_partial).sum()
}
} else {
history.iter().map(compute_partial).sum()
};
let result = sum_partial * base_multiplier;
if result.is_finite() { result } else { 0.0 }
}
#[cfg(target_arch = "x86_64")]
#[target_feature(enable = "avx2")]
unsafe fn compute_partial_simd(
history: &[HistoryRecord],
t_min: i64,
lambda: f64,
valid_future: i64,
valid_past: i64
) -> f64 {
let mut sum_vec = _mm256_setzero_pd();
let v_tmin = _mm256_set1_pd(t_min as f64);
let v_lambda = _mm256_set1_pd(lambda);
let chunks = history.chunks_exact(4);
let remainder = chunks.remainder();
for chunk in chunks {
let t0 = chunk[0].timestamp; let t1 = chunk[1].timestamp;
let t2 = chunk[2].timestamp; let t3 = chunk[3].timestamp;
if t0 > valid_future || t0 < valid_past ||
t1 > valid_future || t1 < valid_past ||
t2 > valid_future || t2 < valid_past ||
t3 > valid_future || t3 < valid_past {
for r in chunk {
if r.timestamp <= valid_future && r.timestamp >= valid_past {
let dt = (r.timestamp - t_min) as f64;
let val = r.amount * (dt * lambda).exp();
let v_val = _mm256_set_pd(0.0, 0.0, 0.0, val);
sum_vec = _mm256_add_pd(sum_vec, v_val);
}
}
continue;
}
let v_ts = _mm256_set_pd(
chunk[3].timestamp as f64,
chunk[2].timestamp as f64,
chunk[1].timestamp as f64,
chunk[0].timestamp as f64,
);
let v_amount = _mm256_set_pd(
chunk[3].amount,
chunk[2].amount,
chunk[1].amount,
chunk[0].amount,
);
let v_dt = _mm256_sub_pd(v_ts, v_tmin);
let v_exponent = _mm256_mul_pd(v_dt, v_lambda);
let mut arr = [0.0f64; 4];
_mm256_storeu_pd(arr.as_mut_ptr(), v_exponent);
arr[0] = arr[0].exp();
arr[1] = arr[1].exp();
arr[2] = arr[2].exp();
arr[3] = arr[3].exp();
let v_exp = _mm256_loadu_pd(arr.as_ptr());
let v_partial = _mm256_mul_pd(v_amount, v_exp);
sum_vec = _mm256_add_pd(sum_vec, v_partial);
}
let mut temp = [0.0f64; 4];
_mm256_storeu_pd(temp.as_mut_ptr(), sum_vec);
let mut total = temp[0] + temp[1] + temp[2] + temp[3];
for rec in remainder {
if rec.timestamp <= valid_future && rec.timestamp >= valid_past {
let dt = (rec.timestamp - t_min) as f64;
total += rec.amount * (dt * lambda).exp();
}
}
total
}

==================================================
FILE: ecobridge-rust\src\security\mod.rs
==================================================

pub mod regulator;
pub use crate::models::RegulatorConfig;
pub use regulator::{
compute_transfer_check_internal,
is_high_risk_transfer,
CODE_NORMAL,
CODE_WARNING_HIGH_RISK,
CODE_BLOCK_REVERSE_FLOW,
CODE_BLOCK_INJECTION,
CODE_BLOCK_INSUFFICIENT_FUNDS,
CODE_BLOCK_VELOCITY_LIMIT,
};

==================================================
FILE: ecobridge-rust\src\security\regulator.rs
==================================================

use crate::models::{TransferContext, TransferResult, RegulatorConfig};
pub const CODE_NORMAL: i32 = 0;
pub const CODE_WARNING_HIGH_RISK: i32 = 1;
pub const CODE_BLOCK_REVERSE_FLOW: i32 = 2;
pub const CODE_BLOCK_INJECTION: i32 = 3;
pub const CODE_BLOCK_INSUFFICIENT_FUNDS: i32 = 4;
pub const CODE_BLOCK_VELOCITY_LIMIT: i32 = 5;
pub fn compute_transfer_check_internal(
ctx: &TransferContext,
cfg: &RegulatorConfig,
) -> TransferResult {
let amount = ctx.amount.max(0.0);
let sender_bal = ctx.sender_balance.max(0.0);
let receiver_bal = ctx.receiver_balance.max(0.0);
if amount > sender_bal {
return TransferResult {
final_tax: 0.0,
is_blocked: 1,
warning_code: CODE_BLOCK_INSUFFICIENT_FUNDS,
};
}
let puppet_factor = if ctx.sender_activity_score < 0.1 {
ctx.sender_velocity as f64 * 2.0
} else {
ctx.sender_velocity as f64 / ctx.sender_activity_score.max(0.1)
};
if puppet_factor > cfg.velocity_threshold {
return TransferResult {
final_tax: 0.0,
is_blocked: 1,
warning_code: CODE_BLOCK_VELOCITY_LIMIT,
};
}
let newbie_threshold_sec = cfg.newbie_hours * 3600.0;
let veteran_threshold_sec = cfg.veteran_hours * 3600.0;
if (ctx.sender_play_time as f64) < newbie_threshold_sec
&& (ctx.receiver_play_time as f64) > veteran_threshold_sec
&& amount > ctx.newbie_limit
{
return TransferResult {
final_tax: 0.0,
is_blocked: 1,
warning_code: CODE_BLOCK_REVERSE_FLOW
};
}
let mut warning_code = CODE_NORMAL;
let risk_ratio = amount / sender_bal.max(1.0);
if risk_ratio > cfg.warning_ratio || puppet_factor > (cfg.velocity_threshold * 0.7) {
warning_code = CODE_WARNING_HIGH_RISK;
}
let inflation_adj = 1.0 + ctx.inflation_rate.max(0.0);
let mut tax = amount * cfg.base_tax_rate * inflation_adj;
let behavioral_penalty = (ctx.sender_velocity as f64 * 0.05).exp();
tax *= behavioral_penalty;
if amount > cfg.luxury_threshold {
let excess = amount - cfg.luxury_threshold;
tax = excess.mul_add(cfg.luxury_tax_rate, tax);
}
if sender_bal < cfg.poor_threshold && receiver_bal > cfg.rich_threshold {
let gap_tax = amount * cfg.wealth_gap_tax_rate;
tax = tax.max(gap_tax);
}
let tax_clamped = tax.min(amount * 0.8);
TransferResult {
final_tax: tax_clamped,
is_blocked: 0,
warning_code,
}
}
pub fn is_high_risk_transfer(result: &crate::models::TransferResult) -> bool {
result.is_blocked == 1 || result.warning_code == CODE_WARNING_HIGH_RISK
}

==================================================
FILE: ecobridge-rust\src\storage\mod.rs
==================================================

use crossbeam_channel::{bounded, Receiver, Sender};
use duckdb::{params, Connection};
use std::ops::Deref;
use std::path::PathBuf;
use std::sync::atomic::{AtomicU64, Ordering};
use std::sync::{OnceLock, RwLock};
use std::thread;
use libc::c_int;
use lazy_static::lazy_static;
use crate::models::HistoryRecord;
lazy_static! {
static ref GLOBAL_HISTORY: RwLock<Vec<HistoryRecord>> = RwLock::new(Vec::with_capacity(200_000));
}
static LOG_SENDER: OnceLock<Sender<LogEvent>> = OnceLock::new();
static READ_POOL: OnceLock<ConnectionPool> = OnceLock::new();
static TOTAL_LOGS: AtomicU64 = AtomicU64::new(0);
static DROPPED_LOGS: AtomicU64 = AtomicU64::new(0);
struct LogEvent {
ts: i64,
uuid: String,
delta: f64,
balance: f64,
meta: String,
}
struct ConnectionPool {
available: Receiver<Connection>,
recycle: Sender<Connection>,
}
struct DbConnectionGuard {
conn: Option<Connection>,
pool_sender: Sender<Connection>,
}
impl Deref for DbConnectionGuard {
type Target = Connection;
fn deref(&self) -> &Self::Target {
self.conn.as_ref().unwrap()
}
}
impl Drop for DbConnectionGuard {
fn drop(&mut self) {
if let Some(conn) = self.conn.take() {
let _ = self.pool_sender.send(conn);
}
}
}
pub fn shutdown_db_internal() -> c_int {
if let Some(sender) = LOG_SENDER.get() {
let res = sender.send(LogEvent {
ts: -1,
uuid: String::new(),
delta: 0.0,
balance: 0.0,
meta: String::from("SHUTDOWN_SIGNAL"),
});
if res.is_ok() {
return 0;
}
}
-1
}
pub fn init_economy_db(path_str: &str) -> c_int {
if LOG_SENDER.get().is_some() {
return 0;
}
let mut db_path = PathBuf::from(path_str);
db_path.push("ecobridge_vault.db");
let write_conn = match Connection::open(&db_path) {
Ok(c) => c,
Err(e) => {
eprintln!("[EcoBridge-Storage] DB Open Error: {}", e);
return -4;
}
};
let ddl_res = write_conn.execute_batch(
"PRAGMA journal_mode=WAL;
PRAGMA synchronous=NORMAL;
PRAGMA busy_timeout=5000;
CREATE TABLE IF NOT EXISTS economy_log (
ts BIGINT,
player_uuid VARCHAR,
delta DOUBLE,
balance DOUBLE,
metadata VARCHAR
);
CREATE INDEX IF NOT EXISTS idx_ts ON economy_log (ts);"
);
if let Err(e) = ddl_res {
eprintln!("[EcoBridge-Storage] DDL Error: {}", e);
return -5;
}
load_recent_history_to_memory(&write_conn);
let pool_size = 4;
let (pool_tx, pool_rx) = bounded(pool_size);
for _i in 0..pool_size {
if let Ok(c) = write_conn.try_clone() {
let _ = pool_tx.send(c);
}
}
READ_POOL.set(ConnectionPool {
available: pool_rx,
recycle: pool_tx,
}).ok();
let (tx, rx) = bounded(50_000);
thread::Builder::new()
.name("ecobridge-db-writer".into())
.spawn(move || writer_loop(write_conn, rx))
.expect("Failed to spawn DB writer thread");
match LOG_SENDER.set(tx) {
Ok(_) => 0,
Err(_) => -7,
}
}
fn load_recent_history_to_memory(conn: &Connection) {
let now = std::time::SystemTime::now()
.duration_since(std::time::UNIX_EPOCH)
.unwrap_or_default()
.as_millis() as i64;
let cutoff = now - (90i64 * 86_400_000);
println!("[EcoBridge-Storage] æ­£åœ¨é¢„çƒ­å†…å­˜æ•°æ® (Cutoff: {})...", cutoff);
let mut stmt = match conn.prepare("SELECT ts, delta FROM economy_log WHERE ts > ? ORDER BY ts ASC") {
Ok(s) => s,
Err(e) => {
eprintln!("[EcoBridge-Storage] Preload Prepare Error: {}", e);
return;
}
};
let records_iter = stmt.query_map(params![cutoff], |row| {
Ok(HistoryRecord {
timestamp: row.get(0)?,
amount: row.get(1)?,
})
});
match records_iter {
Ok(iter) => {
let mut hist = GLOBAL_HISTORY.write().unwrap();
let start_len = hist.len();
for rec in iter {
if let Ok(r) = rec {
hist.push(r);
}
}
println!("[EcoBridge-Storage] é¢„çƒ­å®Œæˆã€‚åŠ è½½äº† {} æ¡è®°å½•åˆ°å†…å­˜ã€‚", hist.len() - start_len);
}
Err(e) => eprintln!("[EcoBridge-Storage] Preload Query Error: {}", e),
}
}
pub fn get_history_read() -> std::sync::RwLockReadGuard<'static, Vec<HistoryRecord>> {
GLOBAL_HISTORY.read().unwrap()
}
pub fn log_economy_event(ts: i64, uuid: String, delta: f64, balance: f64, meta: String) {
TOTAL_LOGS.fetch_add(1, Ordering::Relaxed);
{
if let Ok(mut hist) = GLOBAL_HISTORY.write() {
hist.push(HistoryRecord { timestamp: ts, amount: delta });
if hist.len() > 500_000 {
let keep = 400_000;
let remove_count = hist.len() - keep;
hist.drain(0..remove_count);
}
}
}
if let Some(sender) = LOG_SENDER.get() {
if let Err(_) = sender.try_send(LogEvent { ts, uuid, delta, balance, meta }) {
DROPPED_LOGS.fetch_add(1, Ordering::Relaxed);
}
} else {
DROPPED_LOGS.fetch_add(1, Ordering::Relaxed);
}
}
fn writer_loop(conn: Connection, rx: Receiver<LogEvent>) {
let mut buffer = Vec::with_capacity(1024);
loop {
let first = match rx.recv() {
Ok(msg) => msg,
Err(_) => break,
};
if first.ts == -1 {
eprintln!("[EcoBridge-Storage] æ¥æ”¶åˆ°å…³æœºä¿¡å·ï¼Œæ­£åœ¨å†²åˆ·ç¼“å­˜å¹¶é€€å‡º...");
break;
}
buffer.push(first);
while buffer.len() < 1024 {
match rx.try_recv() {
Ok(msg) => {
if msg.ts == -1 { break; }
buffer.push(msg);
},
Err(_) => break,
}
}
flush_buffer_to_db(&conn, &mut buffer);
}
if !buffer.is_empty() {
flush_buffer_to_db(&conn, &mut buffer);
}
eprintln!("[EcoBridge-Storage] åå°å†™å…¥çº¿ç¨‹å·²å®‰å…¨ç»ˆæ­¢ã€‚");
}
fn flush_buffer_to_db(conn: &Connection, buffer: &mut Vec<LogEvent>) {
if buffer.is_empty() { return; }
match conn.appender("economy_log") {
Ok(mut appender) => {
for ev in buffer.drain(..) {
if appender.append_row(params![ev.ts, ev.uuid, ev.delta, ev.balance, ev.meta]).is_err() {
DROPPED_LOGS.fetch_add(1, Ordering::Relaxed);
}
}
}
Err(e) => {
eprintln!("[EcoBridge-Storage] Appender Error: {}", e);
DROPPED_LOGS.fetch_add(buffer.len() as u64, Ordering::Relaxed);
buffer.clear();
}
}
}
pub fn query_neff_from_db(current_ts: i64, tau: f64) -> f64 {
let pool = match READ_POOL.get() {
Some(p) => p,
None => return 0.0,
};
let raw_conn = match pool.available.recv() {
Ok(c) => c,
Err(_) => return 0.0,
};
let conn_guard = DbConnectionGuard {
conn: Some(raw_conn),
pool_sender: pool.recycle.clone(),
};
let query = "SELECT SUM(ABS(delta) * EXP( -1.0 * (?1 - ts) / (?2 * 86400000.0) )) FROM economy_log WHERE ts > ?3";
let ms_per_day = 86_400_000.0;
let safe_lookback_ms = (tau * ms_per_day * 3.0) as i64;
let min_ts = current_ts - safe_lookback_ms;
conn_guard.query_row(query, params![current_ts, tau, min_ts], |row| row.get(0)).unwrap_or(0.0)
}
pub fn get_total_logs() -> u64 { TOTAL_LOGS.load(Ordering::Relaxed) }
pub fn get_dropped_logs() -> u64 { DROPPED_LOGS.load(Ordering::Relaxed) }
pub fn load_recent_history(days: i64) -> Vec<crate::models::HistoryRecord> {
let pool = match READ_POOL.get() {
Some(p) => p,
None => return Vec::new(),
};
let raw_conn = match pool.available.recv() {
Ok(c) => c,
Err(_) => return Vec::new(),
};
let ms_lookback = days * 86_400_000;
let cutoff = chrono::Utc::now().timestamp_millis() - ms_lookback;
let query = "
SELECT ts, delta
FROM economy_log
WHERE ts > ?
ORDER BY ts ASC
";
let mut stmt = raw_conn.prepare(query).unwrap();
let record_iter = stmt.query_map(params![cutoff], |row| {
Ok(crate::models::HistoryRecord {
timestamp: row.get(0)?,
amount: row.get::<_, f64>(1)?.abs(),
})
}).unwrap();
let mut history = Vec::new();
for record in record_iter {
if let Ok(r) = record {
history.push(r);
}
}
let _ = pool.recycle.send(raw_conn);
history
}
